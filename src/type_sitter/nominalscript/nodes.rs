#[doc = "Typed node `_primary_nominal_type`\n\nThis node type is a supertype of:\n- `array_nominal_type` ([ArrayNominalType])\n- `generic_nominal_type` ([GenericNominalType])\n- `nominal_type_identifier` ([NominalTypeIdentifier])\n- `object_nominal_type` ([ObjectNominalType])\n- `parenthesized_nominal_type` ([ParenthesizedNominalType])\n- `tuple_nominal_type` ([TupleNominalType])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub enum PrimaryNominalType<'tree> {
    ArrayNominalType(ArrayNominalType<'tree>),
    GenericNominalType(GenericNominalType<'tree>),
    NominalTypeIdentifier(NominalTypeIdentifier<'tree>),
    ObjectNominalType(ObjectNominalType<'tree>),
    ParenthesizedNominalType(ParenthesizedNominalType<'tree>),
    TupleNominalType(TupleNominalType<'tree>),
}
#[automatically_derived]
impl<'tree> PrimaryNominalType<'tree> {
    #[doc = "Returns the node if it is of kind `array_nominal_type` ([ArrayNominalType]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn array_nominal_type(self) -> Option<ArrayNominalType<'tree>> {
        match self {
            Self::ArrayNominalType(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `generic_nominal_type` ([GenericNominalType]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn generic_nominal_type(self) -> Option<GenericNominalType<'tree>> {
        match self {
            Self::GenericNominalType(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `nominal_type_identifier` ([NominalTypeIdentifier]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn nominal_type_identifier(self) -> Option<NominalTypeIdentifier<'tree>> {
        match self {
            Self::NominalTypeIdentifier(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `object_nominal_type` ([ObjectNominalType]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn object_nominal_type(self) -> Option<ObjectNominalType<'tree>> {
        match self {
            Self::ObjectNominalType(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `parenthesized_nominal_type` ([ParenthesizedNominalType]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn parenthesized_nominal_type(self) -> Option<ParenthesizedNominalType<'tree>> {
        match self {
            Self::ParenthesizedNominalType(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `tuple_nominal_type` ([TupleNominalType]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn tuple_nominal_type(self) -> Option<TupleNominalType<'tree>> {
        match self {
            Self::TupleNominalType(x) => Some(x),
            _ => None,
        }
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for PrimaryNominalType<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        match node.kind() {
            "array_nominal_type" => {
                Ok(unsafe {
                    Self :: ArrayNominalType (< ArrayNominalType < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "generic_nominal_type" => Ok(unsafe {
                Self :: GenericNominalType (< GenericNominalType < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
            }),
            "nominal_type_identifier" => Ok(unsafe {
                Self :: NominalTypeIdentifier (< NominalTypeIdentifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
            }),
            "object_nominal_type" => {
                Ok(unsafe {
                    Self :: ObjectNominalType (< ObjectNominalType < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "parenthesized_nominal_type" => Ok(unsafe {
                Self :: ParenthesizedNominalType (< ParenthesizedNominalType < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
            }),
            "tuple_nominal_type" => {
                Ok(unsafe {
                    Self :: TupleNominalType (< TupleNominalType < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            _ => Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            }),
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for PrimaryNominalType<'tree> {
    const KIND: &'static str = "_primary_nominal_type";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        match self {
            Self::ArrayNominalType(x) => x.node(),
            Self::GenericNominalType(x) => x.node(),
            Self::NominalTypeIdentifier(x) => x.node(),
            Self::ObjectNominalType(x) => x.node(),
            Self::ParenthesizedNominalType(x) => x.node(),
            Self::TupleNominalType(x) => x.node(),
        }
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        match self {
            Self::ArrayNominalType(x) => x.node_mut(),
            Self::GenericNominalType(x) => x.node_mut(),
            Self::NominalTypeIdentifier(x) => x.node_mut(),
            Self::ObjectNominalType(x) => x.node_mut(),
            Self::ParenthesizedNominalType(x) => x.node_mut(),
            Self::TupleNominalType(x) => x.node_mut(),
        }
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        match self {
            Self::ArrayNominalType(x) => x.into_node(),
            Self::GenericNominalType(x) => x.into_node(),
            Self::NominalTypeIdentifier(x) => x.into_node(),
            Self::ObjectNominalType(x) => x.into_node(),
            Self::ParenthesizedNominalType(x) => x.into_node(),
            Self::TupleNominalType(x) => x.into_node(),
        }
    }
}
#[doc = "Typed node `_primary_type`\n\nThis node type is a supertype of:\n- `array_type` ([ArrayType])\n- `conditional_type` ([ConditionalType])\n- `existential_type` ([ExistentialType])\n- `flow_maybe_type` ([FlowMaybeType])\n- `generic_type` ([GenericType])\n- `index_type_query` ([IndexTypeQuery])\n- `intersection_type` ([IntersectionType])\n- `literal_type` ([LiteralType])\n- `lookup_type` ([LookupType])\n- `nested_type_identifier` ([NestedTypeIdentifier])\n- `object_type` ([ObjectType])\n- `parenthesized_type` ([ParenthesizedType])\n- `predefined_type` ([PredefinedType])\n- `template_literal_type` ([TemplateLiteralType])\n- `this_type` ([ThisType])\n- `tuple_type` ([TupleType])\n- `type_identifier` ([TypeIdentifier])\n- `type_query` ([TypeQuery])\n- `union_type` ([UnionType])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub enum PrimaryType<'tree> {
    ArrayType(ArrayType<'tree>),
    ConditionalType(ConditionalType<'tree>),
    ExistentialType(ExistentialType<'tree>),
    FlowMaybeType(FlowMaybeType<'tree>),
    GenericType(GenericType<'tree>),
    IndexTypeQuery(IndexTypeQuery<'tree>),
    IntersectionType(IntersectionType<'tree>),
    LiteralType(LiteralType<'tree>),
    LookupType(LookupType<'tree>),
    NestedTypeIdentifier(NestedTypeIdentifier<'tree>),
    ObjectType(ObjectType<'tree>),
    ParenthesizedType(ParenthesizedType<'tree>),
    PredefinedType(PredefinedType<'tree>),
    TemplateLiteralType(TemplateLiteralType<'tree>),
    ThisType(ThisType<'tree>),
    TupleType(TupleType<'tree>),
    TypeIdentifier(TypeIdentifier<'tree>),
    TypeQuery(TypeQuery<'tree>),
    UnionType(UnionType<'tree>),
}
#[automatically_derived]
impl<'tree> PrimaryType<'tree> {
    #[doc = "Returns the node if it is of kind `array_type` ([ArrayType]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn array_type(self) -> Option<ArrayType<'tree>> {
        match self {
            Self::ArrayType(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `conditional_type` ([ConditionalType]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn conditional_type(self) -> Option<ConditionalType<'tree>> {
        match self {
            Self::ConditionalType(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `existential_type` ([ExistentialType]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn existential_type(self) -> Option<ExistentialType<'tree>> {
        match self {
            Self::ExistentialType(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `flow_maybe_type` ([FlowMaybeType]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn flow_maybe_type(self) -> Option<FlowMaybeType<'tree>> {
        match self {
            Self::FlowMaybeType(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `generic_type` ([GenericType]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn generic_type(self) -> Option<GenericType<'tree>> {
        match self {
            Self::GenericType(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `index_type_query` ([IndexTypeQuery]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn index_type_query(self) -> Option<IndexTypeQuery<'tree>> {
        match self {
            Self::IndexTypeQuery(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `intersection_type` ([IntersectionType]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn intersection_type(self) -> Option<IntersectionType<'tree>> {
        match self {
            Self::IntersectionType(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `literal_type` ([LiteralType]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn literal_type(self) -> Option<LiteralType<'tree>> {
        match self {
            Self::LiteralType(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `lookup_type` ([LookupType]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn lookup_type(self) -> Option<LookupType<'tree>> {
        match self {
            Self::LookupType(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `nested_type_identifier` ([NestedTypeIdentifier]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn nested_type_identifier(self) -> Option<NestedTypeIdentifier<'tree>> {
        match self {
            Self::NestedTypeIdentifier(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `object_type` ([ObjectType]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn object_type(self) -> Option<ObjectType<'tree>> {
        match self {
            Self::ObjectType(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `parenthesized_type` ([ParenthesizedType]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn parenthesized_type(self) -> Option<ParenthesizedType<'tree>> {
        match self {
            Self::ParenthesizedType(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `predefined_type` ([PredefinedType]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn predefined_type(self) -> Option<PredefinedType<'tree>> {
        match self {
            Self::PredefinedType(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `template_literal_type` ([TemplateLiteralType]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn template_literal_type(self) -> Option<TemplateLiteralType<'tree>> {
        match self {
            Self::TemplateLiteralType(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `this_type` ([ThisType]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn this_type(self) -> Option<ThisType<'tree>> {
        match self {
            Self::ThisType(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `tuple_type` ([TupleType]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn tuple_type(self) -> Option<TupleType<'tree>> {
        match self {
            Self::TupleType(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `type_identifier` ([TypeIdentifier]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn type_identifier(self) -> Option<TypeIdentifier<'tree>> {
        match self {
            Self::TypeIdentifier(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `type_query` ([TypeQuery]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn type_query(self) -> Option<TypeQuery<'tree>> {
        match self {
            Self::TypeQuery(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `union_type` ([UnionType]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn union_type(self) -> Option<UnionType<'tree>> {
        match self {
            Self::UnionType(x) => Some(x),
            _ => None,
        }
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for PrimaryType<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        match node.kind() {
            "array_type" => {
                Ok(unsafe {
                    Self :: ArrayType (< ArrayType < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "conditional_type" => Ok(unsafe {
                Self::ConditionalType(<ConditionalType<'tree> as type_sitter_lib::TypedNode<
                    'tree,
                >>::from_node_unchecked(node))
            }),
            "existential_type" => Ok(unsafe {
                Self::ExistentialType(<ExistentialType<'tree> as type_sitter_lib::TypedNode<
                    'tree,
                >>::from_node_unchecked(node))
            }),
            "flow_maybe_type" => Ok(unsafe {
                Self::FlowMaybeType(<FlowMaybeType<'tree> as type_sitter_lib::TypedNode<
                    'tree,
                >>::from_node_unchecked(node))
            }),
            "generic_type" => {
                Ok(unsafe {
                    Self :: GenericType (< GenericType < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "index_type_query" => Ok(unsafe {
                Self::IndexTypeQuery(<IndexTypeQuery<'tree> as type_sitter_lib::TypedNode<
                    'tree,
                >>::from_node_unchecked(node))
            }),
            "intersection_type" => {
                Ok(unsafe {
                    Self :: IntersectionType (< IntersectionType < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "literal_type" => {
                Ok(unsafe {
                    Self :: LiteralType (< LiteralType < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "lookup_type" => {
                Ok(unsafe {
                    Self :: LookupType (< LookupType < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "nested_type_identifier" => Ok(unsafe {
                Self :: NestedTypeIdentifier (< NestedTypeIdentifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
            }),
            "object_type" => {
                Ok(unsafe {
                    Self :: ObjectType (< ObjectType < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "parenthesized_type" => {
                Ok(unsafe {
                    Self :: ParenthesizedType (< ParenthesizedType < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "predefined_type" => Ok(unsafe {
                Self::PredefinedType(<PredefinedType<'tree> as type_sitter_lib::TypedNode<
                    'tree,
                >>::from_node_unchecked(node))
            }),
            "template_literal_type" => Ok(unsafe {
                Self :: TemplateLiteralType (< TemplateLiteralType < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
            }),
            "this_type" => Ok(unsafe {
                Self::ThisType(
                    <ThisType<'tree> as type_sitter_lib::TypedNode<'tree>>::from_node_unchecked(
                        node,
                    ),
                )
            }),
            "tuple_type" => {
                Ok(unsafe {
                    Self :: TupleType (< TupleType < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "type_identifier" => Ok(unsafe {
                Self::TypeIdentifier(<TypeIdentifier<'tree> as type_sitter_lib::TypedNode<
                    'tree,
                >>::from_node_unchecked(node))
            }),
            "type_query" => {
                Ok(unsafe {
                    Self :: TypeQuery (< TypeQuery < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "union_type" => {
                Ok(unsafe {
                    Self :: UnionType (< UnionType < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            _ => Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            }),
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for PrimaryType<'tree> {
    const KIND: &'static str = "_primary_type";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        match self {
            Self::ArrayType(x) => x.node(),
            Self::ConditionalType(x) => x.node(),
            Self::ExistentialType(x) => x.node(),
            Self::FlowMaybeType(x) => x.node(),
            Self::GenericType(x) => x.node(),
            Self::IndexTypeQuery(x) => x.node(),
            Self::IntersectionType(x) => x.node(),
            Self::LiteralType(x) => x.node(),
            Self::LookupType(x) => x.node(),
            Self::NestedTypeIdentifier(x) => x.node(),
            Self::ObjectType(x) => x.node(),
            Self::ParenthesizedType(x) => x.node(),
            Self::PredefinedType(x) => x.node(),
            Self::TemplateLiteralType(x) => x.node(),
            Self::ThisType(x) => x.node(),
            Self::TupleType(x) => x.node(),
            Self::TypeIdentifier(x) => x.node(),
            Self::TypeQuery(x) => x.node(),
            Self::UnionType(x) => x.node(),
        }
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        match self {
            Self::ArrayType(x) => x.node_mut(),
            Self::ConditionalType(x) => x.node_mut(),
            Self::ExistentialType(x) => x.node_mut(),
            Self::FlowMaybeType(x) => x.node_mut(),
            Self::GenericType(x) => x.node_mut(),
            Self::IndexTypeQuery(x) => x.node_mut(),
            Self::IntersectionType(x) => x.node_mut(),
            Self::LiteralType(x) => x.node_mut(),
            Self::LookupType(x) => x.node_mut(),
            Self::NestedTypeIdentifier(x) => x.node_mut(),
            Self::ObjectType(x) => x.node_mut(),
            Self::ParenthesizedType(x) => x.node_mut(),
            Self::PredefinedType(x) => x.node_mut(),
            Self::TemplateLiteralType(x) => x.node_mut(),
            Self::ThisType(x) => x.node_mut(),
            Self::TupleType(x) => x.node_mut(),
            Self::TypeIdentifier(x) => x.node_mut(),
            Self::TypeQuery(x) => x.node_mut(),
            Self::UnionType(x) => x.node_mut(),
        }
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        match self {
            Self::ArrayType(x) => x.into_node(),
            Self::ConditionalType(x) => x.into_node(),
            Self::ExistentialType(x) => x.into_node(),
            Self::FlowMaybeType(x) => x.into_node(),
            Self::GenericType(x) => x.into_node(),
            Self::IndexTypeQuery(x) => x.into_node(),
            Self::IntersectionType(x) => x.into_node(),
            Self::LiteralType(x) => x.into_node(),
            Self::LookupType(x) => x.into_node(),
            Self::NestedTypeIdentifier(x) => x.into_node(),
            Self::ObjectType(x) => x.into_node(),
            Self::ParenthesizedType(x) => x.into_node(),
            Self::PredefinedType(x) => x.into_node(),
            Self::TemplateLiteralType(x) => x.into_node(),
            Self::ThisType(x) => x.into_node(),
            Self::TupleType(x) => x.into_node(),
            Self::TypeIdentifier(x) => x.into_node(),
            Self::TypeQuery(x) => x.into_node(),
            Self::UnionType(x) => x.into_node(),
        }
    }
}
#[doc = "Typed node `declaration`\n\nThis node type is a supertype of:\n- `abstract_class_declaration` ([AbstractClassDeclaration])\n- `ambient_declaration` ([AmbientDeclaration])\n- `class_declaration` ([ClassDeclaration])\n- `enum_declaration` ([EnumDeclaration])\n- `function_declaration` ([FunctionDeclaration])\n- `function_signature` ([FunctionSignature])\n- `generator_function_declaration` ([GeneratorFunctionDeclaration])\n- `import_alias` ([ImportAlias])\n- `interface_declaration` ([InterfaceDeclaration])\n- `internal_module` ([InternalModule])\n- `lexical_declaration` ([LexicalDeclaration])\n- `module` ([Module])\n- `nominal_type_declaration` ([NominalTypeDeclaration])\n- `type_alias_declaration` ([TypeAliasDeclaration])\n- `variable_declaration` ([VariableDeclaration])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub enum Declaration<'tree> {
    AbstractClassDeclaration(AbstractClassDeclaration<'tree>),
    AmbientDeclaration(AmbientDeclaration<'tree>),
    ClassDeclaration(ClassDeclaration<'tree>),
    EnumDeclaration(EnumDeclaration<'tree>),
    FunctionDeclaration(FunctionDeclaration<'tree>),
    FunctionSignature(FunctionSignature<'tree>),
    GeneratorFunctionDeclaration(GeneratorFunctionDeclaration<'tree>),
    ImportAlias(ImportAlias<'tree>),
    InterfaceDeclaration(InterfaceDeclaration<'tree>),
    InternalModule(InternalModule<'tree>),
    LexicalDeclaration(LexicalDeclaration<'tree>),
    Module(Module<'tree>),
    NominalTypeDeclaration(NominalTypeDeclaration<'tree>),
    TypeAliasDeclaration(TypeAliasDeclaration<'tree>),
    VariableDeclaration(VariableDeclaration<'tree>),
}
#[automatically_derived]
impl<'tree> Declaration<'tree> {
    #[doc = "Returns the node if it is of kind `abstract_class_declaration` ([AbstractClassDeclaration]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn abstract_class_declaration(self) -> Option<AbstractClassDeclaration<'tree>> {
        match self {
            Self::AbstractClassDeclaration(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `ambient_declaration` ([AmbientDeclaration]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn ambient_declaration(self) -> Option<AmbientDeclaration<'tree>> {
        match self {
            Self::AmbientDeclaration(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `class_declaration` ([ClassDeclaration]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn class_declaration(self) -> Option<ClassDeclaration<'tree>> {
        match self {
            Self::ClassDeclaration(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `enum_declaration` ([EnumDeclaration]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn enum_declaration(self) -> Option<EnumDeclaration<'tree>> {
        match self {
            Self::EnumDeclaration(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `function_declaration` ([FunctionDeclaration]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn function_declaration(self) -> Option<FunctionDeclaration<'tree>> {
        match self {
            Self::FunctionDeclaration(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `function_signature` ([FunctionSignature]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn function_signature(self) -> Option<FunctionSignature<'tree>> {
        match self {
            Self::FunctionSignature(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `generator_function_declaration` ([GeneratorFunctionDeclaration]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn generator_function_declaration(self) -> Option<GeneratorFunctionDeclaration<'tree>> {
        match self {
            Self::GeneratorFunctionDeclaration(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `import_alias` ([ImportAlias]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn import_alias(self) -> Option<ImportAlias<'tree>> {
        match self {
            Self::ImportAlias(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `interface_declaration` ([InterfaceDeclaration]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn interface_declaration(self) -> Option<InterfaceDeclaration<'tree>> {
        match self {
            Self::InterfaceDeclaration(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `internal_module` ([InternalModule]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn internal_module(self) -> Option<InternalModule<'tree>> {
        match self {
            Self::InternalModule(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `lexical_declaration` ([LexicalDeclaration]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn lexical_declaration(self) -> Option<LexicalDeclaration<'tree>> {
        match self {
            Self::LexicalDeclaration(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `module` ([Module]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn module(self) -> Option<Module<'tree>> {
        match self {
            Self::Module(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `nominal_type_declaration` ([NominalTypeDeclaration]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn nominal_type_declaration(self) -> Option<NominalTypeDeclaration<'tree>> {
        match self {
            Self::NominalTypeDeclaration(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `type_alias_declaration` ([TypeAliasDeclaration]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn type_alias_declaration(self) -> Option<TypeAliasDeclaration<'tree>> {
        match self {
            Self::TypeAliasDeclaration(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `variable_declaration` ([VariableDeclaration]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn variable_declaration(self) -> Option<VariableDeclaration<'tree>> {
        match self {
            Self::VariableDeclaration(x) => Some(x),
            _ => None,
        }
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Declaration<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        match node.kind() {
            "abstract_class_declaration" => Ok(unsafe {
                Self :: AbstractClassDeclaration (< AbstractClassDeclaration < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
            }),
            "ambient_declaration" => Ok(unsafe {
                Self :: AmbientDeclaration (< AmbientDeclaration < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
            }),
            "class_declaration" => {
                Ok(unsafe {
                    Self :: ClassDeclaration (< ClassDeclaration < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "enum_declaration" => Ok(unsafe {
                Self::EnumDeclaration(<EnumDeclaration<'tree> as type_sitter_lib::TypedNode<
                    'tree,
                >>::from_node_unchecked(node))
            }),
            "function_declaration" => Ok(unsafe {
                Self :: FunctionDeclaration (< FunctionDeclaration < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
            }),
            "function_signature" => {
                Ok(unsafe {
                    Self :: FunctionSignature (< FunctionSignature < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "generator_function_declaration" => Ok(unsafe {
                Self :: GeneratorFunctionDeclaration (< GeneratorFunctionDeclaration < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
            }),
            "import_alias" => {
                Ok(unsafe {
                    Self :: ImportAlias (< ImportAlias < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "interface_declaration" => Ok(unsafe {
                Self :: InterfaceDeclaration (< InterfaceDeclaration < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
            }),
            "internal_module" => Ok(unsafe {
                Self::InternalModule(<InternalModule<'tree> as type_sitter_lib::TypedNode<
                    'tree,
                >>::from_node_unchecked(node))
            }),
            "lexical_declaration" => Ok(unsafe {
                Self :: LexicalDeclaration (< LexicalDeclaration < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
            }),
            "module" => Ok(unsafe {
                Self::Module(
                    <Module<'tree> as type_sitter_lib::TypedNode<'tree>>::from_node_unchecked(node),
                )
            }),
            "nominal_type_declaration" => Ok(unsafe {
                Self :: NominalTypeDeclaration (< NominalTypeDeclaration < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
            }),
            "type_alias_declaration" => Ok(unsafe {
                Self :: TypeAliasDeclaration (< TypeAliasDeclaration < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
            }),
            "variable_declaration" => Ok(unsafe {
                Self :: VariableDeclaration (< VariableDeclaration < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
            }),
            _ => Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            }),
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for Declaration<'tree> {
    const KIND: &'static str = "declaration";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        match self {
            Self::AbstractClassDeclaration(x) => x.node(),
            Self::AmbientDeclaration(x) => x.node(),
            Self::ClassDeclaration(x) => x.node(),
            Self::EnumDeclaration(x) => x.node(),
            Self::FunctionDeclaration(x) => x.node(),
            Self::FunctionSignature(x) => x.node(),
            Self::GeneratorFunctionDeclaration(x) => x.node(),
            Self::ImportAlias(x) => x.node(),
            Self::InterfaceDeclaration(x) => x.node(),
            Self::InternalModule(x) => x.node(),
            Self::LexicalDeclaration(x) => x.node(),
            Self::Module(x) => x.node(),
            Self::NominalTypeDeclaration(x) => x.node(),
            Self::TypeAliasDeclaration(x) => x.node(),
            Self::VariableDeclaration(x) => x.node(),
        }
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        match self {
            Self::AbstractClassDeclaration(x) => x.node_mut(),
            Self::AmbientDeclaration(x) => x.node_mut(),
            Self::ClassDeclaration(x) => x.node_mut(),
            Self::EnumDeclaration(x) => x.node_mut(),
            Self::FunctionDeclaration(x) => x.node_mut(),
            Self::FunctionSignature(x) => x.node_mut(),
            Self::GeneratorFunctionDeclaration(x) => x.node_mut(),
            Self::ImportAlias(x) => x.node_mut(),
            Self::InterfaceDeclaration(x) => x.node_mut(),
            Self::InternalModule(x) => x.node_mut(),
            Self::LexicalDeclaration(x) => x.node_mut(),
            Self::Module(x) => x.node_mut(),
            Self::NominalTypeDeclaration(x) => x.node_mut(),
            Self::TypeAliasDeclaration(x) => x.node_mut(),
            Self::VariableDeclaration(x) => x.node_mut(),
        }
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        match self {
            Self::AbstractClassDeclaration(x) => x.into_node(),
            Self::AmbientDeclaration(x) => x.into_node(),
            Self::ClassDeclaration(x) => x.into_node(),
            Self::EnumDeclaration(x) => x.into_node(),
            Self::FunctionDeclaration(x) => x.into_node(),
            Self::FunctionSignature(x) => x.into_node(),
            Self::GeneratorFunctionDeclaration(x) => x.into_node(),
            Self::ImportAlias(x) => x.into_node(),
            Self::InterfaceDeclaration(x) => x.into_node(),
            Self::InternalModule(x) => x.into_node(),
            Self::LexicalDeclaration(x) => x.into_node(),
            Self::Module(x) => x.into_node(),
            Self::NominalTypeDeclaration(x) => x.into_node(),
            Self::TypeAliasDeclaration(x) => x.into_node(),
            Self::VariableDeclaration(x) => x.into_node(),
        }
    }
}
#[doc = "Typed node `expression`\n\nThis node type is a supertype of:\n- `as_expression` ([AsExpression])\n- `assignment_expression` ([AssignmentExpression])\n- `augmented_assignment_expression` ([AugmentedAssignmentExpression])\n- `await_expression` ([AwaitExpression])\n- `binary_expression` ([BinaryExpression])\n- `glimmer_template` ([GlimmerTemplate])\n- `internal_module` ([InternalModule])\n- `new_expression` ([NewExpression])\n- `primary_expression` ([PrimaryExpression])\n- `satisfies_expression` ([SatisfiesExpression])\n- `ternary_expression` ([TernaryExpression])\n- `type_assertion` ([TypeAssertion])\n- `unary_expression` ([UnaryExpression])\n- `update_expression` ([UpdateExpression])\n- `yield_expression` ([YieldExpression])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub enum Expression<'tree> {
    AsExpression(AsExpression<'tree>),
    AssignmentExpression(AssignmentExpression<'tree>),
    AugmentedAssignmentExpression(AugmentedAssignmentExpression<'tree>),
    AwaitExpression(AwaitExpression<'tree>),
    BinaryExpression(BinaryExpression<'tree>),
    GlimmerTemplate(GlimmerTemplate<'tree>),
    InternalModule(InternalModule<'tree>),
    NewExpression(NewExpression<'tree>),
    PrimaryExpression(PrimaryExpression<'tree>),
    SatisfiesExpression(SatisfiesExpression<'tree>),
    TernaryExpression(TernaryExpression<'tree>),
    TypeAssertion(TypeAssertion<'tree>),
    UnaryExpression(UnaryExpression<'tree>),
    UpdateExpression(UpdateExpression<'tree>),
    YieldExpression(YieldExpression<'tree>),
}
#[automatically_derived]
impl<'tree> Expression<'tree> {
    #[doc = "Returns the node if it is of kind `as_expression` ([AsExpression]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn as_expression(self) -> Option<AsExpression<'tree>> {
        match self {
            Self::AsExpression(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `assignment_expression` ([AssignmentExpression]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn assignment_expression(self) -> Option<AssignmentExpression<'tree>> {
        match self {
            Self::AssignmentExpression(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `augmented_assignment_expression` ([AugmentedAssignmentExpression]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn augmented_assignment_expression(self) -> Option<AugmentedAssignmentExpression<'tree>> {
        match self {
            Self::AugmentedAssignmentExpression(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `await_expression` ([AwaitExpression]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn await_expression(self) -> Option<AwaitExpression<'tree>> {
        match self {
            Self::AwaitExpression(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `binary_expression` ([BinaryExpression]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn binary_expression(self) -> Option<BinaryExpression<'tree>> {
        match self {
            Self::BinaryExpression(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `glimmer_template` ([GlimmerTemplate]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn glimmer_template(self) -> Option<GlimmerTemplate<'tree>> {
        match self {
            Self::GlimmerTemplate(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `internal_module` ([InternalModule]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn internal_module(self) -> Option<InternalModule<'tree>> {
        match self {
            Self::InternalModule(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `new_expression` ([NewExpression]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn new_expression(self) -> Option<NewExpression<'tree>> {
        match self {
            Self::NewExpression(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `primary_expression` ([PrimaryExpression]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn primary_expression(self) -> Option<PrimaryExpression<'tree>> {
        match self {
            Self::PrimaryExpression(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `satisfies_expression` ([SatisfiesExpression]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn satisfies_expression(self) -> Option<SatisfiesExpression<'tree>> {
        match self {
            Self::SatisfiesExpression(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `ternary_expression` ([TernaryExpression]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn ternary_expression(self) -> Option<TernaryExpression<'tree>> {
        match self {
            Self::TernaryExpression(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `type_assertion` ([TypeAssertion]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn type_assertion(self) -> Option<TypeAssertion<'tree>> {
        match self {
            Self::TypeAssertion(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `unary_expression` ([UnaryExpression]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn unary_expression(self) -> Option<UnaryExpression<'tree>> {
        match self {
            Self::UnaryExpression(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `update_expression` ([UpdateExpression]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn update_expression(self) -> Option<UpdateExpression<'tree>> {
        match self {
            Self::UpdateExpression(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `yield_expression` ([YieldExpression]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn yield_expression(self) -> Option<YieldExpression<'tree>> {
        match self {
            Self::YieldExpression(x) => Some(x),
            _ => None,
        }
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Expression<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        match node.kind() {
            "as_expression" => {
                Ok(unsafe {
                    Self :: AsExpression (< AsExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "assignment_expression" => Ok(unsafe {
                Self :: AssignmentExpression (< AssignmentExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
            }),
            "augmented_assignment_expression" => Ok(unsafe {
                Self :: AugmentedAssignmentExpression (< AugmentedAssignmentExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
            }),
            "await_expression" => Ok(unsafe {
                Self::AwaitExpression(<AwaitExpression<'tree> as type_sitter_lib::TypedNode<
                    'tree,
                >>::from_node_unchecked(node))
            }),
            "binary_expression" => {
                Ok(unsafe {
                    Self :: BinaryExpression (< BinaryExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "glimmer_template" => Ok(unsafe {
                Self::GlimmerTemplate(<GlimmerTemplate<'tree> as type_sitter_lib::TypedNode<
                    'tree,
                >>::from_node_unchecked(node))
            }),
            "internal_module" => Ok(unsafe {
                Self::InternalModule(<InternalModule<'tree> as type_sitter_lib::TypedNode<
                    'tree,
                >>::from_node_unchecked(node))
            }),
            "new_expression" => Ok(unsafe {
                Self::NewExpression(<NewExpression<'tree> as type_sitter_lib::TypedNode<
                    'tree,
                >>::from_node_unchecked(node))
            }),
            "primary_expression" => {
                Ok(unsafe {
                    Self :: PrimaryExpression (< PrimaryExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "satisfies_expression" => Ok(unsafe {
                Self :: SatisfiesExpression (< SatisfiesExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
            }),
            "ternary_expression" => {
                Ok(unsafe {
                    Self :: TernaryExpression (< TernaryExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "type_assertion" => Ok(unsafe {
                Self::TypeAssertion(<TypeAssertion<'tree> as type_sitter_lib::TypedNode<
                    'tree,
                >>::from_node_unchecked(node))
            }),
            "unary_expression" => Ok(unsafe {
                Self::UnaryExpression(<UnaryExpression<'tree> as type_sitter_lib::TypedNode<
                    'tree,
                >>::from_node_unchecked(node))
            }),
            "update_expression" => {
                Ok(unsafe {
                    Self :: UpdateExpression (< UpdateExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "yield_expression" => Ok(unsafe {
                Self::YieldExpression(<YieldExpression<'tree> as type_sitter_lib::TypedNode<
                    'tree,
                >>::from_node_unchecked(node))
            }),
            _ => Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            }),
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for Expression<'tree> {
    const KIND: &'static str = "expression";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        match self {
            Self::AsExpression(x) => x.node(),
            Self::AssignmentExpression(x) => x.node(),
            Self::AugmentedAssignmentExpression(x) => x.node(),
            Self::AwaitExpression(x) => x.node(),
            Self::BinaryExpression(x) => x.node(),
            Self::GlimmerTemplate(x) => x.node(),
            Self::InternalModule(x) => x.node(),
            Self::NewExpression(x) => x.node(),
            Self::PrimaryExpression(x) => x.node(),
            Self::SatisfiesExpression(x) => x.node(),
            Self::TernaryExpression(x) => x.node(),
            Self::TypeAssertion(x) => x.node(),
            Self::UnaryExpression(x) => x.node(),
            Self::UpdateExpression(x) => x.node(),
            Self::YieldExpression(x) => x.node(),
        }
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        match self {
            Self::AsExpression(x) => x.node_mut(),
            Self::AssignmentExpression(x) => x.node_mut(),
            Self::AugmentedAssignmentExpression(x) => x.node_mut(),
            Self::AwaitExpression(x) => x.node_mut(),
            Self::BinaryExpression(x) => x.node_mut(),
            Self::GlimmerTemplate(x) => x.node_mut(),
            Self::InternalModule(x) => x.node_mut(),
            Self::NewExpression(x) => x.node_mut(),
            Self::PrimaryExpression(x) => x.node_mut(),
            Self::SatisfiesExpression(x) => x.node_mut(),
            Self::TernaryExpression(x) => x.node_mut(),
            Self::TypeAssertion(x) => x.node_mut(),
            Self::UnaryExpression(x) => x.node_mut(),
            Self::UpdateExpression(x) => x.node_mut(),
            Self::YieldExpression(x) => x.node_mut(),
        }
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        match self {
            Self::AsExpression(x) => x.into_node(),
            Self::AssignmentExpression(x) => x.into_node(),
            Self::AugmentedAssignmentExpression(x) => x.into_node(),
            Self::AwaitExpression(x) => x.into_node(),
            Self::BinaryExpression(x) => x.into_node(),
            Self::GlimmerTemplate(x) => x.into_node(),
            Self::InternalModule(x) => x.into_node(),
            Self::NewExpression(x) => x.into_node(),
            Self::PrimaryExpression(x) => x.into_node(),
            Self::SatisfiesExpression(x) => x.into_node(),
            Self::TernaryExpression(x) => x.into_node(),
            Self::TypeAssertion(x) => x.into_node(),
            Self::UnaryExpression(x) => x.into_node(),
            Self::UpdateExpression(x) => x.into_node(),
            Self::YieldExpression(x) => x.into_node(),
        }
    }
}
#[doc = "Typed node `pattern`\n\nThis node type is a supertype of:\n- `array_pattern` ([ArrayPattern])\n- `identifier` ([Identifier])\n- `member_expression` ([MemberExpression])\n- `non_null_expression` ([NonNullExpression])\n- `object_pattern` ([ObjectPattern])\n- `rest_pattern` ([RestPattern])\n- `subscript_expression` ([SubscriptExpression])\n- `undefined` ([Undefined])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub enum Pattern<'tree> {
    ArrayPattern(ArrayPattern<'tree>),
    Identifier(Identifier<'tree>),
    MemberExpression(MemberExpression<'tree>),
    NonNullExpression(NonNullExpression<'tree>),
    ObjectPattern(ObjectPattern<'tree>),
    RestPattern(RestPattern<'tree>),
    SubscriptExpression(SubscriptExpression<'tree>),
    Undefined(Undefined<'tree>),
}
#[automatically_derived]
impl<'tree> Pattern<'tree> {
    #[doc = "Returns the node if it is of kind `array_pattern` ([ArrayPattern]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn array_pattern(self) -> Option<ArrayPattern<'tree>> {
        match self {
            Self::ArrayPattern(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `identifier` ([Identifier]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn identifier(self) -> Option<Identifier<'tree>> {
        match self {
            Self::Identifier(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `member_expression` ([MemberExpression]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn member_expression(self) -> Option<MemberExpression<'tree>> {
        match self {
            Self::MemberExpression(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `non_null_expression` ([NonNullExpression]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn non_null_expression(self) -> Option<NonNullExpression<'tree>> {
        match self {
            Self::NonNullExpression(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `object_pattern` ([ObjectPattern]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn object_pattern(self) -> Option<ObjectPattern<'tree>> {
        match self {
            Self::ObjectPattern(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `rest_pattern` ([RestPattern]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn rest_pattern(self) -> Option<RestPattern<'tree>> {
        match self {
            Self::RestPattern(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `subscript_expression` ([SubscriptExpression]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn subscript_expression(self) -> Option<SubscriptExpression<'tree>> {
        match self {
            Self::SubscriptExpression(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `undefined` ([Undefined]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn undefined(self) -> Option<Undefined<'tree>> {
        match self {
            Self::Undefined(x) => Some(x),
            _ => None,
        }
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Pattern<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        match node.kind() {
            "array_pattern" => {
                Ok(unsafe {
                    Self :: ArrayPattern (< ArrayPattern < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "identifier" => {
                Ok(unsafe {
                    Self :: Identifier (< Identifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "member_expression" => {
                Ok(unsafe {
                    Self :: MemberExpression (< MemberExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "non_null_expression" => {
                Ok(unsafe {
                    Self :: NonNullExpression (< NonNullExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "object_pattern" => Ok(unsafe {
                Self::ObjectPattern(<ObjectPattern<'tree> as type_sitter_lib::TypedNode<
                    'tree,
                >>::from_node_unchecked(node))
            }),
            "rest_pattern" => {
                Ok(unsafe {
                    Self :: RestPattern (< RestPattern < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "subscript_expression" => Ok(unsafe {
                Self :: SubscriptExpression (< SubscriptExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
            }),
            "undefined" => {
                Ok(unsafe {
                    Self :: Undefined (< Undefined < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            _ => Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            }),
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for Pattern<'tree> {
    const KIND: &'static str = "pattern";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        match self {
            Self::ArrayPattern(x) => x.node(),
            Self::Identifier(x) => x.node(),
            Self::MemberExpression(x) => x.node(),
            Self::NonNullExpression(x) => x.node(),
            Self::ObjectPattern(x) => x.node(),
            Self::RestPattern(x) => x.node(),
            Self::SubscriptExpression(x) => x.node(),
            Self::Undefined(x) => x.node(),
        }
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        match self {
            Self::ArrayPattern(x) => x.node_mut(),
            Self::Identifier(x) => x.node_mut(),
            Self::MemberExpression(x) => x.node_mut(),
            Self::NonNullExpression(x) => x.node_mut(),
            Self::ObjectPattern(x) => x.node_mut(),
            Self::RestPattern(x) => x.node_mut(),
            Self::SubscriptExpression(x) => x.node_mut(),
            Self::Undefined(x) => x.node_mut(),
        }
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        match self {
            Self::ArrayPattern(x) => x.into_node(),
            Self::Identifier(x) => x.into_node(),
            Self::MemberExpression(x) => x.into_node(),
            Self::NonNullExpression(x) => x.into_node(),
            Self::ObjectPattern(x) => x.into_node(),
            Self::RestPattern(x) => x.into_node(),
            Self::SubscriptExpression(x) => x.into_node(),
            Self::Undefined(x) => x.into_node(),
        }
    }
}
#[doc = "Typed node `primary_expression`\n\nThis node type is a supertype of:\n- `array` ([Array])\n- `arrow_function` ([ArrowFunction])\n- `call_expression` ([CallExpression])\n- `class` ([Class])\n- `false` ([False])\n- `function` ([Function])\n- `generator_function` ([GeneratorFunction])\n- `identifier` ([Identifier])\n- `import` ([Import])\n- `member_expression` ([MemberExpression])\n- `meta_property` ([MetaProperty])\n- `nominal_wrap_expression` ([NominalWrapExpression])\n- `nominal_wrap_unchecked_expression` ([NominalWrapUncheckedExpression])\n- `non_null_expression` ([NonNullExpression])\n- `null` ([Null])\n- `number` ([Number])\n- `object` ([Object])\n- `parenthesized_expression` ([ParenthesizedExpression])\n- `regex` ([Regex])\n- `string` ([String])\n- `subscript_expression` ([SubscriptExpression])\n- `super` ([Super])\n- `template_string` ([TemplateString])\n- `this` ([This])\n- `true` ([True])\n- `undefined` ([Undefined])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub enum PrimaryExpression<'tree> {
    Array(Array<'tree>),
    ArrowFunction(ArrowFunction<'tree>),
    CallExpression(CallExpression<'tree>),
    Class(Class<'tree>),
    False(False<'tree>),
    Function(Function<'tree>),
    GeneratorFunction(GeneratorFunction<'tree>),
    Identifier(Identifier<'tree>),
    Import(Import<'tree>),
    MemberExpression(MemberExpression<'tree>),
    MetaProperty(MetaProperty<'tree>),
    NominalWrapExpression(NominalWrapExpression<'tree>),
    NominalWrapUncheckedExpression(NominalWrapUncheckedExpression<'tree>),
    NonNullExpression(NonNullExpression<'tree>),
    Null(Null<'tree>),
    Number(Number<'tree>),
    Object(Object<'tree>),
    ParenthesizedExpression(ParenthesizedExpression<'tree>),
    Regex(Regex<'tree>),
    String(String<'tree>),
    SubscriptExpression(SubscriptExpression<'tree>),
    Super(Super<'tree>),
    TemplateString(TemplateString<'tree>),
    This(This<'tree>),
    True(True<'tree>),
    Undefined(Undefined<'tree>),
}
#[automatically_derived]
impl<'tree> PrimaryExpression<'tree> {
    #[doc = "Returns the node if it is of kind `array` ([Array]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn array(self) -> Option<Array<'tree>> {
        match self {
            Self::Array(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `arrow_function` ([ArrowFunction]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn arrow_function(self) -> Option<ArrowFunction<'tree>> {
        match self {
            Self::ArrowFunction(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `call_expression` ([CallExpression]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn call_expression(self) -> Option<CallExpression<'tree>> {
        match self {
            Self::CallExpression(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `class` ([Class]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn class(self) -> Option<Class<'tree>> {
        match self {
            Self::Class(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `false` ([False]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn r#false(self) -> Option<False<'tree>> {
        match self {
            Self::False(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `function` ([Function]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn function(self) -> Option<Function<'tree>> {
        match self {
            Self::Function(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `generator_function` ([GeneratorFunction]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn generator_function(self) -> Option<GeneratorFunction<'tree>> {
        match self {
            Self::GeneratorFunction(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `identifier` ([Identifier]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn identifier(self) -> Option<Identifier<'tree>> {
        match self {
            Self::Identifier(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `import` ([Import]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn import(self) -> Option<Import<'tree>> {
        match self {
            Self::Import(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `member_expression` ([MemberExpression]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn member_expression(self) -> Option<MemberExpression<'tree>> {
        match self {
            Self::MemberExpression(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `meta_property` ([MetaProperty]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn meta_property(self) -> Option<MetaProperty<'tree>> {
        match self {
            Self::MetaProperty(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `nominal_wrap_expression` ([NominalWrapExpression]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn nominal_wrap_expression(self) -> Option<NominalWrapExpression<'tree>> {
        match self {
            Self::NominalWrapExpression(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `nominal_wrap_unchecked_expression` ([NominalWrapUncheckedExpression]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn nominal_wrap_unchecked_expression(
        self,
    ) -> Option<NominalWrapUncheckedExpression<'tree>> {
        match self {
            Self::NominalWrapUncheckedExpression(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `non_null_expression` ([NonNullExpression]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn non_null_expression(self) -> Option<NonNullExpression<'tree>> {
        match self {
            Self::NonNullExpression(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `null` ([Null]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn null(self) -> Option<Null<'tree>> {
        match self {
            Self::Null(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `number` ([Number]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn number(self) -> Option<Number<'tree>> {
        match self {
            Self::Number(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `object` ([Object]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn object(self) -> Option<Object<'tree>> {
        match self {
            Self::Object(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `parenthesized_expression` ([ParenthesizedExpression]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn parenthesized_expression(self) -> Option<ParenthesizedExpression<'tree>> {
        match self {
            Self::ParenthesizedExpression(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `regex` ([Regex]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn regex(self) -> Option<Regex<'tree>> {
        match self {
            Self::Regex(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `string` ([String]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn string(self) -> Option<String<'tree>> {
        match self {
            Self::String(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `subscript_expression` ([SubscriptExpression]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn subscript_expression(self) -> Option<SubscriptExpression<'tree>> {
        match self {
            Self::SubscriptExpression(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `super` ([Super]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn super_(self) -> Option<Super<'tree>> {
        match self {
            Self::Super(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `template_string` ([TemplateString]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn template_string(self) -> Option<TemplateString<'tree>> {
        match self {
            Self::TemplateString(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `this` ([This]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn this(self) -> Option<This<'tree>> {
        match self {
            Self::This(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `true` ([True]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn r#true(self) -> Option<True<'tree>> {
        match self {
            Self::True(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `undefined` ([Undefined]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn undefined(self) -> Option<Undefined<'tree>> {
        match self {
            Self::Undefined(x) => Some(x),
            _ => None,
        }
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for PrimaryExpression<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        match node.kind() {
            "array" => Ok(unsafe {
                Self::Array(
                    <Array<'tree> as type_sitter_lib::TypedNode<'tree>>::from_node_unchecked(node),
                )
            }),
            "arrow_function" => Ok(unsafe {
                Self::ArrowFunction(<ArrowFunction<'tree> as type_sitter_lib::TypedNode<
                    'tree,
                >>::from_node_unchecked(node))
            }),
            "call_expression" => Ok(unsafe {
                Self::CallExpression(<CallExpression<'tree> as type_sitter_lib::TypedNode<
                    'tree,
                >>::from_node_unchecked(node))
            }),
            "class" => Ok(unsafe {
                Self::Class(
                    <Class<'tree> as type_sitter_lib::TypedNode<'tree>>::from_node_unchecked(node),
                )
            }),
            "false" => Ok(unsafe {
                Self::False(
                    <False<'tree> as type_sitter_lib::TypedNode<'tree>>::from_node_unchecked(node),
                )
            }),
            "function" => Ok(unsafe {
                Self::Function(
                    <Function<'tree> as type_sitter_lib::TypedNode<'tree>>::from_node_unchecked(
                        node,
                    ),
                )
            }),
            "generator_function" => {
                Ok(unsafe {
                    Self :: GeneratorFunction (< GeneratorFunction < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "identifier" => {
                Ok(unsafe {
                    Self :: Identifier (< Identifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "import" => Ok(unsafe {
                Self::Import(
                    <Import<'tree> as type_sitter_lib::TypedNode<'tree>>::from_node_unchecked(node),
                )
            }),
            "member_expression" => {
                Ok(unsafe {
                    Self :: MemberExpression (< MemberExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "meta_property" => {
                Ok(unsafe {
                    Self :: MetaProperty (< MetaProperty < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "nominal_wrap_expression" => Ok(unsafe {
                Self :: NominalWrapExpression (< NominalWrapExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
            }),
            "nominal_wrap_unchecked_expression" => Ok(unsafe {
                Self :: NominalWrapUncheckedExpression (< NominalWrapUncheckedExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
            }),
            "non_null_expression" => {
                Ok(unsafe {
                    Self :: NonNullExpression (< NonNullExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "null" => Ok(unsafe {
                Self::Null(
                    <Null<'tree> as type_sitter_lib::TypedNode<'tree>>::from_node_unchecked(node),
                )
            }),
            "number" => Ok(unsafe {
                Self::Number(
                    <Number<'tree> as type_sitter_lib::TypedNode<'tree>>::from_node_unchecked(node),
                )
            }),
            "object" => Ok(unsafe {
                Self::Object(
                    <Object<'tree> as type_sitter_lib::TypedNode<'tree>>::from_node_unchecked(node),
                )
            }),
            "parenthesized_expression" => Ok(unsafe {
                Self :: ParenthesizedExpression (< ParenthesizedExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
            }),
            "regex" => Ok(unsafe {
                Self::Regex(
                    <Regex<'tree> as type_sitter_lib::TypedNode<'tree>>::from_node_unchecked(node),
                )
            }),
            "string" => Ok(unsafe {
                Self::String(
                    <String<'tree> as type_sitter_lib::TypedNode<'tree>>::from_node_unchecked(node),
                )
            }),
            "subscript_expression" => Ok(unsafe {
                Self :: SubscriptExpression (< SubscriptExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
            }),
            "super" => Ok(unsafe {
                Self::Super(
                    <Super<'tree> as type_sitter_lib::TypedNode<'tree>>::from_node_unchecked(node),
                )
            }),
            "template_string" => Ok(unsafe {
                Self::TemplateString(<TemplateString<'tree> as type_sitter_lib::TypedNode<
                    'tree,
                >>::from_node_unchecked(node))
            }),
            "this" => Ok(unsafe {
                Self::This(
                    <This<'tree> as type_sitter_lib::TypedNode<'tree>>::from_node_unchecked(node),
                )
            }),
            "true" => Ok(unsafe {
                Self::True(
                    <True<'tree> as type_sitter_lib::TypedNode<'tree>>::from_node_unchecked(node),
                )
            }),
            "undefined" => {
                Ok(unsafe {
                    Self :: Undefined (< Undefined < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            _ => Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            }),
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for PrimaryExpression<'tree> {
    const KIND: &'static str = "primary_expression";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        match self {
            Self::Array(x) => x.node(),
            Self::ArrowFunction(x) => x.node(),
            Self::CallExpression(x) => x.node(),
            Self::Class(x) => x.node(),
            Self::False(x) => x.node(),
            Self::Function(x) => x.node(),
            Self::GeneratorFunction(x) => x.node(),
            Self::Identifier(x) => x.node(),
            Self::Import(x) => x.node(),
            Self::MemberExpression(x) => x.node(),
            Self::MetaProperty(x) => x.node(),
            Self::NominalWrapExpression(x) => x.node(),
            Self::NominalWrapUncheckedExpression(x) => x.node(),
            Self::NonNullExpression(x) => x.node(),
            Self::Null(x) => x.node(),
            Self::Number(x) => x.node(),
            Self::Object(x) => x.node(),
            Self::ParenthesizedExpression(x) => x.node(),
            Self::Regex(x) => x.node(),
            Self::String(x) => x.node(),
            Self::SubscriptExpression(x) => x.node(),
            Self::Super(x) => x.node(),
            Self::TemplateString(x) => x.node(),
            Self::This(x) => x.node(),
            Self::True(x) => x.node(),
            Self::Undefined(x) => x.node(),
        }
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        match self {
            Self::Array(x) => x.node_mut(),
            Self::ArrowFunction(x) => x.node_mut(),
            Self::CallExpression(x) => x.node_mut(),
            Self::Class(x) => x.node_mut(),
            Self::False(x) => x.node_mut(),
            Self::Function(x) => x.node_mut(),
            Self::GeneratorFunction(x) => x.node_mut(),
            Self::Identifier(x) => x.node_mut(),
            Self::Import(x) => x.node_mut(),
            Self::MemberExpression(x) => x.node_mut(),
            Self::MetaProperty(x) => x.node_mut(),
            Self::NominalWrapExpression(x) => x.node_mut(),
            Self::NominalWrapUncheckedExpression(x) => x.node_mut(),
            Self::NonNullExpression(x) => x.node_mut(),
            Self::Null(x) => x.node_mut(),
            Self::Number(x) => x.node_mut(),
            Self::Object(x) => x.node_mut(),
            Self::ParenthesizedExpression(x) => x.node_mut(),
            Self::Regex(x) => x.node_mut(),
            Self::String(x) => x.node_mut(),
            Self::SubscriptExpression(x) => x.node_mut(),
            Self::Super(x) => x.node_mut(),
            Self::TemplateString(x) => x.node_mut(),
            Self::This(x) => x.node_mut(),
            Self::True(x) => x.node_mut(),
            Self::Undefined(x) => x.node_mut(),
        }
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        match self {
            Self::Array(x) => x.into_node(),
            Self::ArrowFunction(x) => x.into_node(),
            Self::CallExpression(x) => x.into_node(),
            Self::Class(x) => x.into_node(),
            Self::False(x) => x.into_node(),
            Self::Function(x) => x.into_node(),
            Self::GeneratorFunction(x) => x.into_node(),
            Self::Identifier(x) => x.into_node(),
            Self::Import(x) => x.into_node(),
            Self::MemberExpression(x) => x.into_node(),
            Self::MetaProperty(x) => x.into_node(),
            Self::NominalWrapExpression(x) => x.into_node(),
            Self::NominalWrapUncheckedExpression(x) => x.into_node(),
            Self::NonNullExpression(x) => x.into_node(),
            Self::Null(x) => x.into_node(),
            Self::Number(x) => x.into_node(),
            Self::Object(x) => x.into_node(),
            Self::ParenthesizedExpression(x) => x.into_node(),
            Self::Regex(x) => x.into_node(),
            Self::String(x) => x.into_node(),
            Self::SubscriptExpression(x) => x.into_node(),
            Self::Super(x) => x.into_node(),
            Self::TemplateString(x) => x.into_node(),
            Self::This(x) => x.into_node(),
            Self::True(x) => x.into_node(),
            Self::Undefined(x) => x.into_node(),
        }
    }
}
#[doc = "Typed node `statement`\n\nThis node type is a supertype of:\n- `break_statement` ([BreakStatement])\n- `continue_statement` ([ContinueStatement])\n- `debugger_statement` ([DebuggerStatement])\n- `declaration` ([Declaration])\n- `do_statement` ([DoStatement])\n- `empty_statement` ([EmptyStatement])\n- `export_statement` ([ExportStatement])\n- `expression_statement` ([ExpressionStatement])\n- `for_in_statement` ([ForInStatement])\n- `for_statement` ([ForStatement])\n- `if_statement` ([IfStatement])\n- `import_statement` ([ImportStatement])\n- `labeled_statement` ([LabeledStatement])\n- `return_statement` ([ReturnStatement])\n- `statement_block` ([StatementBlock])\n- `switch_statement` ([SwitchStatement])\n- `throw_statement` ([ThrowStatement])\n- `try_statement` ([TryStatement])\n- `while_statement` ([WhileStatement])\n- `with_statement` ([WithStatement])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub enum Statement<'tree> {
    BreakStatement(BreakStatement<'tree>),
    ContinueStatement(ContinueStatement<'tree>),
    DebuggerStatement(DebuggerStatement<'tree>),
    Declaration(Declaration<'tree>),
    DoStatement(DoStatement<'tree>),
    EmptyStatement(EmptyStatement<'tree>),
    ExportStatement(ExportStatement<'tree>),
    ExpressionStatement(ExpressionStatement<'tree>),
    ForInStatement(ForInStatement<'tree>),
    ForStatement(ForStatement<'tree>),
    IfStatement(IfStatement<'tree>),
    ImportStatement(ImportStatement<'tree>),
    LabeledStatement(LabeledStatement<'tree>),
    ReturnStatement(ReturnStatement<'tree>),
    StatementBlock(StatementBlock<'tree>),
    SwitchStatement(SwitchStatement<'tree>),
    ThrowStatement(ThrowStatement<'tree>),
    TryStatement(TryStatement<'tree>),
    WhileStatement(WhileStatement<'tree>),
    WithStatement(WithStatement<'tree>),
}
#[automatically_derived]
impl<'tree> Statement<'tree> {
    #[doc = "Returns the node if it is of kind `break_statement` ([BreakStatement]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn break_statement(self) -> Option<BreakStatement<'tree>> {
        match self {
            Self::BreakStatement(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `continue_statement` ([ContinueStatement]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn continue_statement(self) -> Option<ContinueStatement<'tree>> {
        match self {
            Self::ContinueStatement(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `debugger_statement` ([DebuggerStatement]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn debugger_statement(self) -> Option<DebuggerStatement<'tree>> {
        match self {
            Self::DebuggerStatement(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `declaration` ([Declaration]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn declaration(self) -> Option<Declaration<'tree>> {
        match self {
            Self::Declaration(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `do_statement` ([DoStatement]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn do_statement(self) -> Option<DoStatement<'tree>> {
        match self {
            Self::DoStatement(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `empty_statement` ([EmptyStatement]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn empty_statement(self) -> Option<EmptyStatement<'tree>> {
        match self {
            Self::EmptyStatement(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `export_statement` ([ExportStatement]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn export_statement(self) -> Option<ExportStatement<'tree>> {
        match self {
            Self::ExportStatement(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `expression_statement` ([ExpressionStatement]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn expression_statement(self) -> Option<ExpressionStatement<'tree>> {
        match self {
            Self::ExpressionStatement(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `for_in_statement` ([ForInStatement]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn for_in_statement(self) -> Option<ForInStatement<'tree>> {
        match self {
            Self::ForInStatement(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `for_statement` ([ForStatement]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn for_statement(self) -> Option<ForStatement<'tree>> {
        match self {
            Self::ForStatement(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `if_statement` ([IfStatement]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn if_statement(self) -> Option<IfStatement<'tree>> {
        match self {
            Self::IfStatement(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `import_statement` ([ImportStatement]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn import_statement(self) -> Option<ImportStatement<'tree>> {
        match self {
            Self::ImportStatement(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `labeled_statement` ([LabeledStatement]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn labeled_statement(self) -> Option<LabeledStatement<'tree>> {
        match self {
            Self::LabeledStatement(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `return_statement` ([ReturnStatement]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn return_statement(self) -> Option<ReturnStatement<'tree>> {
        match self {
            Self::ReturnStatement(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `statement_block` ([StatementBlock]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn statement_block(self) -> Option<StatementBlock<'tree>> {
        match self {
            Self::StatementBlock(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `switch_statement` ([SwitchStatement]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn switch_statement(self) -> Option<SwitchStatement<'tree>> {
        match self {
            Self::SwitchStatement(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `throw_statement` ([ThrowStatement]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn throw_statement(self) -> Option<ThrowStatement<'tree>> {
        match self {
            Self::ThrowStatement(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `try_statement` ([TryStatement]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn try_statement(self) -> Option<TryStatement<'tree>> {
        match self {
            Self::TryStatement(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `while_statement` ([WhileStatement]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn while_statement(self) -> Option<WhileStatement<'tree>> {
        match self {
            Self::WhileStatement(x) => Some(x),
            _ => None,
        }
    }
    #[doc = "Returns the node if it is of kind `with_statement` ([WithStatement]), otherwise returns None"]
    #[inline]
    #[allow(unused, non_snake_case)]
    pub fn with_statement(self) -> Option<WithStatement<'tree>> {
        match self {
            Self::WithStatement(x) => Some(x),
            _ => None,
        }
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Statement<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        match node.kind() {
            "break_statement" => Ok(unsafe {
                Self::BreakStatement(<BreakStatement<'tree> as type_sitter_lib::TypedNode<
                    'tree,
                >>::from_node_unchecked(node))
            }),
            "continue_statement" => {
                Ok(unsafe {
                    Self :: ContinueStatement (< ContinueStatement < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "debugger_statement" => {
                Ok(unsafe {
                    Self :: DebuggerStatement (< DebuggerStatement < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "declaration" => {
                Ok(unsafe {
                    Self :: Declaration (< Declaration < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "do_statement" => {
                Ok(unsafe {
                    Self :: DoStatement (< DoStatement < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "empty_statement" => Ok(unsafe {
                Self::EmptyStatement(<EmptyStatement<'tree> as type_sitter_lib::TypedNode<
                    'tree,
                >>::from_node_unchecked(node))
            }),
            "export_statement" => Ok(unsafe {
                Self::ExportStatement(<ExportStatement<'tree> as type_sitter_lib::TypedNode<
                    'tree,
                >>::from_node_unchecked(node))
            }),
            "expression_statement" => Ok(unsafe {
                Self :: ExpressionStatement (< ExpressionStatement < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
            }),
            "for_in_statement" => Ok(unsafe {
                Self::ForInStatement(<ForInStatement<'tree> as type_sitter_lib::TypedNode<
                    'tree,
                >>::from_node_unchecked(node))
            }),
            "for_statement" => {
                Ok(unsafe {
                    Self :: ForStatement (< ForStatement < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "if_statement" => {
                Ok(unsafe {
                    Self :: IfStatement (< IfStatement < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "import_statement" => Ok(unsafe {
                Self::ImportStatement(<ImportStatement<'tree> as type_sitter_lib::TypedNode<
                    'tree,
                >>::from_node_unchecked(node))
            }),
            "labeled_statement" => {
                Ok(unsafe {
                    Self :: LabeledStatement (< LabeledStatement < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "return_statement" => Ok(unsafe {
                Self::ReturnStatement(<ReturnStatement<'tree> as type_sitter_lib::TypedNode<
                    'tree,
                >>::from_node_unchecked(node))
            }),
            "statement_block" => Ok(unsafe {
                Self::StatementBlock(<StatementBlock<'tree> as type_sitter_lib::TypedNode<
                    'tree,
                >>::from_node_unchecked(node))
            }),
            "switch_statement" => Ok(unsafe {
                Self::SwitchStatement(<SwitchStatement<'tree> as type_sitter_lib::TypedNode<
                    'tree,
                >>::from_node_unchecked(node))
            }),
            "throw_statement" => Ok(unsafe {
                Self::ThrowStatement(<ThrowStatement<'tree> as type_sitter_lib::TypedNode<
                    'tree,
                >>::from_node_unchecked(node))
            }),
            "try_statement" => {
                Ok(unsafe {
                    Self :: TryStatement (< TryStatement < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                })
            }
            "while_statement" => Ok(unsafe {
                Self::WhileStatement(<WhileStatement<'tree> as type_sitter_lib::TypedNode<
                    'tree,
                >>::from_node_unchecked(node))
            }),
            "with_statement" => Ok(unsafe {
                Self::WithStatement(<WithStatement<'tree> as type_sitter_lib::TypedNode<
                    'tree,
                >>::from_node_unchecked(node))
            }),
            _ => Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            }),
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for Statement<'tree> {
    const KIND: &'static str = "statement";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        match self {
            Self::BreakStatement(x) => x.node(),
            Self::ContinueStatement(x) => x.node(),
            Self::DebuggerStatement(x) => x.node(),
            Self::Declaration(x) => x.node(),
            Self::DoStatement(x) => x.node(),
            Self::EmptyStatement(x) => x.node(),
            Self::ExportStatement(x) => x.node(),
            Self::ExpressionStatement(x) => x.node(),
            Self::ForInStatement(x) => x.node(),
            Self::ForStatement(x) => x.node(),
            Self::IfStatement(x) => x.node(),
            Self::ImportStatement(x) => x.node(),
            Self::LabeledStatement(x) => x.node(),
            Self::ReturnStatement(x) => x.node(),
            Self::StatementBlock(x) => x.node(),
            Self::SwitchStatement(x) => x.node(),
            Self::ThrowStatement(x) => x.node(),
            Self::TryStatement(x) => x.node(),
            Self::WhileStatement(x) => x.node(),
            Self::WithStatement(x) => x.node(),
        }
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        match self {
            Self::BreakStatement(x) => x.node_mut(),
            Self::ContinueStatement(x) => x.node_mut(),
            Self::DebuggerStatement(x) => x.node_mut(),
            Self::Declaration(x) => x.node_mut(),
            Self::DoStatement(x) => x.node_mut(),
            Self::EmptyStatement(x) => x.node_mut(),
            Self::ExportStatement(x) => x.node_mut(),
            Self::ExpressionStatement(x) => x.node_mut(),
            Self::ForInStatement(x) => x.node_mut(),
            Self::ForStatement(x) => x.node_mut(),
            Self::IfStatement(x) => x.node_mut(),
            Self::ImportStatement(x) => x.node_mut(),
            Self::LabeledStatement(x) => x.node_mut(),
            Self::ReturnStatement(x) => x.node_mut(),
            Self::StatementBlock(x) => x.node_mut(),
            Self::SwitchStatement(x) => x.node_mut(),
            Self::ThrowStatement(x) => x.node_mut(),
            Self::TryStatement(x) => x.node_mut(),
            Self::WhileStatement(x) => x.node_mut(),
            Self::WithStatement(x) => x.node_mut(),
        }
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        match self {
            Self::BreakStatement(x) => x.into_node(),
            Self::ContinueStatement(x) => x.into_node(),
            Self::DebuggerStatement(x) => x.into_node(),
            Self::Declaration(x) => x.into_node(),
            Self::DoStatement(x) => x.into_node(),
            Self::EmptyStatement(x) => x.into_node(),
            Self::ExportStatement(x) => x.into_node(),
            Self::ExpressionStatement(x) => x.into_node(),
            Self::ForInStatement(x) => x.into_node(),
            Self::ForStatement(x) => x.into_node(),
            Self::IfStatement(x) => x.into_node(),
            Self::ImportStatement(x) => x.into_node(),
            Self::LabeledStatement(x) => x.into_node(),
            Self::ReturnStatement(x) => x.into_node(),
            Self::StatementBlock(x) => x.into_node(),
            Self::SwitchStatement(x) => x.into_node(),
            Self::ThrowStatement(x) => x.into_node(),
            Self::TryStatement(x) => x.into_node(),
            Self::WhileStatement(x) => x.into_node(),
            Self::WithStatement(x) => x.into_node(),
        }
    }
}
#[doc = "Typed node `abstract_class_declaration`\n\nThis node has these fields:\n- `body`: `class_body` ([ClassBody])\n- `decorator`: `decorator*` ([Decorator])\n- `name`: `type_identifier` ([TypeIdentifier])\n- `type_parameters`: `type_parameters?` ([TypeParameters])\n\nAnd an additional (optional) child: `class_heritage?` ([ClassHeritage])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct AbstractClassDeclaration<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> AbstractClassDeclaration<'tree> {
    #[doc = "Get the field `body` which has kind `class_body` ([ClassBody])"]
    #[allow(dead_code)]
    #[inline]
    pub fn body(&self) -> type_sitter_lib::NodeResult<'tree, ClassBody<'tree>> {
        self . 0 . child_by_field_name ("body") . map (< ClassBody < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `decorator` which has kind `decorator*` ([Decorator])"]
    #[allow(dead_code)]
    #[inline]
    pub fn decorators<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, Decorator<'tree>>,
        >,
    > + 'a {
        self.0
            .children_by_field_name("decorator", c)
            .map(|n| <type_sitter_lib::ExtraOr<'tree, Decorator<'tree>> as TryFrom<_>>::try_from(n))
    }
    #[doc = "Get the field `name` which has kind `type_identifier` ([TypeIdentifier])"]
    #[allow(dead_code)]
    #[inline]
    pub fn name(&self) -> type_sitter_lib::NodeResult<'tree, TypeIdentifier<'tree>> {
        self . 0 . child_by_field_name ("name") . map (< TypeIdentifier < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `type_parameters` which has kind `type_parameters?` ([TypeParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn type_parameters(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, TypeParameters<'tree>>> {
        self.0
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::ClassHeritage_ClassBody_Decorator_TypeIdentifier_TypeParameters<'tree>,
            >,
        >,
    > + 'a {
        self.0.named_children(c).map(|n| {
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::ClassHeritage_ClassBody_Decorator_TypeIdentifier_TypeParameters<'tree>,
            > as TryFrom<_>>::try_from(n)
        })
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::ClassHeritage_ClassBody_Decorator_TypeIdentifier_TypeParameters<'tree>,
            >,
        >,
    > {
        self.0.named_child(i).map(
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::ClassHeritage_ClassBody_Decorator_TypeIdentifier_TypeParameters<'tree>,
            > as TryFrom<_>>::try_from,
        )
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for AbstractClassDeclaration<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "abstract_class_declaration" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for AbstractClassDeclaration<'tree> {
    const KIND: &'static str = "abstract_class_declaration";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `abstract_method_signature`\n\nThis node has these fields:\n- `name`: `{computed_property_name | number | private_property_identifier | property_identifier | string}` ([anon_unions::ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String])\n- `nominal_return_type`: `nominal_type_annotation?` ([NominalTypeAnnotation])\n- `parameters`: `formal_parameters` ([FormalParameters])\n- `return_type`: `{asserts | type_annotation | type_predicate_annotation}?` ([anon_unions::Asserts_TypeAnnotation_TypePredicateAnnotation])\n- `type_parameters`: `type_parameters?` ([TypeParameters])\n\nAnd an additional (optional) child: `accessibility_modifier?` ([AccessibilityModifier])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct AbstractMethodSignature<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> AbstractMethodSignature<'tree> {
    #[doc = "Get the field `name` which has kind `{computed_property_name | number | private_property_identifier | property_identifier | string}` ([anon_unions::ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String])"]
    #[allow(dead_code)]
    #[inline]    pub fn name (& self) -> type_sitter_lib :: NodeResult < 'tree , anon_unions :: ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String < 'tree > >{
        self . 0 . child_by_field_name ("name") . map (< anon_unions :: ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `nominal_return_type` which has kind `nominal_type_annotation?` ([NominalTypeAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn nominal_return_type(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, NominalTypeAnnotation<'tree>>> {
        self.0
            .child_by_field_name("nominal_return_type")
            .map(<NominalTypeAnnotation<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `parameters` which has kind `formal_parameters` ([FormalParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn parameters(&self) -> type_sitter_lib::NodeResult<'tree, FormalParameters<'tree>> {
        self . 0 . child_by_field_name ("parameters") . map (< FormalParameters < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `return_type` which has kind `{asserts | type_annotation | type_predicate_annotation}?` ([anon_unions::Asserts_TypeAnnotation_TypePredicateAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn return_type(
        &self,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            anon_unions::Asserts_TypeAnnotation_TypePredicateAnnotation<'tree>,
        >,
    > {
        self . 0 . child_by_field_name ("return_type") . map (< anon_unions :: Asserts_TypeAnnotation_TypePredicateAnnotation < 'tree > as TryFrom < _ >> :: try_from)
    }
    #[doc = "Get the field `type_parameters` which has kind `type_parameters?` ([TypeParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn type_parameters(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, TypeParameters<'tree>>> {
        self.0
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]    pub fn children < 'a > (& self , c : & 'a mut yak_sitter :: TreeCursor < 'tree >) -> impl ExactSizeIterator < Item = type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AccessibilityModifier_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_FormalParameters_Asserts_TypeAnnotation_TypePredicateAnnotation_TypeParameters < 'tree > > >> + 'a{
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AccessibilityModifier_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_FormalParameters_Asserts_TypeAnnotation_TypePredicateAnnotation_TypeParameters < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]    pub fn child (& self , i : usize) -> Option < type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AccessibilityModifier_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_FormalParameters_Asserts_TypeAnnotation_TypePredicateAnnotation_TypeParameters < 'tree > > >>{
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AccessibilityModifier_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_FormalParameters_Asserts_TypeAnnotation_TypePredicateAnnotation_TypeParameters < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for AbstractMethodSignature<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "abstract_method_signature" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for AbstractMethodSignature<'tree> {
    const KIND: &'static str = "abstract_method_signature";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `accessibility_modifier`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct AccessibilityModifier<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> AccessibilityModifier<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for AccessibilityModifier<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "accessibility_modifier" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for AccessibilityModifier<'tree> {
    const KIND: &'static str = "accessibility_modifier";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `ambient_declaration`\n\nThis node has children: `{_primary_type | constructor_type | declaration | function_type | infer_type | property_identifier | readonly_type | statement_block}+`:\n- [PrimaryType]\n- [ConstructorType]\n- [Declaration]\n- [FunctionType]\n- [InferType]\n- [PropertyIdentifier]\n- [ReadonlyType]\n- [StatementBlock]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct AmbientDeclaration<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> AmbientDeclaration<'tree> {
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]    pub fn children < 'a > (& self , c : & 'a mut yak_sitter :: TreeCursor < 'tree >) -> impl ExactSizeIterator < Item = type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryType_ConstructorType_Declaration_FunctionType_InferType_PropertyIdentifier_ReadonlyType_StatementBlock < 'tree > > >> + 'a{
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryType_ConstructorType_Declaration_FunctionType_InferType_PropertyIdentifier_ReadonlyType_StatementBlock < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]    pub fn child (& self , i : usize) -> Option < type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryType_ConstructorType_Declaration_FunctionType_InferType_PropertyIdentifier_ReadonlyType_StatementBlock < 'tree > > >>{
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryType_ConstructorType_Declaration_FunctionType_InferType_PropertyIdentifier_ReadonlyType_StatementBlock < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for AmbientDeclaration<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "ambient_declaration" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for AmbientDeclaration<'tree> {
    const KIND: &'static str = "ambient_declaration";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `arguments`\n\nThis node has children: `{expression | spread_element}*`:\n- [Expression]\n- [SpreadElement]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct Arguments<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> Arguments<'tree> {
    #[doc = "Get the node's named children"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, anon_unions::Expression_SpreadElement<'tree>>,
        >,
    > + 'a {
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: Expression_SpreadElement < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, anon_unions::Expression_SpreadElement<'tree>>,
        >,
    > {
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: Expression_SpreadElement < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Arguments<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "arguments" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for Arguments<'tree> {
    const KIND: &'static str = "arguments";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `array`\n\nThis node has children: `{expression | spread_element}*`:\n- [Expression]\n- [SpreadElement]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct Array<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> Array<'tree> {
    #[doc = "Get the node's named children"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, anon_unions::Expression_SpreadElement<'tree>>,
        >,
    > + 'a {
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: Expression_SpreadElement < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, anon_unions::Expression_SpreadElement<'tree>>,
        >,
    > {
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: Expression_SpreadElement < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Array<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "array" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for Array<'tree> {
    const KIND: &'static str = "array";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `array_nominal_type`\n\nThis node has a child: `_primary_nominal_type` ([PrimaryNominalType])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ArrayNominalType<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ArrayNominalType<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(&self) -> type_sitter_lib::NodeResult<'tree, PrimaryNominalType<'tree>> {
        self . 0 . named_child (0) . map (< PrimaryNominalType < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ArrayNominalType<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "array_nominal_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ArrayNominalType<'tree> {
    const KIND: &'static str = "array_nominal_type";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `array_pattern`\n\nThis node has children: `{assignment_pattern | pattern}*`:\n- [AssignmentPattern]\n- [Pattern]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ArrayPattern<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ArrayPattern<'tree> {
    #[doc = "Get the node's named children"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, anon_unions::AssignmentPattern_Pattern<'tree>>,
        >,
    > + 'a {
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AssignmentPattern_Pattern < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, anon_unions::AssignmentPattern_Pattern<'tree>>,
        >,
    > {
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AssignmentPattern_Pattern < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ArrayPattern<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "array_pattern" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ArrayPattern<'tree> {
    const KIND: &'static str = "array_pattern";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `array_type`\n\nThis node has a child: `_primary_type` ([PrimaryType])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ArrayType<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ArrayType<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(&self) -> type_sitter_lib::NodeResult<'tree, PrimaryType<'tree>> {
        self . 0 . named_child (0) . map (< PrimaryType < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ArrayType<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "array_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ArrayType<'tree> {
    const KIND: &'static str = "array_type";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `arrow_function`\n\nThis node has these fields:\n- `body`: `{expression | statement_block}` ([anon_unions::Expression_StatementBlock])\n- `nominal_return_type`: `nominal_type_annotation?` ([NominalTypeAnnotation])\n- `parameter`: `identifier?` ([Identifier])\n- `parameters`: `formal_parameters?` ([FormalParameters])\n- `return_type`: `{asserts | type_annotation | type_predicate_annotation}?` ([anon_unions::Asserts_TypeAnnotation_TypePredicateAnnotation])\n- `type_parameters`: `type_parameters?` ([TypeParameters])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ArrowFunction<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ArrowFunction<'tree> {
    #[doc = "Get the field `body` which has kind `{expression | statement_block}` ([anon_unions::Expression_StatementBlock])"]
    #[allow(dead_code)]
    #[inline]
    pub fn body(
        &self,
    ) -> type_sitter_lib::NodeResult<'tree, anon_unions::Expression_StatementBlock<'tree>> {
        self . 0 . child_by_field_name ("body") . map (< anon_unions :: Expression_StatementBlock < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `nominal_return_type` which has kind `nominal_type_annotation?` ([NominalTypeAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn nominal_return_type(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, NominalTypeAnnotation<'tree>>> {
        self.0
            .child_by_field_name("nominal_return_type")
            .map(<NominalTypeAnnotation<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `parameter` which has kind `identifier?` ([Identifier])"]
    #[allow(dead_code)]
    #[inline]
    pub fn parameter(&self) -> Option<type_sitter_lib::NodeResult<'tree, Identifier<'tree>>> {
        self.0
            .child_by_field_name("parameter")
            .map(<Identifier<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `parameters` which has kind `formal_parameters?` ([FormalParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn parameters(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, FormalParameters<'tree>>> {
        self.0
            .child_by_field_name("parameters")
            .map(<FormalParameters<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `return_type` which has kind `{asserts | type_annotation | type_predicate_annotation}?` ([anon_unions::Asserts_TypeAnnotation_TypePredicateAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn return_type(
        &self,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            anon_unions::Asserts_TypeAnnotation_TypePredicateAnnotation<'tree>,
        >,
    > {
        self . 0 . child_by_field_name ("return_type") . map (< anon_unions :: Asserts_TypeAnnotation_TypePredicateAnnotation < 'tree > as TryFrom < _ >> :: try_from)
    }
    #[doc = "Get the field `type_parameters` which has kind `type_parameters?` ([TypeParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn type_parameters(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, TypeParameters<'tree>>> {
        self.0
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as TryFrom<_>>::try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ArrowFunction<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "arrow_function" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ArrowFunction<'tree> {
    const KIND: &'static str = "arrow_function";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `as_expression`\n\nThis node has children: `{_primary_type | constructor_type | expression | function_type | infer_type | readonly_type}+`:\n- [PrimaryType]\n- [ConstructorType]\n- [Expression]\n- [FunctionType]\n- [InferType]\n- [ReadonlyType]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct AsExpression<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> AsExpression<'tree> {
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]    pub fn children < 'a > (& self , c : & 'a mut yak_sitter :: TreeCursor < 'tree >) -> impl ExactSizeIterator < Item = type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryType_ConstructorType_Expression_FunctionType_InferType_ReadonlyType < 'tree > > >> + 'a{
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryType_ConstructorType_Expression_FunctionType_InferType_ReadonlyType < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]    pub fn child (& self , i : usize) -> Option < type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryType_ConstructorType_Expression_FunctionType_InferType_ReadonlyType < 'tree > > >>{
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryType_ConstructorType_Expression_FunctionType_InferType_ReadonlyType < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for AsExpression<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "as_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for AsExpression<'tree> {
    const KIND: &'static str = "as_expression";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `asserts`\n\nThis node has a child: `{identifier | this | type_predicate}`:\n- [Identifier]\n- [This]\n- [TypePredicate]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct Asserts<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> Asserts<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
    ) -> type_sitter_lib::NodeResult<'tree, anon_unions::Identifier_This_TypePredicate<'tree>> {
        self . 0 . named_child (0) . map (< anon_unions :: Identifier_This_TypePredicate < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Asserts<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "asserts" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for Asserts<'tree> {
    const KIND: &'static str = "asserts";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `assignment_expression`\n\nThis node has these fields:\n- `left`: `{array_pattern | identifier | member_expression | non_null_expression | object_pattern | parenthesized_expression | subscript_expression | undefined}` ([anon_unions::ArrayPattern_Identifier_MemberExpression_NonNullExpression_ObjectPattern_ParenthesizedExpression_SubscriptExpression_Undefined])\n- `right`: `expression` ([Expression])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct AssignmentExpression<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> AssignmentExpression<'tree> {
    #[doc = "Get the field `left` which has kind `{array_pattern | identifier | member_expression | non_null_expression | object_pattern | parenthesized_expression | subscript_expression | undefined}` ([anon_unions::ArrayPattern_Identifier_MemberExpression_NonNullExpression_ObjectPattern_ParenthesizedExpression_SubscriptExpression_Undefined])"]
    #[allow(dead_code)]
    #[inline]    pub fn left (& self) -> type_sitter_lib :: NodeResult < 'tree , anon_unions :: ArrayPattern_Identifier_MemberExpression_NonNullExpression_ObjectPattern_ParenthesizedExpression_SubscriptExpression_Undefined < 'tree > >{
        self . 0 . child_by_field_name ("left") . map (< anon_unions :: ArrayPattern_Identifier_MemberExpression_NonNullExpression_ObjectPattern_ParenthesizedExpression_SubscriptExpression_Undefined < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `right` which has kind `expression` ([Expression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn right(&self) -> type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        self . 0 . child_by_field_name ("right") . map (< Expression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for AssignmentExpression<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "assignment_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for AssignmentExpression<'tree> {
    const KIND: &'static str = "assignment_expression";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `assignment_pattern`\n\nThis node has these fields:\n- `left`: `pattern` ([Pattern])\n- `right`: `expression` ([Expression])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct AssignmentPattern<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> AssignmentPattern<'tree> {
    #[doc = "Get the field `left` which has kind `pattern` ([Pattern])"]
    #[allow(dead_code)]
    #[inline]
    pub fn left(&self) -> type_sitter_lib::NodeResult<'tree, Pattern<'tree>> {
        self . 0 . child_by_field_name ("left") . map (< Pattern < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `right` which has kind `expression` ([Expression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn right(&self) -> type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        self . 0 . child_by_field_name ("right") . map (< Expression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for AssignmentPattern<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "assignment_pattern" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for AssignmentPattern<'tree> {
    const KIND: &'static str = "assignment_pattern";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `augmented_assignment_expression`\n\nThis node has these fields:\n- `left`: `{identifier | member_expression | non_null_expression | parenthesized_expression | subscript_expression}` ([anon_unions::Identifier_MemberExpression_NonNullExpression_ParenthesizedExpression_SubscriptExpression])\n- `operator`: `{%= | &&= | &= | **= | *= | += | -= | /= | <<= | >>= | >>>= | ??= | ^= | |= | ||=}` ([anon_unions::ModEq_AndAndEq_AndEq_MulMulEq_MulEq_AddEq_SubEq_DivEq_LtLtEq_GtGtEq_GtGtGtEq_QuestionQuestionEq_BitXorEq_OrEq_OrOrEq])\n- `right`: `expression` ([Expression])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct AugmentedAssignmentExpression<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> AugmentedAssignmentExpression<'tree> {
    #[doc = "Get the field `left` which has kind `{identifier | member_expression | non_null_expression | parenthesized_expression | subscript_expression}` ([anon_unions::Identifier_MemberExpression_NonNullExpression_ParenthesizedExpression_SubscriptExpression])"]
    #[allow(dead_code)]
    #[inline]    pub fn left (& self) -> type_sitter_lib :: NodeResult < 'tree , anon_unions :: Identifier_MemberExpression_NonNullExpression_ParenthesizedExpression_SubscriptExpression < 'tree > >{
        self . 0 . child_by_field_name ("left") . map (< anon_unions :: Identifier_MemberExpression_NonNullExpression_ParenthesizedExpression_SubscriptExpression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `operator` which has kind `{%= | &&= | &= | **= | *= | += | -= | /= | <<= | >>= | >>>= | ??= | ^= | |= | ||=}` ([anon_unions::ModEq_AndAndEq_AndEq_MulMulEq_MulEq_AddEq_SubEq_DivEq_LtLtEq_GtGtEq_GtGtGtEq_QuestionQuestionEq_BitXorEq_OrEq_OrOrEq])"]
    #[allow(dead_code)]
    #[inline]    pub fn operator (& self) -> type_sitter_lib :: NodeResult < 'tree , anon_unions :: ModEq_AndAndEq_AndEq_MulMulEq_MulEq_AddEq_SubEq_DivEq_LtLtEq_GtGtEq_GtGtGtEq_QuestionQuestionEq_BitXorEq_OrEq_OrOrEq < 'tree > >{
        self . 0 . child_by_field_name ("operator") . map (< anon_unions :: ModEq_AndAndEq_AndEq_MulMulEq_MulEq_AddEq_SubEq_DivEq_LtLtEq_GtGtEq_GtGtGtEq_QuestionQuestionEq_BitXorEq_OrEq_OrOrEq < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `right` which has kind `expression` ([Expression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn right(&self) -> type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        self . 0 . child_by_field_name ("right") . map (< Expression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for AugmentedAssignmentExpression<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "augmented_assignment_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for AugmentedAssignmentExpression<'tree> {
    const KIND: &'static str = "augmented_assignment_expression";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `await_expression`\n\nThis node has a child: `expression` ([Expression])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct AwaitExpression<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> AwaitExpression<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(&self) -> type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        self . 0 . named_child (0) . map (< Expression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for AwaitExpression<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "await_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for AwaitExpression<'tree> {
    const KIND: &'static str = "await_expression";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `binary_expression`\n\nThis node has these fields:\n- `left`: `expression` ([Expression])\n- `operator`: `{!= | !== | % | & | && | * | ** | + | - | / | < | << | <= | == | === | > | >= | >> | >>> | ?? | ^ | in | instanceof | | | ||}` ([anon_unions::NotEq_NotEqEq_Mod_And_AndAnd_Mul_MulMul_Add_Sub_Div_Lt_LtLt_LtEq_EqEq_EqEqEq_Gt_GtEq_GtGt_GtGtGt_QuestionQuestion_BitXor_In_Instanceof_Or_OrOr])\n- `right`: `expression` ([Expression])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct BinaryExpression<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> BinaryExpression<'tree> {
    #[doc = "Get the field `left` which has kind `expression` ([Expression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn left(&self) -> type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        self . 0 . child_by_field_name ("left") . map (< Expression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `operator` which has kind `{!= | !== | % | & | && | * | ** | + | - | / | < | << | <= | == | === | > | >= | >> | >>> | ?? | ^ | in | instanceof | | | ||}` ([anon_unions::NotEq_NotEqEq_Mod_And_AndAnd_Mul_MulMul_Add_Sub_Div_Lt_LtLt_LtEq_EqEq_EqEqEq_Gt_GtEq_GtGt_GtGtGt_QuestionQuestion_BitXor_In_Instanceof_Or_OrOr])"]
    #[allow(dead_code)]
    #[inline]    pub fn operator (& self) -> type_sitter_lib :: NodeResult < 'tree , anon_unions :: NotEq_NotEqEq_Mod_And_AndAnd_Mul_MulMul_Add_Sub_Div_Lt_LtLt_LtEq_EqEq_EqEqEq_Gt_GtEq_GtGt_GtGtGt_QuestionQuestion_BitXor_In_Instanceof_Or_OrOr < 'tree > >{
        self . 0 . child_by_field_name ("operator") . map (< anon_unions :: NotEq_NotEqEq_Mod_And_AndAnd_Mul_MulMul_Add_Sub_Div_Lt_LtLt_LtEq_EqEq_EqEqEq_Gt_GtEq_GtGt_GtGtGt_QuestionQuestion_BitXor_In_Instanceof_Or_OrOr < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `right` which has kind `expression` ([Expression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn right(&self) -> type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        self . 0 . child_by_field_name ("right") . map (< Expression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for BinaryExpression<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "binary_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for BinaryExpression<'tree> {
    const KIND: &'static str = "binary_expression";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `break_statement`\n\nThis node has these fields:\n- `label`: `statement_identifier?` ([StatementIdentifier])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct BreakStatement<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> BreakStatement<'tree> {
    #[doc = "Get the field `label` which has kind `statement_identifier?` ([StatementIdentifier])"]
    #[allow(dead_code)]
    #[inline]
    pub fn label(&self) -> Option<type_sitter_lib::NodeResult<'tree, StatementIdentifier<'tree>>> {
        self.0
            .child_by_field_name("label")
            .map(<StatementIdentifier<'tree> as TryFrom<_>>::try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for BreakStatement<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "break_statement" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for BreakStatement<'tree> {
    const KIND: &'static str = "break_statement";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `call_expression`\n\nThis node has these fields:\n- `arguments`: `{arguments | template_string}` ([anon_unions::Arguments_TemplateString])\n- `function`: `expression` ([Expression])\n- `type_arguments`: `type_arguments?` ([TypeArguments])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct CallExpression<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> CallExpression<'tree> {
    #[doc = "Get the field `arguments` which has kind `{arguments | template_string}` ([anon_unions::Arguments_TemplateString])"]
    #[allow(dead_code)]
    #[inline]
    pub fn arguments(
        &self,
    ) -> type_sitter_lib::NodeResult<'tree, anon_unions::Arguments_TemplateString<'tree>> {
        self . 0 . child_by_field_name ("arguments") . map (< anon_unions :: Arguments_TemplateString < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `function` which has kind `expression` ([Expression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn function(&self) -> type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        self . 0 . child_by_field_name ("function") . map (< Expression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `type_arguments` which has kind `type_arguments?` ([TypeArguments])"]
    #[allow(dead_code)]
    #[inline]
    pub fn type_arguments(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, TypeArguments<'tree>>> {
        self.0
            .child_by_field_name("type_arguments")
            .map(<TypeArguments<'tree> as TryFrom<_>>::try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for CallExpression<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "call_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for CallExpression<'tree> {
    const KIND: &'static str = "call_expression";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `call_signature`\n\nThis node has these fields:\n- `nominal_return_type`: `nominal_type_annotation?` ([NominalTypeAnnotation])\n- `parameters`: `formal_parameters` ([FormalParameters])\n- `return_type`: `{asserts | type_annotation | type_predicate_annotation}?` ([anon_unions::Asserts_TypeAnnotation_TypePredicateAnnotation])\n- `type_parameters`: `type_parameters?` ([TypeParameters])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct CallSignature<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> CallSignature<'tree> {
    #[doc = "Get the field `nominal_return_type` which has kind `nominal_type_annotation?` ([NominalTypeAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn nominal_return_type(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, NominalTypeAnnotation<'tree>>> {
        self.0
            .child_by_field_name("nominal_return_type")
            .map(<NominalTypeAnnotation<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `parameters` which has kind `formal_parameters` ([FormalParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn parameters(&self) -> type_sitter_lib::NodeResult<'tree, FormalParameters<'tree>> {
        self . 0 . child_by_field_name ("parameters") . map (< FormalParameters < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `return_type` which has kind `{asserts | type_annotation | type_predicate_annotation}?` ([anon_unions::Asserts_TypeAnnotation_TypePredicateAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn return_type(
        &self,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            anon_unions::Asserts_TypeAnnotation_TypePredicateAnnotation<'tree>,
        >,
    > {
        self . 0 . child_by_field_name ("return_type") . map (< anon_unions :: Asserts_TypeAnnotation_TypePredicateAnnotation < 'tree > as TryFrom < _ >> :: try_from)
    }
    #[doc = "Get the field `type_parameters` which has kind `type_parameters?` ([TypeParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn type_parameters(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, TypeParameters<'tree>>> {
        self.0
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as TryFrom<_>>::try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for CallSignature<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "call_signature" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for CallSignature<'tree> {
    const KIND: &'static str = "call_signature";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `catch_clause`\n\nThis node has these fields:\n- `body`: `statement_block` ([StatementBlock])\n- `nominal_type`: `nominal_type_annotation?` ([NominalTypeAnnotation])\n- `parameter`: `{array_pattern | identifier | object_pattern}?` ([anon_unions::ArrayPattern_Identifier_ObjectPattern])\n- `type`: `type_annotation?` ([TypeAnnotation])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct CatchClause<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> CatchClause<'tree> {
    #[doc = "Get the field `body` which has kind `statement_block` ([StatementBlock])"]
    #[allow(dead_code)]
    #[inline]
    pub fn body(&self) -> type_sitter_lib::NodeResult<'tree, StatementBlock<'tree>> {
        self . 0 . child_by_field_name ("body") . map (< StatementBlock < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `nominal_type` which has kind `nominal_type_annotation?` ([NominalTypeAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn nominal_type(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, NominalTypeAnnotation<'tree>>> {
        self.0
            .child_by_field_name("nominal_type")
            .map(<NominalTypeAnnotation<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `parameter` which has kind `{array_pattern | identifier | object_pattern}?` ([anon_unions::ArrayPattern_Identifier_ObjectPattern])"]
    #[allow(dead_code)]
    #[inline]
    pub fn parameter(
        &self,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            anon_unions::ArrayPattern_Identifier_ObjectPattern<'tree>,
        >,
    > {
        self.0.child_by_field_name("parameter").map(
            <anon_unions::ArrayPattern_Identifier_ObjectPattern<'tree> as TryFrom<_>>::try_from,
        )
    }
    #[doc = "Get the field `type` which has kind `type_annotation?` ([TypeAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn r#type(&self) -> Option<type_sitter_lib::NodeResult<'tree, TypeAnnotation<'tree>>> {
        self.0
            .child_by_field_name("type")
            .map(<TypeAnnotation<'tree> as TryFrom<_>>::try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for CatchClause<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "catch_clause" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for CatchClause<'tree> {
    const KIND: &'static str = "catch_clause";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `class`\n\nThis node has these fields:\n- `body`: `class_body` ([ClassBody])\n- `decorator`: `decorator*` ([Decorator])\n- `name`: `type_identifier?` ([TypeIdentifier])\n- `type_parameters`: `type_parameters?` ([TypeParameters])\n\nAnd an additional (optional) child: `class_heritage?` ([ClassHeritage])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct Class<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> Class<'tree> {
    #[doc = "Get the field `body` which has kind `class_body` ([ClassBody])"]
    #[allow(dead_code)]
    #[inline]
    pub fn body(&self) -> type_sitter_lib::NodeResult<'tree, ClassBody<'tree>> {
        self . 0 . child_by_field_name ("body") . map (< ClassBody < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `decorator` which has kind `decorator*` ([Decorator])"]
    #[allow(dead_code)]
    #[inline]
    pub fn decorators<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, Decorator<'tree>>,
        >,
    > + 'a {
        self.0
            .children_by_field_name("decorator", c)
            .map(|n| <type_sitter_lib::ExtraOr<'tree, Decorator<'tree>> as TryFrom<_>>::try_from(n))
    }
    #[doc = "Get the field `name` which has kind `type_identifier?` ([TypeIdentifier])"]
    #[allow(dead_code)]
    #[inline]
    pub fn name(&self) -> Option<type_sitter_lib::NodeResult<'tree, TypeIdentifier<'tree>>> {
        self.0
            .child_by_field_name("name")
            .map(<TypeIdentifier<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `type_parameters` which has kind `type_parameters?` ([TypeParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn type_parameters(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, TypeParameters<'tree>>> {
        self.0
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::ClassHeritage_ClassBody_Decorator_TypeIdentifier_TypeParameters<'tree>,
            >,
        >,
    > + 'a {
        self.0.named_children(c).map(|n| {
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::ClassHeritage_ClassBody_Decorator_TypeIdentifier_TypeParameters<'tree>,
            > as TryFrom<_>>::try_from(n)
        })
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::ClassHeritage_ClassBody_Decorator_TypeIdentifier_TypeParameters<'tree>,
            >,
        >,
    > {
        self.0.named_child(i).map(
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::ClassHeritage_ClassBody_Decorator_TypeIdentifier_TypeParameters<'tree>,
            > as TryFrom<_>>::try_from,
        )
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Class<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "class" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for Class<'tree> {
    const KIND: &'static str = "class";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `class_body`\n\nThis node has children: `{abstract_method_signature | class_static_block | decorator | index_signature | method_definition | method_signature | public_field_definition}*`:\n- [AbstractMethodSignature]\n- [ClassStaticBlock]\n- [Decorator]\n- [IndexSignature]\n- [MethodDefinition]\n- [MethodSignature]\n- [PublicFieldDefinition]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ClassBody<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ClassBody<'tree> {
    #[doc = "Get the node's named children"]
    #[allow(dead_code)]
    #[inline]    pub fn children < 'a > (& self , c : & 'a mut yak_sitter :: TreeCursor < 'tree >) -> impl ExactSizeIterator < Item = type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AbstractMethodSignature_ClassStaticBlock_Decorator_IndexSignature_MethodDefinition_MethodSignature_PublicFieldDefinition < 'tree > > >> + 'a{
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AbstractMethodSignature_ClassStaticBlock_Decorator_IndexSignature_MethodDefinition_MethodSignature_PublicFieldDefinition < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]    pub fn child (& self , i : usize) -> Option < type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AbstractMethodSignature_ClassStaticBlock_Decorator_IndexSignature_MethodDefinition_MethodSignature_PublicFieldDefinition < 'tree > > >>{
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AbstractMethodSignature_ClassStaticBlock_Decorator_IndexSignature_MethodDefinition_MethodSignature_PublicFieldDefinition < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ClassBody<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "class_body" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ClassBody<'tree> {
    const KIND: &'static str = "class_body";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `class_declaration`\n\nThis node has these fields:\n- `body`: `class_body` ([ClassBody])\n- `decorator`: `decorator*` ([Decorator])\n- `name`: `type_identifier` ([TypeIdentifier])\n- `type_parameters`: `type_parameters?` ([TypeParameters])\n\nAnd an additional (optional) child: `class_heritage?` ([ClassHeritage])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ClassDeclaration<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ClassDeclaration<'tree> {
    #[doc = "Get the field `body` which has kind `class_body` ([ClassBody])"]
    #[allow(dead_code)]
    #[inline]
    pub fn body(&self) -> type_sitter_lib::NodeResult<'tree, ClassBody<'tree>> {
        self . 0 . child_by_field_name ("body") . map (< ClassBody < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `decorator` which has kind `decorator*` ([Decorator])"]
    #[allow(dead_code)]
    #[inline]
    pub fn decorators<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, Decorator<'tree>>,
        >,
    > + 'a {
        self.0
            .children_by_field_name("decorator", c)
            .map(|n| <type_sitter_lib::ExtraOr<'tree, Decorator<'tree>> as TryFrom<_>>::try_from(n))
    }
    #[doc = "Get the field `name` which has kind `type_identifier` ([TypeIdentifier])"]
    #[allow(dead_code)]
    #[inline]
    pub fn name(&self) -> type_sitter_lib::NodeResult<'tree, TypeIdentifier<'tree>> {
        self . 0 . child_by_field_name ("name") . map (< TypeIdentifier < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `type_parameters` which has kind `type_parameters?` ([TypeParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn type_parameters(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, TypeParameters<'tree>>> {
        self.0
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::ClassHeritage_ClassBody_Decorator_TypeIdentifier_TypeParameters<'tree>,
            >,
        >,
    > + 'a {
        self.0.named_children(c).map(|n| {
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::ClassHeritage_ClassBody_Decorator_TypeIdentifier_TypeParameters<'tree>,
            > as TryFrom<_>>::try_from(n)
        })
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::ClassHeritage_ClassBody_Decorator_TypeIdentifier_TypeParameters<'tree>,
            >,
        >,
    > {
        self.0.named_child(i).map(
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::ClassHeritage_ClassBody_Decorator_TypeIdentifier_TypeParameters<'tree>,
            > as TryFrom<_>>::try_from,
        )
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ClassDeclaration<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "class_declaration" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ClassDeclaration<'tree> {
    const KIND: &'static str = "class_declaration";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `class_heritage`\n\nThis node has children: `{extends_clause | implements_clause}+`:\n- [ExtendsClause]\n- [ImplementsClause]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ClassHeritage<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ClassHeritage<'tree> {
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, anon_unions::ExtendsClause_ImplementsClause<'tree>>,
        >,
    > + 'a {
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: ExtendsClause_ImplementsClause < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, anon_unions::ExtendsClause_ImplementsClause<'tree>>,
        >,
    > {
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: ExtendsClause_ImplementsClause < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ClassHeritage<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "class_heritage" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ClassHeritage<'tree> {
    const KIND: &'static str = "class_heritage";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `class_static_block`\n\nThis node has these fields:\n- `body`: `statement_block` ([StatementBlock])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ClassStaticBlock<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ClassStaticBlock<'tree> {
    #[doc = "Get the field `body` which has kind `statement_block` ([StatementBlock])"]
    #[allow(dead_code)]
    #[inline]
    pub fn body(&self) -> type_sitter_lib::NodeResult<'tree, StatementBlock<'tree>> {
        self . 0 . child_by_field_name ("body") . map (< StatementBlock < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ClassStaticBlock<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "class_static_block" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ClassStaticBlock<'tree> {
    const KIND: &'static str = "class_static_block";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `computed_property_name`\n\nThis node has a child: `expression` ([Expression])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ComputedPropertyName<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ComputedPropertyName<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(&self) -> type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        self . 0 . named_child (0) . map (< Expression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ComputedPropertyName<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "computed_property_name" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ComputedPropertyName<'tree> {
    const KIND: &'static str = "computed_property_name";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `conditional_type`\n\nThis node has these fields:\n- `alternative`: `{_primary_type | constructor_type | function_type | infer_type | readonly_type}` ([anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType])\n- `consequence`: `{_primary_type | constructor_type | function_type | infer_type | readonly_type}` ([anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType])\n- `left`: `{_primary_type | constructor_type | function_type | infer_type | readonly_type}` ([anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType])\n- `right`: `{_primary_type | constructor_type | function_type | infer_type | readonly_type}` ([anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ConditionalType<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ConditionalType<'tree> {
    #[doc = "Get the field `alternative` which has kind `{_primary_type | constructor_type | function_type | infer_type | readonly_type}` ([anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType])"]
    #[allow(dead_code)]
    #[inline]
    pub fn alternative(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
    > {
        self . 0 . child_by_field_name ("alternative") . map (< anon_unions :: PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `consequence` which has kind `{_primary_type | constructor_type | function_type | infer_type | readonly_type}` ([anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType])"]
    #[allow(dead_code)]
    #[inline]
    pub fn consequence(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
    > {
        self . 0 . child_by_field_name ("consequence") . map (< anon_unions :: PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `left` which has kind `{_primary_type | constructor_type | function_type | infer_type | readonly_type}` ([anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType])"]
    #[allow(dead_code)]
    #[inline]
    pub fn left(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
    > {
        self . 0 . child_by_field_name ("left") . map (< anon_unions :: PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `right` which has kind `{_primary_type | constructor_type | function_type | infer_type | readonly_type}` ([anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType])"]
    #[allow(dead_code)]
    #[inline]
    pub fn right(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
    > {
        self . 0 . child_by_field_name ("right") . map (< anon_unions :: PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ConditionalType<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "conditional_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ConditionalType<'tree> {
    const KIND: &'static str = "conditional_type";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `constraint`\n\nThis node has a child: `{_primary_type | constructor_type | function_type | infer_type | readonly_type}`:\n- [PrimaryType]\n- [ConstructorType]\n- [FunctionType]\n- [InferType]\n- [ReadonlyType]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct Constraint<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> Constraint<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
    > {
        self . 0 . named_child (0) . map (< anon_unions :: PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Constraint<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "constraint" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for Constraint<'tree> {
    const KIND: &'static str = "constraint";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `construct_signature`\n\nThis node has these fields:\n- `parameters`: `formal_parameters` ([FormalParameters])\n- `type`: `type_annotation?` ([TypeAnnotation])\n- `type_parameters`: `type_parameters?` ([TypeParameters])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ConstructSignature<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ConstructSignature<'tree> {
    #[doc = "Get the field `parameters` which has kind `formal_parameters` ([FormalParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn parameters(&self) -> type_sitter_lib::NodeResult<'tree, FormalParameters<'tree>> {
        self . 0 . child_by_field_name ("parameters") . map (< FormalParameters < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `type` which has kind `type_annotation?` ([TypeAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn r#type(&self) -> Option<type_sitter_lib::NodeResult<'tree, TypeAnnotation<'tree>>> {
        self.0
            .child_by_field_name("type")
            .map(<TypeAnnotation<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `type_parameters` which has kind `type_parameters?` ([TypeParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn type_parameters(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, TypeParameters<'tree>>> {
        self.0
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as TryFrom<_>>::try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ConstructSignature<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "construct_signature" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ConstructSignature<'tree> {
    const KIND: &'static str = "construct_signature";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `constructor_type`\n\nThis node has these fields:\n- `parameters`: `formal_parameters` ([FormalParameters])\n- `type`: `{_primary_type | constructor_type | function_type | infer_type | readonly_type}` ([anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType])\n- `type_parameters`: `type_parameters?` ([TypeParameters])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ConstructorType<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ConstructorType<'tree> {
    #[doc = "Get the field `parameters` which has kind `formal_parameters` ([FormalParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn parameters(&self) -> type_sitter_lib::NodeResult<'tree, FormalParameters<'tree>> {
        self . 0 . child_by_field_name ("parameters") . map (< FormalParameters < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `type` which has kind `{_primary_type | constructor_type | function_type | infer_type | readonly_type}` ([anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType])"]
    #[allow(dead_code)]
    #[inline]
    pub fn r#type(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
    > {
        self . 0 . child_by_field_name ("type") . map (< anon_unions :: PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `type_parameters` which has kind `type_parameters?` ([TypeParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn type_parameters(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, TypeParameters<'tree>>> {
        self.0
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as TryFrom<_>>::try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ConstructorType<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "constructor_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ConstructorType<'tree> {
    const KIND: &'static str = "constructor_type";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `continue_statement`\n\nThis node has these fields:\n- `label`: `statement_identifier?` ([StatementIdentifier])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ContinueStatement<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ContinueStatement<'tree> {
    #[doc = "Get the field `label` which has kind `statement_identifier?` ([StatementIdentifier])"]
    #[allow(dead_code)]
    #[inline]
    pub fn label(&self) -> Option<type_sitter_lib::NodeResult<'tree, StatementIdentifier<'tree>>> {
        self.0
            .child_by_field_name("label")
            .map(<StatementIdentifier<'tree> as TryFrom<_>>::try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ContinueStatement<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "continue_statement" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ContinueStatement<'tree> {
    const KIND: &'static str = "continue_statement";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `debugger_statement`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct DebuggerStatement<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> DebuggerStatement<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for DebuggerStatement<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "debugger_statement" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for DebuggerStatement<'tree> {
    const KIND: &'static str = "debugger_statement";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `decorator`\n\nThis node has a child: `{call_expression | identifier | member_expression}`:\n- [CallExpression]\n- [Identifier]\n- [MemberExpression]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct Decorator<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> Decorator<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::CallExpression_Identifier_MemberExpression<'tree>,
    > {
        self . 0 . named_child (0) . map (< anon_unions :: CallExpression_Identifier_MemberExpression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Decorator<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "decorator" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for Decorator<'tree> {
    const KIND: &'static str = "decorator";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `default_type`\n\nThis node has a child: `{_primary_type | constructor_type | function_type | infer_type | readonly_type}`:\n- [PrimaryType]\n- [ConstructorType]\n- [FunctionType]\n- [InferType]\n- [ReadonlyType]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct DefaultType<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> DefaultType<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
    > {
        self . 0 . named_child (0) . map (< anon_unions :: PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for DefaultType<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "default_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for DefaultType<'tree> {
    const KIND: &'static str = "default_type";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `do_statement`\n\nThis node has these fields:\n- `body`: `statement` ([Statement])\n- `condition`: `parenthesized_expression` ([ParenthesizedExpression])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct DoStatement<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> DoStatement<'tree> {
    #[doc = "Get the field `body` which has kind `statement` ([Statement])"]
    #[allow(dead_code)]
    #[inline]
    pub fn body(&self) -> type_sitter_lib::NodeResult<'tree, Statement<'tree>> {
        self . 0 . child_by_field_name ("body") . map (< Statement < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `condition` which has kind `parenthesized_expression` ([ParenthesizedExpression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn condition(&self) -> type_sitter_lib::NodeResult<'tree, ParenthesizedExpression<'tree>> {
        self . 0 . child_by_field_name ("condition") . map (< ParenthesizedExpression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for DoStatement<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "do_statement" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for DoStatement<'tree> {
    const KIND: &'static str = "do_statement";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `else_clause`\n\nThis node has a child: `statement` ([Statement])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ElseClause<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ElseClause<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(&self) -> type_sitter_lib::NodeResult<'tree, Statement<'tree>> {
        self . 0 . named_child (0) . map (< Statement < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ElseClause<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "else_clause" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ElseClause<'tree> {
    const KIND: &'static str = "else_clause";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `empty_statement`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct EmptyStatement<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> EmptyStatement<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for EmptyStatement<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "empty_statement" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for EmptyStatement<'tree> {
    const KIND: &'static str = "empty_statement";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `enum_assignment`\n\nThis node has these fields:\n- `name`: `{computed_property_name | number | private_property_identifier | property_identifier | string}` ([anon_unions::ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String])\n- `value`: `expression` ([Expression])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct EnumAssignment<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> EnumAssignment<'tree> {
    #[doc = "Get the field `name` which has kind `{computed_property_name | number | private_property_identifier | property_identifier | string}` ([anon_unions::ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String])"]
    #[allow(dead_code)]
    #[inline]    pub fn name (& self) -> type_sitter_lib :: NodeResult < 'tree , anon_unions :: ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String < 'tree > >{
        self . 0 . child_by_field_name ("name") . map (< anon_unions :: ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `value` which has kind `expression` ([Expression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn value(&self) -> type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        self . 0 . child_by_field_name ("value") . map (< Expression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for EnumAssignment<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "enum_assignment" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for EnumAssignment<'tree> {
    const KIND: &'static str = "enum_assignment";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `enum_body`\n\nThis node has these fields:\n- `name`: `{computed_property_name | number | private_property_identifier | property_identifier | string}*` ([anon_unions::ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String])\n\nAnd additional children: `enum_assignment*` ([EnumAssignment])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct EnumBody<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> EnumBody<'tree> {
    #[doc = "Get the field `name` which has kind `{computed_property_name | number | private_property_identifier | property_identifier | string}*` ([anon_unions::ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String])"]
    #[allow(dead_code)]
    #[inline]    pub fn names < 'a > (& self , c : & 'a mut yak_sitter :: TreeCursor < 'tree >) -> impl Iterator < Item = type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String < 'tree > > >> + 'a{
        self . 0 . children_by_field_name ("name" , c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named children"]
    #[allow(dead_code)]
    #[inline]    pub fn children < 'a > (& self , c : & 'a mut yak_sitter :: TreeCursor < 'tree >) -> impl ExactSizeIterator < Item = type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: EnumAssignment_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String < 'tree > > >> + 'a{
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: EnumAssignment_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]    pub fn child (& self , i : usize) -> Option < type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: EnumAssignment_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String < 'tree > > >>{
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: EnumAssignment_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for EnumBody<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "enum_body" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for EnumBody<'tree> {
    const KIND: &'static str = "enum_body";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `enum_declaration`\n\nThis node has these fields:\n- `body`: `enum_body` ([EnumBody])\n- `name`: `identifier` ([Identifier])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct EnumDeclaration<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> EnumDeclaration<'tree> {
    #[doc = "Get the field `body` which has kind `enum_body` ([EnumBody])"]
    #[allow(dead_code)]
    #[inline]
    pub fn body(&self) -> type_sitter_lib::NodeResult<'tree, EnumBody<'tree>> {
        self . 0 . child_by_field_name ("body") . map (< EnumBody < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `name` which has kind `identifier` ([Identifier])"]
    #[allow(dead_code)]
    #[inline]
    pub fn name(&self) -> type_sitter_lib::NodeResult<'tree, Identifier<'tree>> {
        self . 0 . child_by_field_name ("name") . map (< Identifier < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for EnumDeclaration<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "enum_declaration" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for EnumDeclaration<'tree> {
    const KIND: &'static str = "enum_declaration";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `existential_type`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ExistentialType<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ExistentialType<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ExistentialType<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "existential_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ExistentialType<'tree> {
    const KIND: &'static str = "existential_type";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `export_clause`\n\nThis node has children: `export_specifier*` ([ExportSpecifier])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ExportClause<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ExportClause<'tree> {
    #[doc = "Get the node's named children"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, ExportSpecifier<'tree>>,
        >,
    > + 'a {
        self.0.named_children(c).map(|n| {
            <type_sitter_lib::ExtraOr<'tree, ExportSpecifier<'tree>> as TryFrom<_>>::try_from(n)
        })
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<'tree, type_sitter_lib::ExtraOr<'tree, ExportSpecifier<'tree>>>,
    > {
        self.0
            .named_child(i)
            .map(<type_sitter_lib::ExtraOr<'tree, ExportSpecifier<'tree>> as TryFrom<_>>::try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ExportClause<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "export_clause" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ExportClause<'tree> {
    const KIND: &'static str = "export_clause";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `export_specifier`\n\nThis node has these fields:\n- `alias`: `{identifier | string}?` ([anon_unions::Identifier_String])\n- `name`: `{identifier | string}?` ([anon_unions::Identifier_String])\n\nAnd an additional (optional) child: `nominal_type_identifier?` ([NominalTypeIdentifier])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ExportSpecifier<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ExportSpecifier<'tree> {
    #[doc = "Get the field `alias` which has kind `{identifier | string}?` ([anon_unions::Identifier_String])"]
    #[allow(dead_code)]
    #[inline]
    pub fn alias(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, anon_unions::Identifier_String<'tree>>> {
        self.0
            .child_by_field_name("alias")
            .map(<anon_unions::Identifier_String<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `name` which has kind `{identifier | string}?` ([anon_unions::Identifier_String])"]
    #[allow(dead_code)]
    #[inline]
    pub fn name(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, anon_unions::Identifier_String<'tree>>> {
        self.0
            .child_by_field_name("name")
            .map(<anon_unions::Identifier_String<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the node's named children"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::NominalTypeIdentifier_Identifier_String<'tree>,
            >,
        >,
    > + 'a {
        self.0.named_children(c).map(|n| {
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::NominalTypeIdentifier_Identifier_String<'tree>,
            > as TryFrom<_>>::try_from(n)
        })
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::NominalTypeIdentifier_Identifier_String<'tree>,
            >,
        >,
    > {
        self.0.named_child(i).map(
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::NominalTypeIdentifier_Identifier_String<'tree>,
            > as TryFrom<_>>::try_from,
        )
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ExportSpecifier<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "export_specifier" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ExportSpecifier<'tree> {
    const KIND: &'static str = "export_specifier";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `export_statement`\n\nThis node has these fields:\n- `declaration`: `declaration?` ([Declaration])\n- `decorator`: `decorator*` ([Decorator])\n- `source`: `string?` ([String])\n- `value`: `expression?` ([Expression])\n\nAnd an additional (optional) child: `{export_clause | expression | identifier | namespace_export}?`:\n- [ExportClause]\n- [Expression]\n- [Identifier]\n- [NamespaceExport]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ExportStatement<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ExportStatement<'tree> {
    #[doc = "Get the field `declaration` which has kind `declaration?` ([Declaration])"]
    #[allow(dead_code)]
    #[inline]
    pub fn declaration(&self) -> Option<type_sitter_lib::NodeResult<'tree, Declaration<'tree>>> {
        self.0
            .child_by_field_name("declaration")
            .map(<Declaration<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `decorator` which has kind `decorator*` ([Decorator])"]
    #[allow(dead_code)]
    #[inline]
    pub fn decorators<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, Decorator<'tree>>,
        >,
    > + 'a {
        self.0
            .children_by_field_name("decorator", c)
            .map(|n| <type_sitter_lib::ExtraOr<'tree, Decorator<'tree>> as TryFrom<_>>::try_from(n))
    }
    #[doc = "Get the field `source` which has kind `string?` ([String])"]
    #[allow(dead_code)]
    #[inline]
    pub fn source(&self) -> Option<type_sitter_lib::NodeResult<'tree, String<'tree>>> {
        self.0
            .child_by_field_name("source")
            .map(<String<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `value` which has kind `expression?` ([Expression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn value(&self) -> Option<type_sitter_lib::NodeResult<'tree, Expression<'tree>>> {
        self.0
            .child_by_field_name("value")
            .map(<Expression<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the node's named children"]
    #[allow(dead_code)]
    #[inline]    pub fn children < 'a > (& self , c : & 'a mut yak_sitter :: TreeCursor < 'tree >) -> impl ExactSizeIterator < Item = type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: ExportClause_Expression_Identifier_NamespaceExport_Declaration_Decorator_String < 'tree > > >> + 'a{
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: ExportClause_Expression_Identifier_NamespaceExport_Declaration_Decorator_String < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]    pub fn child (& self , i : usize) -> Option < type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: ExportClause_Expression_Identifier_NamespaceExport_Declaration_Decorator_String < 'tree > > >>{
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: ExportClause_Expression_Identifier_NamespaceExport_Declaration_Decorator_String < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ExportStatement<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "export_statement" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ExportStatement<'tree> {
    const KIND: &'static str = "export_statement";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `expression_statement`\n\nThis node has a child: `{expression | sequence_expression}`:\n- [Expression]\n- [SequenceExpression]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ExpressionStatement<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ExpressionStatement<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
    ) -> type_sitter_lib::NodeResult<'tree, anon_unions::Expression_SequenceExpression<'tree>> {
        self . 0 . named_child (0) . map (< anon_unions :: Expression_SequenceExpression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ExpressionStatement<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "expression_statement" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ExpressionStatement<'tree> {
    const KIND: &'static str = "expression_statement";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `extends_clause`\n\nThis node has these fields:\n- `type_arguments`: `type_arguments*` ([TypeArguments])\n- `value`: `expression+` ([Expression])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ExtendsClause<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ExtendsClause<'tree> {
    #[doc = "Get the field `type_arguments` which has kind `type_arguments*` ([TypeArguments])"]
    #[allow(dead_code)]
    #[inline]
    pub fn type_argumentss<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, TypeArguments<'tree>>,
        >,
    > + 'a {
        self.0.children_by_field_name("type_arguments", c).map(|n| {
            <type_sitter_lib::ExtraOr<'tree, TypeArguments<'tree>> as TryFrom<_>>::try_from(n)
        })
    }
    #[doc = "Get the field `value` which has kind `expression+` ([Expression])"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]
    pub fn values<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, Expression<'tree>>,
        >,
    > + 'a {
        self.0.children_by_field_name("value", c).map(|n| {
            <type_sitter_lib::ExtraOr<'tree, Expression<'tree>> as TryFrom<_>>::try_from(n)
        })
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ExtendsClause<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "extends_clause" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ExtendsClause<'tree> {
    const KIND: &'static str = "extends_clause";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `extends_type_clause`\n\nThis node has these fields:\n- `type`: `{generic_type | nested_type_identifier | type_identifier}+` ([anon_unions::GenericType_NestedTypeIdentifier_TypeIdentifier])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ExtendsTypeClause<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ExtendsTypeClause<'tree> {
    #[doc = "Get the field `type` which has kind `{generic_type | nested_type_identifier | type_identifier}+` ([anon_unions::GenericType_NestedTypeIdentifier_TypeIdentifier])"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]
    pub fn types<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::GenericType_NestedTypeIdentifier_TypeIdentifier<'tree>,
            >,
        >,
    > + 'a {
        self.0.children_by_field_name("type", c).map(|n| {
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::GenericType_NestedTypeIdentifier_TypeIdentifier<'tree>,
            > as TryFrom<_>>::try_from(n)
        })
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ExtendsTypeClause<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "extends_type_clause" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ExtendsTypeClause<'tree> {
    const KIND: &'static str = "extends_type_clause";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `finally_clause`\n\nThis node has these fields:\n- `body`: `statement_block` ([StatementBlock])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct FinallyClause<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> FinallyClause<'tree> {
    #[doc = "Get the field `body` which has kind `statement_block` ([StatementBlock])"]
    #[allow(dead_code)]
    #[inline]
    pub fn body(&self) -> type_sitter_lib::NodeResult<'tree, StatementBlock<'tree>> {
        self . 0 . child_by_field_name ("body") . map (< StatementBlock < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for FinallyClause<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "finally_clause" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for FinallyClause<'tree> {
    const KIND: &'static str = "finally_clause";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `flow_maybe_type`\n\nThis node has a child: `_primary_type` ([PrimaryType])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct FlowMaybeType<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> FlowMaybeType<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(&self) -> type_sitter_lib::NodeResult<'tree, PrimaryType<'tree>> {
        self . 0 . named_child (0) . map (< PrimaryType < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for FlowMaybeType<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "flow_maybe_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for FlowMaybeType<'tree> {
    const KIND: &'static str = "flow_maybe_type";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `for_in_statement`\n\nThis node has these fields:\n- `body`: `statement` ([Statement])\n- `kind`: `{const | let | var}?` ([anon_unions::Const_Let_Var])\n- `left`: `{array_pattern | identifier | member_expression | non_null_expression | object_pattern | parenthesized_expression | subscript_expression | undefined}` ([anon_unions::ArrayPattern_Identifier_MemberExpression_NonNullExpression_ObjectPattern_ParenthesizedExpression_SubscriptExpression_Undefined])\n- `operator`: `{in | of}` ([anon_unions::In_Of])\n- `right`: `{expression | sequence_expression}` ([anon_unions::Expression_SequenceExpression])\n- `value`: `expression?` ([Expression])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ForInStatement<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ForInStatement<'tree> {
    #[doc = "Get the field `body` which has kind `statement` ([Statement])"]
    #[allow(dead_code)]
    #[inline]
    pub fn body(&self) -> type_sitter_lib::NodeResult<'tree, Statement<'tree>> {
        self . 0 . child_by_field_name ("body") . map (< Statement < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `kind` which has kind `{const | let | var}?` ([anon_unions::Const_Let_Var])"]
    #[allow(dead_code)]
    #[inline]
    pub fn kind(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, anon_unions::Const_Let_Var<'tree>>> {
        self.0
            .child_by_field_name("kind")
            .map(<anon_unions::Const_Let_Var<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `left` which has kind `{array_pattern | identifier | member_expression | non_null_expression | object_pattern | parenthesized_expression | subscript_expression | undefined}` ([anon_unions::ArrayPattern_Identifier_MemberExpression_NonNullExpression_ObjectPattern_ParenthesizedExpression_SubscriptExpression_Undefined])"]
    #[allow(dead_code)]
    #[inline]    pub fn left (& self) -> type_sitter_lib :: NodeResult < 'tree , anon_unions :: ArrayPattern_Identifier_MemberExpression_NonNullExpression_ObjectPattern_ParenthesizedExpression_SubscriptExpression_Undefined < 'tree > >{
        self . 0 . child_by_field_name ("left") . map (< anon_unions :: ArrayPattern_Identifier_MemberExpression_NonNullExpression_ObjectPattern_ParenthesizedExpression_SubscriptExpression_Undefined < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `operator` which has kind `{in | of}` ([anon_unions::In_Of])"]
    #[allow(dead_code)]
    #[inline]
    pub fn operator(&self) -> type_sitter_lib::NodeResult<'tree, anon_unions::In_Of<'tree>> {
        self . 0 . child_by_field_name ("operator") . map (< anon_unions :: In_Of < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `right` which has kind `{expression | sequence_expression}` ([anon_unions::Expression_SequenceExpression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn right(
        &self,
    ) -> type_sitter_lib::NodeResult<'tree, anon_unions::Expression_SequenceExpression<'tree>> {
        self . 0 . child_by_field_name ("right") . map (< anon_unions :: Expression_SequenceExpression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `value` which has kind `expression?` ([Expression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn value(&self) -> Option<type_sitter_lib::NodeResult<'tree, Expression<'tree>>> {
        self.0
            .child_by_field_name("value")
            .map(<Expression<'tree> as TryFrom<_>>::try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ForInStatement<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "for_in_statement" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ForInStatement<'tree> {
    const KIND: &'static str = "for_in_statement";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `for_statement`\n\nThis node has these fields:\n- `body`: `statement` ([Statement])\n- `condition`: `{empty_statement | expression_statement}` ([anon_unions::EmptyStatement_ExpressionStatement])\n- `increment`: `{expression | sequence_expression}?` ([anon_unions::Expression_SequenceExpression])\n- `initializer`: `{empty_statement | expression_statement | lexical_declaration | variable_declaration}` ([anon_unions::EmptyStatement_ExpressionStatement_LexicalDeclaration_VariableDeclaration])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ForStatement<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ForStatement<'tree> {
    #[doc = "Get the field `body` which has kind `statement` ([Statement])"]
    #[allow(dead_code)]
    #[inline]
    pub fn body(&self) -> type_sitter_lib::NodeResult<'tree, Statement<'tree>> {
        self . 0 . child_by_field_name ("body") . map (< Statement < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `condition` which has kind `{empty_statement | expression_statement}` ([anon_unions::EmptyStatement_ExpressionStatement])"]
    #[allow(dead_code)]
    #[inline]
    pub fn condition(
        &self,
    ) -> type_sitter_lib::NodeResult<'tree, anon_unions::EmptyStatement_ExpressionStatement<'tree>>
    {
        self . 0 . child_by_field_name ("condition") . map (< anon_unions :: EmptyStatement_ExpressionStatement < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `increment` which has kind `{expression | sequence_expression}?` ([anon_unions::Expression_SequenceExpression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn increment(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, anon_unions::Expression_SequenceExpression<'tree>>>
    {
        self.0
            .child_by_field_name("increment")
            .map(<anon_unions::Expression_SequenceExpression<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `initializer` which has kind `{empty_statement | expression_statement | lexical_declaration | variable_declaration}` ([anon_unions::EmptyStatement_ExpressionStatement_LexicalDeclaration_VariableDeclaration])"]
    #[allow(dead_code)]
    #[inline]
    pub fn initializer(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::EmptyStatement_ExpressionStatement_LexicalDeclaration_VariableDeclaration<
            'tree,
        >,
    > {
        self . 0 . child_by_field_name ("initializer") . map (< anon_unions :: EmptyStatement_ExpressionStatement_LexicalDeclaration_VariableDeclaration < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ForStatement<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "for_statement" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ForStatement<'tree> {
    const KIND: &'static str = "for_statement";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `formal_parameters`\n\nThis node has children: `{optional_parameter | required_parameter}*`:\n- [OptionalParameter]\n- [RequiredParameter]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct FormalParameters<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> FormalParameters<'tree> {
    #[doc = "Get the node's named children"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::OptionalParameter_RequiredParameter<'tree>,
            >,
        >,
    > + 'a {
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: OptionalParameter_RequiredParameter < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::OptionalParameter_RequiredParameter<'tree>,
            >,
        >,
    > {
        self.0.named_child(i).map(
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::OptionalParameter_RequiredParameter<'tree>,
            > as TryFrom<_>>::try_from,
        )
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for FormalParameters<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "formal_parameters" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for FormalParameters<'tree> {
    const KIND: &'static str = "formal_parameters";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `function`\n\nThis node has these fields:\n- `body`: `statement_block` ([StatementBlock])\n- `name`: `identifier?` ([Identifier])\n- `nominal_return_type`: `nominal_type_annotation?` ([NominalTypeAnnotation])\n- `parameters`: `formal_parameters` ([FormalParameters])\n- `return_type`: `{asserts | type_annotation | type_predicate_annotation}?` ([anon_unions::Asserts_TypeAnnotation_TypePredicateAnnotation])\n- `type_parameters`: `type_parameters?` ([TypeParameters])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct Function<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> Function<'tree> {
    #[doc = "Get the field `body` which has kind `statement_block` ([StatementBlock])"]
    #[allow(dead_code)]
    #[inline]
    pub fn body(&self) -> type_sitter_lib::NodeResult<'tree, StatementBlock<'tree>> {
        self . 0 . child_by_field_name ("body") . map (< StatementBlock < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `name` which has kind `identifier?` ([Identifier])"]
    #[allow(dead_code)]
    #[inline]
    pub fn name(&self) -> Option<type_sitter_lib::NodeResult<'tree, Identifier<'tree>>> {
        self.0
            .child_by_field_name("name")
            .map(<Identifier<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `nominal_return_type` which has kind `nominal_type_annotation?` ([NominalTypeAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn nominal_return_type(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, NominalTypeAnnotation<'tree>>> {
        self.0
            .child_by_field_name("nominal_return_type")
            .map(<NominalTypeAnnotation<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `parameters` which has kind `formal_parameters` ([FormalParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn parameters(&self) -> type_sitter_lib::NodeResult<'tree, FormalParameters<'tree>> {
        self . 0 . child_by_field_name ("parameters") . map (< FormalParameters < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `return_type` which has kind `{asserts | type_annotation | type_predicate_annotation}?` ([anon_unions::Asserts_TypeAnnotation_TypePredicateAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn return_type(
        &self,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            anon_unions::Asserts_TypeAnnotation_TypePredicateAnnotation<'tree>,
        >,
    > {
        self . 0 . child_by_field_name ("return_type") . map (< anon_unions :: Asserts_TypeAnnotation_TypePredicateAnnotation < 'tree > as TryFrom < _ >> :: try_from)
    }
    #[doc = "Get the field `type_parameters` which has kind `type_parameters?` ([TypeParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn type_parameters(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, TypeParameters<'tree>>> {
        self.0
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as TryFrom<_>>::try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Function<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "function" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for Function<'tree> {
    const KIND: &'static str = "function";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `function_declaration`\n\nThis node has these fields:\n- `body`: `statement_block` ([StatementBlock])\n- `name`: `identifier` ([Identifier])\n- `nominal_return_type`: `nominal_type_annotation?` ([NominalTypeAnnotation])\n- `parameters`: `formal_parameters` ([FormalParameters])\n- `return_type`: `{asserts | type_annotation | type_predicate_annotation}?` ([anon_unions::Asserts_TypeAnnotation_TypePredicateAnnotation])\n- `type_parameters`: `type_parameters?` ([TypeParameters])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct FunctionDeclaration<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> FunctionDeclaration<'tree> {
    #[doc = "Get the field `body` which has kind `statement_block` ([StatementBlock])"]
    #[allow(dead_code)]
    #[inline]
    pub fn body(&self) -> type_sitter_lib::NodeResult<'tree, StatementBlock<'tree>> {
        self . 0 . child_by_field_name ("body") . map (< StatementBlock < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `name` which has kind `identifier` ([Identifier])"]
    #[allow(dead_code)]
    #[inline]
    pub fn name(&self) -> type_sitter_lib::NodeResult<'tree, Identifier<'tree>> {
        self . 0 . child_by_field_name ("name") . map (< Identifier < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `nominal_return_type` which has kind `nominal_type_annotation?` ([NominalTypeAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn nominal_return_type(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, NominalTypeAnnotation<'tree>>> {
        self.0
            .child_by_field_name("nominal_return_type")
            .map(<NominalTypeAnnotation<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `parameters` which has kind `formal_parameters` ([FormalParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn parameters(&self) -> type_sitter_lib::NodeResult<'tree, FormalParameters<'tree>> {
        self . 0 . child_by_field_name ("parameters") . map (< FormalParameters < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `return_type` which has kind `{asserts | type_annotation | type_predicate_annotation}?` ([anon_unions::Asserts_TypeAnnotation_TypePredicateAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn return_type(
        &self,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            anon_unions::Asserts_TypeAnnotation_TypePredicateAnnotation<'tree>,
        >,
    > {
        self . 0 . child_by_field_name ("return_type") . map (< anon_unions :: Asserts_TypeAnnotation_TypePredicateAnnotation < 'tree > as TryFrom < _ >> :: try_from)
    }
    #[doc = "Get the field `type_parameters` which has kind `type_parameters?` ([TypeParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn type_parameters(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, TypeParameters<'tree>>> {
        self.0
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as TryFrom<_>>::try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for FunctionDeclaration<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "function_declaration" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for FunctionDeclaration<'tree> {
    const KIND: &'static str = "function_declaration";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `function_nominal_type`\n\nThis node has these fields:\n- `nominal_type_parameters`: `nominal_type_parameters?` ([NominalTypeParameters])\n- `parameters`: `nominal_formal_parameters` ([NominalFormalParameters])\n- `return_type`: `{_primary_nominal_type | function_nominal_type | nullable_nominal_type}` ([anon_unions::PrimaryNominalType_FunctionNominalType_NullableNominalType])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct FunctionNominalType<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> FunctionNominalType<'tree> {
    #[doc = "Get the field `nominal_type_parameters` which has kind `nominal_type_parameters?` ([NominalTypeParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn nominal_type_parameters(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, NominalTypeParameters<'tree>>> {
        self.0
            .child_by_field_name("nominal_type_parameters")
            .map(<NominalTypeParameters<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `parameters` which has kind `nominal_formal_parameters` ([NominalFormalParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn parameters(&self) -> type_sitter_lib::NodeResult<'tree, NominalFormalParameters<'tree>> {
        self . 0 . child_by_field_name ("parameters") . map (< NominalFormalParameters < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `return_type` which has kind `{_primary_nominal_type | function_nominal_type | nullable_nominal_type}` ([anon_unions::PrimaryNominalType_FunctionNominalType_NullableNominalType])"]
    #[allow(dead_code)]
    #[inline]
    pub fn return_type(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::PrimaryNominalType_FunctionNominalType_NullableNominalType<'tree>,
    > {
        self . 0 . child_by_field_name ("return_type") . map (< anon_unions :: PrimaryNominalType_FunctionNominalType_NullableNominalType < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for FunctionNominalType<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "function_nominal_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for FunctionNominalType<'tree> {
    const KIND: &'static str = "function_nominal_type";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `function_signature`\n\nThis node has these fields:\n- `name`: `identifier` ([Identifier])\n- `nominal_return_type`: `nominal_type_annotation?` ([NominalTypeAnnotation])\n- `parameters`: `formal_parameters` ([FormalParameters])\n- `return_type`: `{asserts | type_annotation | type_predicate_annotation}?` ([anon_unions::Asserts_TypeAnnotation_TypePredicateAnnotation])\n- `type_parameters`: `type_parameters?` ([TypeParameters])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct FunctionSignature<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> FunctionSignature<'tree> {
    #[doc = "Get the field `name` which has kind `identifier` ([Identifier])"]
    #[allow(dead_code)]
    #[inline]
    pub fn name(&self) -> type_sitter_lib::NodeResult<'tree, Identifier<'tree>> {
        self . 0 . child_by_field_name ("name") . map (< Identifier < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `nominal_return_type` which has kind `nominal_type_annotation?` ([NominalTypeAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn nominal_return_type(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, NominalTypeAnnotation<'tree>>> {
        self.0
            .child_by_field_name("nominal_return_type")
            .map(<NominalTypeAnnotation<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `parameters` which has kind `formal_parameters` ([FormalParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn parameters(&self) -> type_sitter_lib::NodeResult<'tree, FormalParameters<'tree>> {
        self . 0 . child_by_field_name ("parameters") . map (< FormalParameters < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `return_type` which has kind `{asserts | type_annotation | type_predicate_annotation}?` ([anon_unions::Asserts_TypeAnnotation_TypePredicateAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn return_type(
        &self,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            anon_unions::Asserts_TypeAnnotation_TypePredicateAnnotation<'tree>,
        >,
    > {
        self . 0 . child_by_field_name ("return_type") . map (< anon_unions :: Asserts_TypeAnnotation_TypePredicateAnnotation < 'tree > as TryFrom < _ >> :: try_from)
    }
    #[doc = "Get the field `type_parameters` which has kind `type_parameters?` ([TypeParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn type_parameters(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, TypeParameters<'tree>>> {
        self.0
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as TryFrom<_>>::try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for FunctionSignature<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "function_signature" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for FunctionSignature<'tree> {
    const KIND: &'static str = "function_signature";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `function_type`\n\nThis node has these fields:\n- `parameters`: `formal_parameters` ([FormalParameters])\n- `return_type`: `{_primary_type | constructor_type | function_type | infer_type | readonly_type | type_predicate}` ([anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType_TypePredicate])\n- `type_parameters`: `type_parameters?` ([TypeParameters])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct FunctionType<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> FunctionType<'tree> {
    #[doc = "Get the field `parameters` which has kind `formal_parameters` ([FormalParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn parameters(&self) -> type_sitter_lib::NodeResult<'tree, FormalParameters<'tree>> {
        self . 0 . child_by_field_name ("parameters") . map (< FormalParameters < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `return_type` which has kind `{_primary_type | constructor_type | function_type | infer_type | readonly_type | type_predicate}` ([anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType_TypePredicate])"]
    #[allow(dead_code)]
    #[inline]
    pub fn return_type(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType_TypePredicate<
            'tree,
        >,
    > {
        self . 0 . child_by_field_name ("return_type") . map (< anon_unions :: PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType_TypePredicate < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `type_parameters` which has kind `type_parameters?` ([TypeParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn type_parameters(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, TypeParameters<'tree>>> {
        self.0
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as TryFrom<_>>::try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for FunctionType<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "function_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for FunctionType<'tree> {
    const KIND: &'static str = "function_type";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `generator_function`\n\nThis node has these fields:\n- `body`: `statement_block` ([StatementBlock])\n- `name`: `identifier?` ([Identifier])\n- `nominal_return_type`: `nominal_type_annotation?` ([NominalTypeAnnotation])\n- `parameters`: `formal_parameters` ([FormalParameters])\n- `return_type`: `{asserts | type_annotation | type_predicate_annotation}?` ([anon_unions::Asserts_TypeAnnotation_TypePredicateAnnotation])\n- `type_parameters`: `type_parameters?` ([TypeParameters])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct GeneratorFunction<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> GeneratorFunction<'tree> {
    #[doc = "Get the field `body` which has kind `statement_block` ([StatementBlock])"]
    #[allow(dead_code)]
    #[inline]
    pub fn body(&self) -> type_sitter_lib::NodeResult<'tree, StatementBlock<'tree>> {
        self . 0 . child_by_field_name ("body") . map (< StatementBlock < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `name` which has kind `identifier?` ([Identifier])"]
    #[allow(dead_code)]
    #[inline]
    pub fn name(&self) -> Option<type_sitter_lib::NodeResult<'tree, Identifier<'tree>>> {
        self.0
            .child_by_field_name("name")
            .map(<Identifier<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `nominal_return_type` which has kind `nominal_type_annotation?` ([NominalTypeAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn nominal_return_type(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, NominalTypeAnnotation<'tree>>> {
        self.0
            .child_by_field_name("nominal_return_type")
            .map(<NominalTypeAnnotation<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `parameters` which has kind `formal_parameters` ([FormalParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn parameters(&self) -> type_sitter_lib::NodeResult<'tree, FormalParameters<'tree>> {
        self . 0 . child_by_field_name ("parameters") . map (< FormalParameters < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `return_type` which has kind `{asserts | type_annotation | type_predicate_annotation}?` ([anon_unions::Asserts_TypeAnnotation_TypePredicateAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn return_type(
        &self,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            anon_unions::Asserts_TypeAnnotation_TypePredicateAnnotation<'tree>,
        >,
    > {
        self . 0 . child_by_field_name ("return_type") . map (< anon_unions :: Asserts_TypeAnnotation_TypePredicateAnnotation < 'tree > as TryFrom < _ >> :: try_from)
    }
    #[doc = "Get the field `type_parameters` which has kind `type_parameters?` ([TypeParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn type_parameters(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, TypeParameters<'tree>>> {
        self.0
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as TryFrom<_>>::try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for GeneratorFunction<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "generator_function" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for GeneratorFunction<'tree> {
    const KIND: &'static str = "generator_function";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `generator_function_declaration`\n\nThis node has these fields:\n- `body`: `statement_block` ([StatementBlock])\n- `name`: `identifier` ([Identifier])\n- `nominal_return_type`: `nominal_type_annotation?` ([NominalTypeAnnotation])\n- `parameters`: `formal_parameters` ([FormalParameters])\n- `return_type`: `{asserts | type_annotation | type_predicate_annotation}?` ([anon_unions::Asserts_TypeAnnotation_TypePredicateAnnotation])\n- `type_parameters`: `type_parameters?` ([TypeParameters])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct GeneratorFunctionDeclaration<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> GeneratorFunctionDeclaration<'tree> {
    #[doc = "Get the field `body` which has kind `statement_block` ([StatementBlock])"]
    #[allow(dead_code)]
    #[inline]
    pub fn body(&self) -> type_sitter_lib::NodeResult<'tree, StatementBlock<'tree>> {
        self . 0 . child_by_field_name ("body") . map (< StatementBlock < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `name` which has kind `identifier` ([Identifier])"]
    #[allow(dead_code)]
    #[inline]
    pub fn name(&self) -> type_sitter_lib::NodeResult<'tree, Identifier<'tree>> {
        self . 0 . child_by_field_name ("name") . map (< Identifier < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `nominal_return_type` which has kind `nominal_type_annotation?` ([NominalTypeAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn nominal_return_type(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, NominalTypeAnnotation<'tree>>> {
        self.0
            .child_by_field_name("nominal_return_type")
            .map(<NominalTypeAnnotation<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `parameters` which has kind `formal_parameters` ([FormalParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn parameters(&self) -> type_sitter_lib::NodeResult<'tree, FormalParameters<'tree>> {
        self . 0 . child_by_field_name ("parameters") . map (< FormalParameters < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `return_type` which has kind `{asserts | type_annotation | type_predicate_annotation}?` ([anon_unions::Asserts_TypeAnnotation_TypePredicateAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn return_type(
        &self,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            anon_unions::Asserts_TypeAnnotation_TypePredicateAnnotation<'tree>,
        >,
    > {
        self . 0 . child_by_field_name ("return_type") . map (< anon_unions :: Asserts_TypeAnnotation_TypePredicateAnnotation < 'tree > as TryFrom < _ >> :: try_from)
    }
    #[doc = "Get the field `type_parameters` which has kind `type_parameters?` ([TypeParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn type_parameters(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, TypeParameters<'tree>>> {
        self.0
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as TryFrom<_>>::try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for GeneratorFunctionDeclaration<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "generator_function_declaration" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for GeneratorFunctionDeclaration<'tree> {
    const KIND: &'static str = "generator_function_declaration";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `generic_nominal_type`\n\nThis node has these fields:\n- `name`: `nominal_type_identifier` ([NominalTypeIdentifier])\n- `nominal_type_arguments`: `nominal_type_arguments` ([NominalTypeArguments])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct GenericNominalType<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> GenericNominalType<'tree> {
    #[doc = "Get the field `name` which has kind `nominal_type_identifier` ([NominalTypeIdentifier])"]
    #[allow(dead_code)]
    #[inline]
    pub fn name(&self) -> type_sitter_lib::NodeResult<'tree, NominalTypeIdentifier<'tree>> {
        self . 0 . child_by_field_name ("name") . map (< NominalTypeIdentifier < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `nominal_type_arguments` which has kind `nominal_type_arguments` ([NominalTypeArguments])"]
    #[allow(dead_code)]
    #[inline]
    pub fn nominal_type_arguments(
        &self,
    ) -> type_sitter_lib::NodeResult<'tree, NominalTypeArguments<'tree>> {
        self . 0 . child_by_field_name ("nominal_type_arguments") . map (< NominalTypeArguments < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for GenericNominalType<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "generic_nominal_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for GenericNominalType<'tree> {
    const KIND: &'static str = "generic_nominal_type";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `generic_type`\n\nThis node has these fields:\n- `name`: `{nested_type_identifier | type_identifier}` ([anon_unions::NestedTypeIdentifier_TypeIdentifier])\n- `type_arguments`: `type_arguments` ([TypeArguments])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct GenericType<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> GenericType<'tree> {
    #[doc = "Get the field `name` which has kind `{nested_type_identifier | type_identifier}` ([anon_unions::NestedTypeIdentifier_TypeIdentifier])"]
    #[allow(dead_code)]
    #[inline]
    pub fn name(
        &self,
    ) -> type_sitter_lib::NodeResult<'tree, anon_unions::NestedTypeIdentifier_TypeIdentifier<'tree>>
    {
        self . 0 . child_by_field_name ("name") . map (< anon_unions :: NestedTypeIdentifier_TypeIdentifier < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `type_arguments` which has kind `type_arguments` ([TypeArguments])"]
    #[allow(dead_code)]
    #[inline]
    pub fn type_arguments(&self) -> type_sitter_lib::NodeResult<'tree, TypeArguments<'tree>> {
        self . 0 . child_by_field_name ("type_arguments") . map (< TypeArguments < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for GenericType<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "generic_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for GenericType<'tree> {
    const KIND: &'static str = "generic_type";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `glimmer_closing_tag`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct GlimmerClosingTag<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> GlimmerClosingTag<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for GlimmerClosingTag<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "glimmer_closing_tag" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for GlimmerClosingTag<'tree> {
    const KIND: &'static str = "glimmer_closing_tag";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `glimmer_opening_tag`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct GlimmerOpeningTag<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> GlimmerOpeningTag<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for GlimmerOpeningTag<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "glimmer_opening_tag" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for GlimmerOpeningTag<'tree> {
    const KIND: &'static str = "glimmer_opening_tag";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `glimmer_template`\n\nThis node has these fields:\n- `close_tag`: `glimmer_closing_tag` ([GlimmerClosingTag])\n- `open_tag`: `glimmer_opening_tag` ([GlimmerOpeningTag])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct GlimmerTemplate<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> GlimmerTemplate<'tree> {
    #[doc = "Get the field `close_tag` which has kind `glimmer_closing_tag` ([GlimmerClosingTag])"]
    #[allow(dead_code)]
    #[inline]
    pub fn close_tag(&self) -> type_sitter_lib::NodeResult<'tree, GlimmerClosingTag<'tree>> {
        self . 0 . child_by_field_name ("close_tag") . map (< GlimmerClosingTag < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `open_tag` which has kind `glimmer_opening_tag` ([GlimmerOpeningTag])"]
    #[allow(dead_code)]
    #[inline]
    pub fn open_tag(&self) -> type_sitter_lib::NodeResult<'tree, GlimmerOpeningTag<'tree>> {
        self . 0 . child_by_field_name ("open_tag") . map (< GlimmerOpeningTag < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for GlimmerTemplate<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "glimmer_template" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for GlimmerTemplate<'tree> {
    const KIND: &'static str = "glimmer_template";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `identifier`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct Identifier<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> Identifier<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Identifier<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "identifier" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for Identifier<'tree> {
    const KIND: &'static str = "identifier";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `if_statement`\n\nThis node has these fields:\n- `alternative`: `else_clause?` ([ElseClause])\n- `condition`: `parenthesized_expression` ([ParenthesizedExpression])\n- `consequence`: `statement` ([Statement])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct IfStatement<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> IfStatement<'tree> {
    #[doc = "Get the field `alternative` which has kind `else_clause?` ([ElseClause])"]
    #[allow(dead_code)]
    #[inline]
    pub fn alternative(&self) -> Option<type_sitter_lib::NodeResult<'tree, ElseClause<'tree>>> {
        self.0
            .child_by_field_name("alternative")
            .map(<ElseClause<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `condition` which has kind `parenthesized_expression` ([ParenthesizedExpression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn condition(&self) -> type_sitter_lib::NodeResult<'tree, ParenthesizedExpression<'tree>> {
        self . 0 . child_by_field_name ("condition") . map (< ParenthesizedExpression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `consequence` which has kind `statement` ([Statement])"]
    #[allow(dead_code)]
    #[inline]
    pub fn consequence(&self) -> type_sitter_lib::NodeResult<'tree, Statement<'tree>> {
        self . 0 . child_by_field_name ("consequence") . map (< Statement < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for IfStatement<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "if_statement" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for IfStatement<'tree> {
    const KIND: &'static str = "if_statement";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `implements_clause`\n\nThis node has children: `{_primary_type | constructor_type | function_type | infer_type | readonly_type}+`:\n- [PrimaryType]\n- [ConstructorType]\n- [FunctionType]\n- [InferType]\n- [ReadonlyType]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ImplementsClause<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ImplementsClause<'tree> {
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
            >,
        >,
    > + 'a {
        self.0.named_children(c).map(|n| {
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
            > as TryFrom<_>>::try_from(n)
        })
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
            >,
        >,
    > {
        self.0.named_child(i).map(
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
            > as TryFrom<_>>::try_from,
        )
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ImplementsClause<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "implements_clause" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ImplementsClause<'tree> {
    const KIND: &'static str = "implements_clause";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `import`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct Import<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> Import<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Import<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "import" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for Import<'tree> {
    const KIND: &'static str = "import";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `import_alias`\n\nThis node has children: `{identifier | nested_identifier}+`:\n- [Identifier]\n- [NestedIdentifier]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ImportAlias<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ImportAlias<'tree> {
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, anon_unions::Identifier_NestedIdentifier<'tree>>,
        >,
    > + 'a {
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: Identifier_NestedIdentifier < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, anon_unions::Identifier_NestedIdentifier<'tree>>,
        >,
    > {
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: Identifier_NestedIdentifier < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ImportAlias<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "import_alias" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ImportAlias<'tree> {
    const KIND: &'static str = "import_alias";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `import_clause`\n\nThis node has children: `{identifier | named_imports | namespace_import}+`:\n- [Identifier]\n- [NamedImports]\n- [NamespaceImport]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ImportClause<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ImportClause<'tree> {
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::Identifier_NamedImports_NamespaceImport<'tree>,
            >,
        >,
    > + 'a {
        self.0.named_children(c).map(|n| {
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::Identifier_NamedImports_NamespaceImport<'tree>,
            > as TryFrom<_>>::try_from(n)
        })
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::Identifier_NamedImports_NamespaceImport<'tree>,
            >,
        >,
    > {
        self.0.named_child(i).map(
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::Identifier_NamedImports_NamespaceImport<'tree>,
            > as TryFrom<_>>::try_from,
        )
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ImportClause<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "import_clause" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ImportClause<'tree> {
    const KIND: &'static str = "import_clause";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `import_require_clause`\n\nThis node has these fields:\n- `source`: `string` ([String])\n\nAnd an additional child: `identifier` ([Identifier])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ImportRequireClause<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ImportRequireClause<'tree> {
    #[doc = "Get the field `source` which has kind `string` ([String])"]
    #[allow(dead_code)]
    #[inline]
    pub fn source(&self) -> type_sitter_lib::NodeResult<'tree, String<'tree>> {
        self . 0 . child_by_field_name ("source") . map (< String < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, anon_unions::Identifier_String<'tree>>,
        >,
    > + 'a {
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: Identifier_String < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, anon_unions::Identifier_String<'tree>>,
        >,
    > {
        self.0.named_child(i).map(
            <type_sitter_lib::ExtraOr<'tree, anon_unions::Identifier_String<'tree>> as TryFrom<
                _,
            >>::try_from,
        )
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ImportRequireClause<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "import_require_clause" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ImportRequireClause<'tree> {
    const KIND: &'static str = "import_require_clause";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `import_specifier`\n\nThis node has these fields:\n- `alias`: `identifier?` ([Identifier])\n- `name`: `{identifier | string}?` ([anon_unions::Identifier_String])\n\nAnd an additional (optional) child: `nominal_type_identifier?` ([NominalTypeIdentifier])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ImportSpecifier<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ImportSpecifier<'tree> {
    #[doc = "Get the field `alias` which has kind `identifier?` ([Identifier])"]
    #[allow(dead_code)]
    #[inline]
    pub fn alias(&self) -> Option<type_sitter_lib::NodeResult<'tree, Identifier<'tree>>> {
        self.0
            .child_by_field_name("alias")
            .map(<Identifier<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `name` which has kind `{identifier | string}?` ([anon_unions::Identifier_String])"]
    #[allow(dead_code)]
    #[inline]
    pub fn name(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, anon_unions::Identifier_String<'tree>>> {
        self.0
            .child_by_field_name("name")
            .map(<anon_unions::Identifier_String<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the node's named children"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::NominalTypeIdentifier_Identifier_String<'tree>,
            >,
        >,
    > + 'a {
        self.0.named_children(c).map(|n| {
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::NominalTypeIdentifier_Identifier_String<'tree>,
            > as TryFrom<_>>::try_from(n)
        })
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::NominalTypeIdentifier_Identifier_String<'tree>,
            >,
        >,
    > {
        self.0.named_child(i).map(
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::NominalTypeIdentifier_Identifier_String<'tree>,
            > as TryFrom<_>>::try_from,
        )
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ImportSpecifier<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "import_specifier" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ImportSpecifier<'tree> {
    const KIND: &'static str = "import_specifier";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `import_statement`\n\nThis node has these fields:\n- `source`: `string?` ([String])\n\nAnd an additional (optional) child: `{import_clause | import_require_clause}?`:\n- [ImportClause]\n- [ImportRequireClause]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ImportStatement<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ImportStatement<'tree> {
    #[doc = "Get the field `source` which has kind `string?` ([String])"]
    #[allow(dead_code)]
    #[inline]
    pub fn source(&self) -> Option<type_sitter_lib::NodeResult<'tree, String<'tree>>> {
        self.0
            .child_by_field_name("source")
            .map(<String<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the node's named children"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::ImportClause_ImportRequireClause_String<'tree>,
            >,
        >,
    > + 'a {
        self.0.named_children(c).map(|n| {
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::ImportClause_ImportRequireClause_String<'tree>,
            > as TryFrom<_>>::try_from(n)
        })
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::ImportClause_ImportRequireClause_String<'tree>,
            >,
        >,
    > {
        self.0.named_child(i).map(
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::ImportClause_ImportRequireClause_String<'tree>,
            > as TryFrom<_>>::try_from,
        )
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ImportStatement<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "import_statement" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ImportStatement<'tree> {
    const KIND: &'static str = "import_statement";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `index_signature`\n\nThis node has these fields:\n- `index_type`: `{_primary_type | constructor_type | function_type | infer_type | readonly_type}?` ([anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType])\n- `name`: `identifier?` ([Identifier])\n- `sign`: `-?` ([symbols::Sub])\n- `type`: `{omitting_type_annotation | opting_type_annotation | type_annotation}` ([anon_unions::OmittingTypeAnnotation_OptingTypeAnnotation_TypeAnnotation])\n\nAnd an additional (optional) child: `mapped_type_clause?` ([MappedTypeClause])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct IndexSignature<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> IndexSignature<'tree> {
    #[doc = "Get the field `index_type` which has kind `{_primary_type | constructor_type | function_type | infer_type | readonly_type}?` ([anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType])"]
    #[allow(dead_code)]
    #[inline]
    pub fn index_type(
        &self,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
        >,
    > {
        self . 0 . child_by_field_name ("index_type") . map (< anon_unions :: PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType < 'tree > as TryFrom < _ >> :: try_from)
    }
    #[doc = "Get the field `name` which has kind `identifier?` ([Identifier])"]
    #[allow(dead_code)]
    #[inline]
    pub fn name(&self) -> Option<type_sitter_lib::NodeResult<'tree, Identifier<'tree>>> {
        self.0
            .child_by_field_name("name")
            .map(<Identifier<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `sign` which has kind `-?` ([symbols::Sub])"]
    #[allow(dead_code)]
    #[inline]
    pub fn sign(&self) -> Option<type_sitter_lib::NodeResult<'tree, symbols::Sub<'tree>>> {
        self.0
            .child_by_field_name("sign")
            .map(<symbols::Sub<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `type` which has kind `{omitting_type_annotation | opting_type_annotation | type_annotation}` ([anon_unions::OmittingTypeAnnotation_OptingTypeAnnotation_TypeAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn r#type(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::OmittingTypeAnnotation_OptingTypeAnnotation_TypeAnnotation<'tree>,
    > {
        self . 0 . child_by_field_name ("type") . map (< anon_unions :: OmittingTypeAnnotation_OptingTypeAnnotation_TypeAnnotation < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]    pub fn children < 'a > (& self , c : & 'a mut yak_sitter :: TreeCursor < 'tree >) -> impl ExactSizeIterator < Item = type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: MappedTypeClause_PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType_Identifier_Sub_OmittingTypeAnnotation_OptingTypeAnnotation_TypeAnnotation < 'tree > > >> + 'a{
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: MappedTypeClause_PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType_Identifier_Sub_OmittingTypeAnnotation_OptingTypeAnnotation_TypeAnnotation < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]    pub fn child (& self , i : usize) -> Option < type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: MappedTypeClause_PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType_Identifier_Sub_OmittingTypeAnnotation_OptingTypeAnnotation_TypeAnnotation < 'tree > > >>{
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: MappedTypeClause_PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType_Identifier_Sub_OmittingTypeAnnotation_OptingTypeAnnotation_TypeAnnotation < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for IndexSignature<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "index_signature" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for IndexSignature<'tree> {
    const KIND: &'static str = "index_signature";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `index_type_query`\n\nThis node has a child: `_primary_type` ([PrimaryType])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct IndexTypeQuery<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> IndexTypeQuery<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(&self) -> type_sitter_lib::NodeResult<'tree, PrimaryType<'tree>> {
        self . 0 . named_child (0) . map (< PrimaryType < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for IndexTypeQuery<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "index_type_query" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for IndexTypeQuery<'tree> {
    const KIND: &'static str = "index_type_query";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `infer_type`\n\nThis node has a child: `type_identifier` ([TypeIdentifier])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct InferType<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> InferType<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(&self) -> type_sitter_lib::NodeResult<'tree, TypeIdentifier<'tree>> {
        self . 0 . named_child (0) . map (< TypeIdentifier < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for InferType<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "infer_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for InferType<'tree> {
    const KIND: &'static str = "infer_type";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `interface_declaration`\n\nThis node has these fields:\n- `body`: `object_type` ([ObjectType])\n- `name`: `type_identifier` ([TypeIdentifier])\n- `type_parameters`: `type_parameters?` ([TypeParameters])\n\nAnd an additional (optional) child: `extends_type_clause?` ([ExtendsTypeClause])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct InterfaceDeclaration<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> InterfaceDeclaration<'tree> {
    #[doc = "Get the field `body` which has kind `object_type` ([ObjectType])"]
    #[allow(dead_code)]
    #[inline]
    pub fn body(&self) -> type_sitter_lib::NodeResult<'tree, ObjectType<'tree>> {
        self . 0 . child_by_field_name ("body") . map (< ObjectType < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `name` which has kind `type_identifier` ([TypeIdentifier])"]
    #[allow(dead_code)]
    #[inline]
    pub fn name(&self) -> type_sitter_lib::NodeResult<'tree, TypeIdentifier<'tree>> {
        self . 0 . child_by_field_name ("name") . map (< TypeIdentifier < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `type_parameters` which has kind `type_parameters?` ([TypeParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn type_parameters(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, TypeParameters<'tree>>> {
        self.0
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::ExtendsTypeClause_ObjectType_TypeIdentifier_TypeParameters<'tree>,
            >,
        >,
    > + 'a {
        self.0.named_children(c).map(|n| {
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::ExtendsTypeClause_ObjectType_TypeIdentifier_TypeParameters<'tree>,
            > as TryFrom<_>>::try_from(n)
        })
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::ExtendsTypeClause_ObjectType_TypeIdentifier_TypeParameters<'tree>,
            >,
        >,
    > {
        self.0.named_child(i).map(
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::ExtendsTypeClause_ObjectType_TypeIdentifier_TypeParameters<'tree>,
            > as TryFrom<_>>::try_from,
        )
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for InterfaceDeclaration<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "interface_declaration" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for InterfaceDeclaration<'tree> {
    const KIND: &'static str = "interface_declaration";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `internal_module`\n\nThis node has these fields:\n- `body`: `statement_block?` ([StatementBlock])\n- `name`: `{identifier | nested_identifier | string}` ([anon_unions::Identifier_NestedIdentifier_String])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct InternalModule<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> InternalModule<'tree> {
    #[doc = "Get the field `body` which has kind `statement_block?` ([StatementBlock])"]
    #[allow(dead_code)]
    #[inline]
    pub fn body(&self) -> Option<type_sitter_lib::NodeResult<'tree, StatementBlock<'tree>>> {
        self.0
            .child_by_field_name("body")
            .map(<StatementBlock<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `name` which has kind `{identifier | nested_identifier | string}` ([anon_unions::Identifier_NestedIdentifier_String])"]
    #[allow(dead_code)]
    #[inline]
    pub fn name(
        &self,
    ) -> type_sitter_lib::NodeResult<'tree, anon_unions::Identifier_NestedIdentifier_String<'tree>>
    {
        self . 0 . child_by_field_name ("name") . map (< anon_unions :: Identifier_NestedIdentifier_String < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for InternalModule<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "internal_module" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for InternalModule<'tree> {
    const KIND: &'static str = "internal_module";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `intersection_type`\n\nThis node has children: `{_primary_type | constructor_type | function_type | infer_type | readonly_type}+`:\n- [PrimaryType]\n- [ConstructorType]\n- [FunctionType]\n- [InferType]\n- [ReadonlyType]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct IntersectionType<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> IntersectionType<'tree> {
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
            >,
        >,
    > + 'a {
        self.0.named_children(c).map(|n| {
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
            > as TryFrom<_>>::try_from(n)
        })
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
            >,
        >,
    > {
        self.0.named_child(i).map(
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
            > as TryFrom<_>>::try_from,
        )
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for IntersectionType<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "intersection_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for IntersectionType<'tree> {
    const KIND: &'static str = "intersection_type";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `jsx_attribute`\n\nThis node has children: `{jsx_element | jsx_expression | jsx_fragment | jsx_namespace_name | jsx_self_closing_element | property_identifier | string}+`:\n- [JsxElement]\n- [JsxExpression]\n- [JsxFragment]\n- [JsxNamespaceName]\n- [JsxSelfClosingElement]\n- [PropertyIdentifier]\n- [String]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct JsxAttribute<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> JsxAttribute<'tree> {
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]    pub fn children < 'a > (& self , c : & 'a mut yak_sitter :: TreeCursor < 'tree >) -> impl ExactSizeIterator < Item = type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: JsxElement_JsxExpression_JsxFragment_JsxNamespaceName_JsxSelfClosingElement_PropertyIdentifier_String < 'tree > > >> + 'a{
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: JsxElement_JsxExpression_JsxFragment_JsxNamespaceName_JsxSelfClosingElement_PropertyIdentifier_String < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]    pub fn child (& self , i : usize) -> Option < type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: JsxElement_JsxExpression_JsxFragment_JsxNamespaceName_JsxSelfClosingElement_PropertyIdentifier_String < 'tree > > >>{
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: JsxElement_JsxExpression_JsxFragment_JsxNamespaceName_JsxSelfClosingElement_PropertyIdentifier_String < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for JsxAttribute<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "jsx_attribute" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for JsxAttribute<'tree> {
    const KIND: &'static str = "jsx_attribute";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `jsx_closing_element`\n\nThis node has these fields:\n- `name`: `{identifier | jsx_namespace_name | nested_identifier}` ([anon_unions::Identifier_JsxNamespaceName_NestedIdentifier])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct JsxClosingElement<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> JsxClosingElement<'tree> {
    #[doc = "Get the field `name` which has kind `{identifier | jsx_namespace_name | nested_identifier}` ([anon_unions::Identifier_JsxNamespaceName_NestedIdentifier])"]
    #[allow(dead_code)]
    #[inline]
    pub fn name(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::Identifier_JsxNamespaceName_NestedIdentifier<'tree>,
    > {
        self . 0 . child_by_field_name ("name") . map (< anon_unions :: Identifier_JsxNamespaceName_NestedIdentifier < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for JsxClosingElement<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "jsx_closing_element" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for JsxClosingElement<'tree> {
    const KIND: &'static str = "jsx_closing_element";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `jsx_element`\n\nThis node has these fields:\n- `close_tag`: `jsx_closing_element` ([JsxClosingElement])\n- `open_tag`: `jsx_opening_element` ([JsxOpeningElement])\n\nAnd additional children: `{jsx_element | jsx_expression | jsx_fragment | jsx_self_closing_element | jsx_text}*`:\n- [JsxElement]\n- [JsxExpression]\n- [JsxFragment]\n- [JsxSelfClosingElement]\n- [JsxText]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct JsxElement<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> JsxElement<'tree> {
    #[doc = "Get the field `close_tag` which has kind `jsx_closing_element` ([JsxClosingElement])"]
    #[allow(dead_code)]
    #[inline]
    pub fn close_tag(&self) -> type_sitter_lib::NodeResult<'tree, JsxClosingElement<'tree>> {
        self . 0 . child_by_field_name ("close_tag") . map (< JsxClosingElement < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `open_tag` which has kind `jsx_opening_element` ([JsxOpeningElement])"]
    #[allow(dead_code)]
    #[inline]
    pub fn open_tag(&self) -> type_sitter_lib::NodeResult<'tree, JsxOpeningElement<'tree>> {
        self . 0 . child_by_field_name ("open_tag") . map (< JsxOpeningElement < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]    pub fn children < 'a > (& self , c : & 'a mut yak_sitter :: TreeCursor < 'tree >) -> impl ExactSizeIterator < Item = type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: JsxElement_JsxExpression_JsxFragment_JsxSelfClosingElement_JsxText_JsxClosingElement_JsxOpeningElement < 'tree > > >> + 'a{
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: JsxElement_JsxExpression_JsxFragment_JsxSelfClosingElement_JsxText_JsxClosingElement_JsxOpeningElement < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]    pub fn child (& self , i : usize) -> Option < type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: JsxElement_JsxExpression_JsxFragment_JsxSelfClosingElement_JsxText_JsxClosingElement_JsxOpeningElement < 'tree > > >>{
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: JsxElement_JsxExpression_JsxFragment_JsxSelfClosingElement_JsxText_JsxClosingElement_JsxOpeningElement < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for JsxElement<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "jsx_element" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for JsxElement<'tree> {
    const KIND: &'static str = "jsx_element";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `jsx_expression`\n\nThis node has an (optional) child: `{expression | sequence_expression | spread_element}?`:\n- [Expression]\n- [SequenceExpression]\n- [SpreadElement]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct JsxExpression<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> JsxExpression<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            anon_unions::Expression_SequenceExpression_SpreadElement<'tree>,
        >,
    > {
        self . 0 . named_child (0) . map (< anon_unions :: Expression_SequenceExpression_SpreadElement < 'tree > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for JsxExpression<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "jsx_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for JsxExpression<'tree> {
    const KIND: &'static str = "jsx_expression";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `jsx_fragment`\n\nThis node has children: `{jsx_element | jsx_expression | jsx_fragment | jsx_self_closing_element | jsx_text}*`:\n- [JsxElement]\n- [JsxExpression]\n- [JsxFragment]\n- [JsxSelfClosingElement]\n- [JsxText]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct JsxFragment<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> JsxFragment<'tree> {
    #[doc = "Get the node's named children"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::JsxElement_JsxExpression_JsxFragment_JsxSelfClosingElement_JsxText<
                    'tree,
                >,
            >,
        >,
    > + 'a {
        self.0.named_children(c).map(|n| {
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::JsxElement_JsxExpression_JsxFragment_JsxSelfClosingElement_JsxText<
                    'tree,
                >,
            > as TryFrom<_>>::try_from(n)
        })
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::JsxElement_JsxExpression_JsxFragment_JsxSelfClosingElement_JsxText<
                    'tree,
                >,
            >,
        >,
    > {
        self.0.named_child(i).map(
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::JsxElement_JsxExpression_JsxFragment_JsxSelfClosingElement_JsxText<
                    'tree,
                >,
            > as TryFrom<_>>::try_from,
        )
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for JsxFragment<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "jsx_fragment" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for JsxFragment<'tree> {
    const KIND: &'static str = "jsx_fragment";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `jsx_namespace_name`\n\nThis node has children: `identifier+` ([Identifier])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct JsxNamespaceName<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> JsxNamespaceName<'tree> {
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, Identifier<'tree>>,
        >,
    > + 'a {
        self.0.named_children(c).map(|n| {
            <type_sitter_lib::ExtraOr<'tree, Identifier<'tree>> as TryFrom<_>>::try_from(n)
        })
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<'tree, type_sitter_lib::ExtraOr<'tree, Identifier<'tree>>>,
    > {
        self.0
            .named_child(i)
            .map(<type_sitter_lib::ExtraOr<'tree, Identifier<'tree>> as TryFrom<_>>::try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for JsxNamespaceName<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "jsx_namespace_name" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for JsxNamespaceName<'tree> {
    const KIND: &'static str = "jsx_namespace_name";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `jsx_opening_element`\n\nThis node has these fields:\n- `attribute`: `{jsx_attribute | jsx_expression}*` ([anon_unions::JsxAttribute_JsxExpression])\n- `name`: `{identifier | jsx_namespace_name | nested_identifier}` ([anon_unions::Identifier_JsxNamespaceName_NestedIdentifier])\n- `type_arguments`: `type_arguments?` ([TypeArguments])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct JsxOpeningElement<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> JsxOpeningElement<'tree> {
    #[doc = "Get the field `attribute` which has kind `{jsx_attribute | jsx_expression}*` ([anon_unions::JsxAttribute_JsxExpression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn attributes<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, anon_unions::JsxAttribute_JsxExpression<'tree>>,
        >,
    > + 'a {
        self . 0 . children_by_field_name ("attribute" , c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: JsxAttribute_JsxExpression < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the field `name` which has kind `{identifier | jsx_namespace_name | nested_identifier}` ([anon_unions::Identifier_JsxNamespaceName_NestedIdentifier])"]
    #[allow(dead_code)]
    #[inline]
    pub fn name(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::Identifier_JsxNamespaceName_NestedIdentifier<'tree>,
    > {
        self . 0 . child_by_field_name ("name") . map (< anon_unions :: Identifier_JsxNamespaceName_NestedIdentifier < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `type_arguments` which has kind `type_arguments?` ([TypeArguments])"]
    #[allow(dead_code)]
    #[inline]
    pub fn type_arguments(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, TypeArguments<'tree>>> {
        self.0
            .child_by_field_name("type_arguments")
            .map(<TypeArguments<'tree> as TryFrom<_>>::try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for JsxOpeningElement<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "jsx_opening_element" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for JsxOpeningElement<'tree> {
    const KIND: &'static str = "jsx_opening_element";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `jsx_self_closing_element`\n\nThis node has these fields:\n- `attribute`: `{jsx_attribute | jsx_expression}*` ([anon_unions::JsxAttribute_JsxExpression])\n- `name`: `{identifier | jsx_namespace_name | nested_identifier}` ([anon_unions::Identifier_JsxNamespaceName_NestedIdentifier])\n- `type_arguments`: `type_arguments?` ([TypeArguments])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct JsxSelfClosingElement<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> JsxSelfClosingElement<'tree> {
    #[doc = "Get the field `attribute` which has kind `{jsx_attribute | jsx_expression}*` ([anon_unions::JsxAttribute_JsxExpression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn attributes<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, anon_unions::JsxAttribute_JsxExpression<'tree>>,
        >,
    > + 'a {
        self . 0 . children_by_field_name ("attribute" , c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: JsxAttribute_JsxExpression < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the field `name` which has kind `{identifier | jsx_namespace_name | nested_identifier}` ([anon_unions::Identifier_JsxNamespaceName_NestedIdentifier])"]
    #[allow(dead_code)]
    #[inline]
    pub fn name(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::Identifier_JsxNamespaceName_NestedIdentifier<'tree>,
    > {
        self . 0 . child_by_field_name ("name") . map (< anon_unions :: Identifier_JsxNamespaceName_NestedIdentifier < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `type_arguments` which has kind `type_arguments?` ([TypeArguments])"]
    #[allow(dead_code)]
    #[inline]
    pub fn type_arguments(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, TypeArguments<'tree>>> {
        self.0
            .child_by_field_name("type_arguments")
            .map(<TypeArguments<'tree> as TryFrom<_>>::try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for JsxSelfClosingElement<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "jsx_self_closing_element" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for JsxSelfClosingElement<'tree> {
    const KIND: &'static str = "jsx_self_closing_element";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `labeled_statement`\n\nThis node has these fields:\n- `body`: `statement` ([Statement])\n- `label`: `statement_identifier` ([StatementIdentifier])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct LabeledStatement<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> LabeledStatement<'tree> {
    #[doc = "Get the field `body` which has kind `statement` ([Statement])"]
    #[allow(dead_code)]
    #[inline]
    pub fn body(&self) -> type_sitter_lib::NodeResult<'tree, Statement<'tree>> {
        self . 0 . child_by_field_name ("body") . map (< Statement < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `label` which has kind `statement_identifier` ([StatementIdentifier])"]
    #[allow(dead_code)]
    #[inline]
    pub fn label(&self) -> type_sitter_lib::NodeResult<'tree, StatementIdentifier<'tree>> {
        self . 0 . child_by_field_name ("label") . map (< StatementIdentifier < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for LabeledStatement<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "labeled_statement" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for LabeledStatement<'tree> {
    const KIND: &'static str = "labeled_statement";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `lexical_declaration`\n\nThis node has these fields:\n- `kind`: `{const | let}` ([anon_unions::Const_Let])\n\nAnd additional children: `variable_declarator+` ([VariableDeclarator])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct LexicalDeclaration<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> LexicalDeclaration<'tree> {
    #[doc = "Get the field `kind` which has kind `{const | let}` ([anon_unions::Const_Let])"]
    #[allow(dead_code)]
    #[inline]
    pub fn kind(&self) -> type_sitter_lib::NodeResult<'tree, anon_unions::Const_Let<'tree>> {
        self . 0 . child_by_field_name ("kind") . map (< anon_unions :: Const_Let < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, anon_unions::VariableDeclarator_Const_Let<'tree>>,
        >,
    > + 'a {
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: VariableDeclarator_Const_Let < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, anon_unions::VariableDeclarator_Const_Let<'tree>>,
        >,
    > {
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: VariableDeclarator_Const_Let < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for LexicalDeclaration<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "lexical_declaration" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for LexicalDeclaration<'tree> {
    const KIND: &'static str = "lexical_declaration";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `literal_type`\n\nThis node has a child: `{false | null | number | string | true | unary_expression | undefined}`:\n- [False]\n- [Null]\n- [Number]\n- [String]\n- [True]\n- [UnaryExpression]\n- [Undefined]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct LiteralType<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> LiteralType<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::False_Null_Number_String_True_UnaryExpression_Undefined<'tree>,
    > {
        self . 0 . named_child (0) . map (< anon_unions :: False_Null_Number_String_True_UnaryExpression_Undefined < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for LiteralType<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "literal_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for LiteralType<'tree> {
    const KIND: &'static str = "literal_type";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `lookup_type`\n\nThis node has children: `{_primary_type | constructor_type | function_type | infer_type | readonly_type}+`:\n- [PrimaryType]\n- [ConstructorType]\n- [FunctionType]\n- [InferType]\n- [ReadonlyType]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct LookupType<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> LookupType<'tree> {
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
            >,
        >,
    > + 'a {
        self.0.named_children(c).map(|n| {
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
            > as TryFrom<_>>::try_from(n)
        })
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
            >,
        >,
    > {
        self.0.named_child(i).map(
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
            > as TryFrom<_>>::try_from,
        )
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for LookupType<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "lookup_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for LookupType<'tree> {
    const KIND: &'static str = "lookup_type";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `mapped_type_clause`\n\nThis node has these fields:\n- `alias`: `{_primary_type | constructor_type | function_type | infer_type | readonly_type}?` ([anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType])\n- `name`: `type_identifier` ([TypeIdentifier])\n- `type`: `{_primary_type | constructor_type | function_type | infer_type | readonly_type}` ([anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct MappedTypeClause<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> MappedTypeClause<'tree> {
    #[doc = "Get the field `alias` which has kind `{_primary_type | constructor_type | function_type | infer_type | readonly_type}?` ([anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType])"]
    #[allow(dead_code)]
    #[inline]
    pub fn alias(
        &self,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
        >,
    > {
        self . 0 . child_by_field_name ("alias") . map (< anon_unions :: PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType < 'tree > as TryFrom < _ >> :: try_from)
    }
    #[doc = "Get the field `name` which has kind `type_identifier` ([TypeIdentifier])"]
    #[allow(dead_code)]
    #[inline]
    pub fn name(&self) -> type_sitter_lib::NodeResult<'tree, TypeIdentifier<'tree>> {
        self . 0 . child_by_field_name ("name") . map (< TypeIdentifier < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `type` which has kind `{_primary_type | constructor_type | function_type | infer_type | readonly_type}` ([anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType])"]
    #[allow(dead_code)]
    #[inline]
    pub fn r#type(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
    > {
        self . 0 . child_by_field_name ("type") . map (< anon_unions :: PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for MappedTypeClause<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "mapped_type_clause" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for MappedTypeClause<'tree> {
    const KIND: &'static str = "mapped_type_clause";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `member_expression`\n\nThis node has these fields:\n- `object`: `expression` ([Expression])\n- `optional_chain`: `optional_chain?` ([OptionalChain])\n- `property`: `{private_property_identifier | property_identifier}` ([anon_unions::PrivatePropertyIdentifier_PropertyIdentifier])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct MemberExpression<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> MemberExpression<'tree> {
    #[doc = "Get the field `object` which has kind `expression` ([Expression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn object(&self) -> type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        self . 0 . child_by_field_name ("object") . map (< Expression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `optional_chain` which has kind `optional_chain?` ([OptionalChain])"]
    #[allow(dead_code)]
    #[inline]
    pub fn optional_chain(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, OptionalChain<'tree>>> {
        self.0
            .child_by_field_name("optional_chain")
            .map(<OptionalChain<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `property` which has kind `{private_property_identifier | property_identifier}` ([anon_unions::PrivatePropertyIdentifier_PropertyIdentifier])"]
    #[allow(dead_code)]
    #[inline]
    pub fn property(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::PrivatePropertyIdentifier_PropertyIdentifier<'tree>,
    > {
        self . 0 . child_by_field_name ("property") . map (< anon_unions :: PrivatePropertyIdentifier_PropertyIdentifier < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for MemberExpression<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "member_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for MemberExpression<'tree> {
    const KIND: &'static str = "member_expression";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `meta_property`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct MetaProperty<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> MetaProperty<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for MetaProperty<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "meta_property" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for MetaProperty<'tree> {
    const KIND: &'static str = "meta_property";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `method_definition`\n\nThis node has these fields:\n- `body`: `statement_block` ([StatementBlock])\n- `name`: `{computed_property_name | number | private_property_identifier | property_identifier | string}` ([anon_unions::ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String])\n- `nominal_return_type`: `nominal_type_annotation?` ([NominalTypeAnnotation])\n- `parameters`: `formal_parameters` ([FormalParameters])\n- `return_type`: `{asserts | type_annotation | type_predicate_annotation}?` ([anon_unions::Asserts_TypeAnnotation_TypePredicateAnnotation])\n- `type_parameters`: `type_parameters?` ([TypeParameters])\n\nAnd additional children: `{accessibility_modifier | override_modifier}*`:\n- [AccessibilityModifier]\n- [OverrideModifier]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct MethodDefinition<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> MethodDefinition<'tree> {
    #[doc = "Get the field `body` which has kind `statement_block` ([StatementBlock])"]
    #[allow(dead_code)]
    #[inline]
    pub fn body(&self) -> type_sitter_lib::NodeResult<'tree, StatementBlock<'tree>> {
        self . 0 . child_by_field_name ("body") . map (< StatementBlock < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `name` which has kind `{computed_property_name | number | private_property_identifier | property_identifier | string}` ([anon_unions::ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String])"]
    #[allow(dead_code)]
    #[inline]    pub fn name (& self) -> type_sitter_lib :: NodeResult < 'tree , anon_unions :: ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String < 'tree > >{
        self . 0 . child_by_field_name ("name") . map (< anon_unions :: ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `nominal_return_type` which has kind `nominal_type_annotation?` ([NominalTypeAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn nominal_return_type(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, NominalTypeAnnotation<'tree>>> {
        self.0
            .child_by_field_name("nominal_return_type")
            .map(<NominalTypeAnnotation<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `parameters` which has kind `formal_parameters` ([FormalParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn parameters(&self) -> type_sitter_lib::NodeResult<'tree, FormalParameters<'tree>> {
        self . 0 . child_by_field_name ("parameters") . map (< FormalParameters < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `return_type` which has kind `{asserts | type_annotation | type_predicate_annotation}?` ([anon_unions::Asserts_TypeAnnotation_TypePredicateAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn return_type(
        &self,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            anon_unions::Asserts_TypeAnnotation_TypePredicateAnnotation<'tree>,
        >,
    > {
        self . 0 . child_by_field_name ("return_type") . map (< anon_unions :: Asserts_TypeAnnotation_TypePredicateAnnotation < 'tree > as TryFrom < _ >> :: try_from)
    }
    #[doc = "Get the field `type_parameters` which has kind `type_parameters?` ([TypeParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn type_parameters(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, TypeParameters<'tree>>> {
        self.0
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]    pub fn children < 'a > (& self , c : & 'a mut yak_sitter :: TreeCursor < 'tree >) -> impl ExactSizeIterator < Item = type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AccessibilityModifier_OverrideModifier_StatementBlock_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_FormalParameters_Asserts_TypeAnnotation_TypePredicateAnnotation_TypeParameters < 'tree > > >> + 'a{
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AccessibilityModifier_OverrideModifier_StatementBlock_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_FormalParameters_Asserts_TypeAnnotation_TypePredicateAnnotation_TypeParameters < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]    pub fn child (& self , i : usize) -> Option < type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AccessibilityModifier_OverrideModifier_StatementBlock_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_FormalParameters_Asserts_TypeAnnotation_TypePredicateAnnotation_TypeParameters < 'tree > > >>{
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AccessibilityModifier_OverrideModifier_StatementBlock_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_FormalParameters_Asserts_TypeAnnotation_TypePredicateAnnotation_TypeParameters < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for MethodDefinition<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "method_definition" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for MethodDefinition<'tree> {
    const KIND: &'static str = "method_definition";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `method_signature`\n\nThis node has these fields:\n- `name`: `{computed_property_name | number | private_property_identifier | property_identifier | string}` ([anon_unions::ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String])\n- `nominal_return_type`: `nominal_type_annotation?` ([NominalTypeAnnotation])\n- `parameters`: `formal_parameters` ([FormalParameters])\n- `return_type`: `{asserts | type_annotation | type_predicate_annotation}?` ([anon_unions::Asserts_TypeAnnotation_TypePredicateAnnotation])\n- `type_parameters`: `type_parameters?` ([TypeParameters])\n\nAnd additional children: `{accessibility_modifier | override_modifier}*`:\n- [AccessibilityModifier]\n- [OverrideModifier]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct MethodSignature<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> MethodSignature<'tree> {
    #[doc = "Get the field `name` which has kind `{computed_property_name | number | private_property_identifier | property_identifier | string}` ([anon_unions::ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String])"]
    #[allow(dead_code)]
    #[inline]    pub fn name (& self) -> type_sitter_lib :: NodeResult < 'tree , anon_unions :: ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String < 'tree > >{
        self . 0 . child_by_field_name ("name") . map (< anon_unions :: ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `nominal_return_type` which has kind `nominal_type_annotation?` ([NominalTypeAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn nominal_return_type(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, NominalTypeAnnotation<'tree>>> {
        self.0
            .child_by_field_name("nominal_return_type")
            .map(<NominalTypeAnnotation<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `parameters` which has kind `formal_parameters` ([FormalParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn parameters(&self) -> type_sitter_lib::NodeResult<'tree, FormalParameters<'tree>> {
        self . 0 . child_by_field_name ("parameters") . map (< FormalParameters < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `return_type` which has kind `{asserts | type_annotation | type_predicate_annotation}?` ([anon_unions::Asserts_TypeAnnotation_TypePredicateAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn return_type(
        &self,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            anon_unions::Asserts_TypeAnnotation_TypePredicateAnnotation<'tree>,
        >,
    > {
        self . 0 . child_by_field_name ("return_type") . map (< anon_unions :: Asserts_TypeAnnotation_TypePredicateAnnotation < 'tree > as TryFrom < _ >> :: try_from)
    }
    #[doc = "Get the field `type_parameters` which has kind `type_parameters?` ([TypeParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn type_parameters(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, TypeParameters<'tree>>> {
        self.0
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]    pub fn children < 'a > (& self , c : & 'a mut yak_sitter :: TreeCursor < 'tree >) -> impl ExactSizeIterator < Item = type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AccessibilityModifier_OverrideModifier_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_FormalParameters_Asserts_TypeAnnotation_TypePredicateAnnotation_TypeParameters < 'tree > > >> + 'a{
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AccessibilityModifier_OverrideModifier_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_FormalParameters_Asserts_TypeAnnotation_TypePredicateAnnotation_TypeParameters < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]    pub fn child (& self , i : usize) -> Option < type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AccessibilityModifier_OverrideModifier_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_FormalParameters_Asserts_TypeAnnotation_TypePredicateAnnotation_TypeParameters < 'tree > > >>{
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AccessibilityModifier_OverrideModifier_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_FormalParameters_Asserts_TypeAnnotation_TypePredicateAnnotation_TypeParameters < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for MethodSignature<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "method_signature" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for MethodSignature<'tree> {
    const KIND: &'static str = "method_signature";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `module`\n\nThis node has these fields:\n- `body`: `statement_block?` ([StatementBlock])\n- `name`: `{identifier | nested_identifier | string}` ([anon_unions::Identifier_NestedIdentifier_String])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct Module<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> Module<'tree> {
    #[doc = "Get the field `body` which has kind `statement_block?` ([StatementBlock])"]
    #[allow(dead_code)]
    #[inline]
    pub fn body(&self) -> Option<type_sitter_lib::NodeResult<'tree, StatementBlock<'tree>>> {
        self.0
            .child_by_field_name("body")
            .map(<StatementBlock<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `name` which has kind `{identifier | nested_identifier | string}` ([anon_unions::Identifier_NestedIdentifier_String])"]
    #[allow(dead_code)]
    #[inline]
    pub fn name(
        &self,
    ) -> type_sitter_lib::NodeResult<'tree, anon_unions::Identifier_NestedIdentifier_String<'tree>>
    {
        self . 0 . child_by_field_name ("name") . map (< anon_unions :: Identifier_NestedIdentifier_String < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Module<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "module" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for Module<'tree> {
    const KIND: &'static str = "module";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `named_imports`\n\nThis node has children: `import_specifier*` ([ImportSpecifier])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct NamedImports<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> NamedImports<'tree> {
    #[doc = "Get the node's named children"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, ImportSpecifier<'tree>>,
        >,
    > + 'a {
        self.0.named_children(c).map(|n| {
            <type_sitter_lib::ExtraOr<'tree, ImportSpecifier<'tree>> as TryFrom<_>>::try_from(n)
        })
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<'tree, type_sitter_lib::ExtraOr<'tree, ImportSpecifier<'tree>>>,
    > {
        self.0
            .named_child(i)
            .map(<type_sitter_lib::ExtraOr<'tree, ImportSpecifier<'tree>> as TryFrom<_>>::try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for NamedImports<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "named_imports" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for NamedImports<'tree> {
    const KIND: &'static str = "named_imports";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `namespace_export`\n\nThis node has a child: `{identifier | string}`:\n- [Identifier]\n- [String]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct NamespaceExport<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> NamespaceExport<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
    ) -> type_sitter_lib::NodeResult<'tree, anon_unions::Identifier_String<'tree>> {
        self . 0 . named_child (0) . map (< anon_unions :: Identifier_String < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for NamespaceExport<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "namespace_export" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for NamespaceExport<'tree> {
    const KIND: &'static str = "namespace_export";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `namespace_import`\n\nThis node has a child: `identifier` ([Identifier])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct NamespaceImport<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> NamespaceImport<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(&self) -> type_sitter_lib::NodeResult<'tree, Identifier<'tree>> {
        self . 0 . named_child (0) . map (< Identifier < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for NamespaceImport<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "namespace_import" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for NamespaceImport<'tree> {
    const KIND: &'static str = "namespace_import";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `nested_identifier`\n\nThis node has children: `{identifier | nested_identifier}+`:\n- [Identifier]\n- [NestedIdentifier]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct NestedIdentifier<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> NestedIdentifier<'tree> {
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, anon_unions::Identifier_NestedIdentifier<'tree>>,
        >,
    > + 'a {
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: Identifier_NestedIdentifier < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, anon_unions::Identifier_NestedIdentifier<'tree>>,
        >,
    > {
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: Identifier_NestedIdentifier < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for NestedIdentifier<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "nested_identifier" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for NestedIdentifier<'tree> {
    const KIND: &'static str = "nested_identifier";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `nested_type_identifier`\n\nThis node has these fields:\n- `module`: `{identifier | nested_identifier}` ([anon_unions::Identifier_NestedIdentifier])\n- `name`: `type_identifier` ([TypeIdentifier])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct NestedTypeIdentifier<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> NestedTypeIdentifier<'tree> {
    #[doc = "Get the field `module` which has kind `{identifier | nested_identifier}` ([anon_unions::Identifier_NestedIdentifier])"]
    #[allow(dead_code)]
    #[inline]
    pub fn module(
        &self,
    ) -> type_sitter_lib::NodeResult<'tree, anon_unions::Identifier_NestedIdentifier<'tree>> {
        self . 0 . child_by_field_name ("module") . map (< anon_unions :: Identifier_NestedIdentifier < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `name` which has kind `type_identifier` ([TypeIdentifier])"]
    #[allow(dead_code)]
    #[inline]
    pub fn name(&self) -> type_sitter_lib::NodeResult<'tree, TypeIdentifier<'tree>> {
        self . 0 . child_by_field_name ("name") . map (< TypeIdentifier < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for NestedTypeIdentifier<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "nested_type_identifier" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for NestedTypeIdentifier<'tree> {
    const KIND: &'static str = "nested_type_identifier";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `new_expression`\n\nThis node has these fields:\n- `arguments`: `arguments?` ([Arguments])\n- `constructor`: `primary_expression` ([PrimaryExpression])\n- `type_arguments`: `type_arguments?` ([TypeArguments])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct NewExpression<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> NewExpression<'tree> {
    #[doc = "Get the field `arguments` which has kind `arguments?` ([Arguments])"]
    #[allow(dead_code)]
    #[inline]
    pub fn arguments(&self) -> Option<type_sitter_lib::NodeResult<'tree, Arguments<'tree>>> {
        self.0
            .child_by_field_name("arguments")
            .map(<Arguments<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `constructor` which has kind `primary_expression` ([PrimaryExpression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn constructor(&self) -> type_sitter_lib::NodeResult<'tree, PrimaryExpression<'tree>> {
        self . 0 . child_by_field_name ("constructor") . map (< PrimaryExpression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `type_arguments` which has kind `type_arguments?` ([TypeArguments])"]
    #[allow(dead_code)]
    #[inline]
    pub fn type_arguments(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, TypeArguments<'tree>>> {
        self.0
            .child_by_field_name("type_arguments")
            .map(<TypeArguments<'tree> as TryFrom<_>>::try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for NewExpression<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "new_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for NewExpression<'tree> {
    const KIND: &'static str = "new_expression";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `nominal_formal_parameters`\n\nThis node has these fields:\n- `rest_type`: `{_primary_nominal_type | function_nominal_type | nullable_nominal_type}?` ([anon_unions::PrimaryNominalType_FunctionNominalType_NullableNominalType])\n- `this_type`: `{_primary_nominal_type | function_nominal_type | nullable_nominal_type}?` ([anon_unions::PrimaryNominalType_FunctionNominalType_NullableNominalType])\n\nAnd additional children: `{_primary_nominal_type | function_nominal_type | nullable_nominal_type | optional_nominal_type}*`:\n- [PrimaryNominalType]\n- [FunctionNominalType]\n- [NullableNominalType]\n- [OptionalNominalType]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct NominalFormalParameters<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> NominalFormalParameters<'tree> {
    #[doc = "Get the field `rest_type` which has kind `{_primary_nominal_type | function_nominal_type | nullable_nominal_type}?` ([anon_unions::PrimaryNominalType_FunctionNominalType_NullableNominalType])"]
    #[allow(dead_code)]
    #[inline]
    pub fn rest_type(
        &self,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            anon_unions::PrimaryNominalType_FunctionNominalType_NullableNominalType<'tree>,
        >,
    > {
        self . 0 . child_by_field_name ("rest_type") . map (< anon_unions :: PrimaryNominalType_FunctionNominalType_NullableNominalType < 'tree > as TryFrom < _ >> :: try_from)
    }
    #[doc = "Get the field `this_type` which has kind `{_primary_nominal_type | function_nominal_type | nullable_nominal_type}?` ([anon_unions::PrimaryNominalType_FunctionNominalType_NullableNominalType])"]
    #[allow(dead_code)]
    #[inline]
    pub fn this_type(
        &self,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            anon_unions::PrimaryNominalType_FunctionNominalType_NullableNominalType<'tree>,
        >,
    > {
        self . 0 . child_by_field_name ("this_type") . map (< anon_unions :: PrimaryNominalType_FunctionNominalType_NullableNominalType < 'tree > as TryFrom < _ >> :: try_from)
    }
    #[doc = "Get the node's named children"]
    #[allow(dead_code)]
    #[inline]    pub fn children < 'a > (& self , c : & 'a mut yak_sitter :: TreeCursor < 'tree >) -> impl ExactSizeIterator < Item = type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryNominalType_FunctionNominalType_NullableNominalType_OptionalNominalType < 'tree > > >> + 'a{
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryNominalType_FunctionNominalType_NullableNominalType_OptionalNominalType < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]    pub fn child (& self , i : usize) -> Option < type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryNominalType_FunctionNominalType_NullableNominalType_OptionalNominalType < 'tree > > >>{
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryNominalType_FunctionNominalType_NullableNominalType_OptionalNominalType < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for NominalFormalParameters<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "nominal_formal_parameters" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for NominalFormalParameters<'tree> {
    const KIND: &'static str = "nominal_formal_parameters";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `nominal_method_signature`\n\nThis node has these fields:\n- `is_optional`: `??` ([symbols::Question])\n- `name`: `{computed_property_name | number | private_property_identifier | property_identifier | string}` ([anon_unions::ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String])\n- `nominal_type_parameters`: `nominal_type_parameters?` ([NominalTypeParameters])\n- `parameters`: `nominal_formal_parameters` ([NominalFormalParameters])\n- `return_type`: `nominal_type_annotation` ([NominalTypeAnnotation])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct NominalMethodSignature<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> NominalMethodSignature<'tree> {
    #[doc = "Get the field `is_optional` which has kind `??` ([symbols::Question])"]
    #[allow(dead_code)]
    #[inline]
    pub fn is_optional(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, symbols::Question<'tree>>> {
        self.0
            .child_by_field_name("is_optional")
            .map(<symbols::Question<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `name` which has kind `{computed_property_name | number | private_property_identifier | property_identifier | string}` ([anon_unions::ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String])"]
    #[allow(dead_code)]
    #[inline]    pub fn name (& self) -> type_sitter_lib :: NodeResult < 'tree , anon_unions :: ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String < 'tree > >{
        self . 0 . child_by_field_name ("name") . map (< anon_unions :: ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `nominal_type_parameters` which has kind `nominal_type_parameters?` ([NominalTypeParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn nominal_type_parameters(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, NominalTypeParameters<'tree>>> {
        self.0
            .child_by_field_name("nominal_type_parameters")
            .map(<NominalTypeParameters<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `parameters` which has kind `nominal_formal_parameters` ([NominalFormalParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn parameters(&self) -> type_sitter_lib::NodeResult<'tree, NominalFormalParameters<'tree>> {
        self . 0 . child_by_field_name ("parameters") . map (< NominalFormalParameters < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `return_type` which has kind `nominal_type_annotation` ([NominalTypeAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn return_type(&self) -> type_sitter_lib::NodeResult<'tree, NominalTypeAnnotation<'tree>> {
        self . 0 . child_by_field_name ("return_type") . map (< NominalTypeAnnotation < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for NominalMethodSignature<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "nominal_method_signature" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for NominalMethodSignature<'tree> {
    const KIND: &'static str = "nominal_method_signature";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `nominal_property_signature`\n\nThis node has these fields:\n- `is_optional`: `??` ([symbols::Question])\n- `name`: `{computed_property_name | number | private_property_identifier | property_identifier | string}` ([anon_unions::ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String])\n- `type`: `nominal_type_annotation` ([NominalTypeAnnotation])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct NominalPropertySignature<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> NominalPropertySignature<'tree> {
    #[doc = "Get the field `is_optional` which has kind `??` ([symbols::Question])"]
    #[allow(dead_code)]
    #[inline]
    pub fn is_optional(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, symbols::Question<'tree>>> {
        self.0
            .child_by_field_name("is_optional")
            .map(<symbols::Question<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `name` which has kind `{computed_property_name | number | private_property_identifier | property_identifier | string}` ([anon_unions::ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String])"]
    #[allow(dead_code)]
    #[inline]    pub fn name (& self) -> type_sitter_lib :: NodeResult < 'tree , anon_unions :: ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String < 'tree > >{
        self . 0 . child_by_field_name ("name") . map (< anon_unions :: ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `type` which has kind `nominal_type_annotation` ([NominalTypeAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn r#type(&self) -> type_sitter_lib::NodeResult<'tree, NominalTypeAnnotation<'tree>> {
        self . 0 . child_by_field_name ("type") . map (< NominalTypeAnnotation < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for NominalPropertySignature<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "nominal_property_signature" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for NominalPropertySignature<'tree> {
    const KIND: &'static str = "nominal_property_signature";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `nominal_supertypes`\n\nThis node has children: `{_primary_nominal_type | function_nominal_type | nullable_nominal_type}+`:\n- [PrimaryNominalType]\n- [FunctionNominalType]\n- [NullableNominalType]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct NominalSupertypes<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> NominalSupertypes<'tree> {
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::PrimaryNominalType_FunctionNominalType_NullableNominalType<'tree>,
            >,
        >,
    > + 'a {
        self.0.named_children(c).map(|n| {
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::PrimaryNominalType_FunctionNominalType_NullableNominalType<'tree>,
            > as TryFrom<_>>::try_from(n)
        })
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::PrimaryNominalType_FunctionNominalType_NullableNominalType<'tree>,
            >,
        >,
    > {
        self.0.named_child(i).map(
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::PrimaryNominalType_FunctionNominalType_NullableNominalType<'tree>,
            > as TryFrom<_>>::try_from,
        )
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for NominalSupertypes<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "nominal_supertypes" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for NominalSupertypes<'tree> {
    const KIND: &'static str = "nominal_supertypes";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `nominal_type_annotation`\n\nThis node has a child: `{_primary_nominal_type | function_nominal_type | nullable_nominal_type}`:\n- [PrimaryNominalType]\n- [FunctionNominalType]\n- [NullableNominalType]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct NominalTypeAnnotation<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> NominalTypeAnnotation<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::PrimaryNominalType_FunctionNominalType_NullableNominalType<'tree>,
    > {
        self . 0 . named_child (0) . map (< anon_unions :: PrimaryNominalType_FunctionNominalType_NullableNominalType < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for NominalTypeAnnotation<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "nominal_type_annotation" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for NominalTypeAnnotation<'tree> {
    const KIND: &'static str = "nominal_type_annotation";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `nominal_type_arguments`\n\nThis node has children: `{_primary_nominal_type | function_nominal_type | nullable_nominal_type}+`:\n- [PrimaryNominalType]\n- [FunctionNominalType]\n- [NullableNominalType]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct NominalTypeArguments<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> NominalTypeArguments<'tree> {
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::PrimaryNominalType_FunctionNominalType_NullableNominalType<'tree>,
            >,
        >,
    > + 'a {
        self.0.named_children(c).map(|n| {
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::PrimaryNominalType_FunctionNominalType_NullableNominalType<'tree>,
            > as TryFrom<_>>::try_from(n)
        })
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::PrimaryNominalType_FunctionNominalType_NullableNominalType<'tree>,
            >,
        >,
    > {
        self.0.named_child(i).map(
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::PrimaryNominalType_FunctionNominalType_NullableNominalType<'tree>,
            > as TryFrom<_>>::try_from,
        )
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for NominalTypeArguments<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "nominal_type_arguments" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for NominalTypeArguments<'tree> {
    const KIND: &'static str = "nominal_type_arguments";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `nominal_type_declaration`\n\nThis node has these fields:\n- `guard`: `nominal_type_guard?` ([NominalTypeGuard])\n- `name`: `nominal_type_identifier` ([NominalTypeIdentifier])\n- `nominal_supertypes`: `nominal_supertypes?` ([NominalSupertypes])\n- `nominal_type_parameters`: `nominal_type_parameters?` ([NominalTypeParameters])\n- `type`: `typescript_supertype?` ([TypescriptSupertype])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct NominalTypeDeclaration<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> NominalTypeDeclaration<'tree> {
    #[doc = "Get the field `guard` which has kind `nominal_type_guard?` ([NominalTypeGuard])"]
    #[allow(dead_code)]
    #[inline]
    pub fn guard(&self) -> Option<type_sitter_lib::NodeResult<'tree, NominalTypeGuard<'tree>>> {
        self.0
            .child_by_field_name("guard")
            .map(<NominalTypeGuard<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `name` which has kind `nominal_type_identifier` ([NominalTypeIdentifier])"]
    #[allow(dead_code)]
    #[inline]
    pub fn name(&self) -> type_sitter_lib::NodeResult<'tree, NominalTypeIdentifier<'tree>> {
        self . 0 . child_by_field_name ("name") . map (< NominalTypeIdentifier < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `nominal_supertypes` which has kind `nominal_supertypes?` ([NominalSupertypes])"]
    #[allow(dead_code)]
    #[inline]
    pub fn nominal_supertypes(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, NominalSupertypes<'tree>>> {
        self.0
            .child_by_field_name("nominal_supertypes")
            .map(<NominalSupertypes<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `nominal_type_parameters` which has kind `nominal_type_parameters?` ([NominalTypeParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn nominal_type_parameters(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, NominalTypeParameters<'tree>>> {
        self.0
            .child_by_field_name("nominal_type_parameters")
            .map(<NominalTypeParameters<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `type` which has kind `typescript_supertype?` ([TypescriptSupertype])"]
    #[allow(dead_code)]
    #[inline]
    pub fn r#type(&self) -> Option<type_sitter_lib::NodeResult<'tree, TypescriptSupertype<'tree>>> {
        self.0
            .child_by_field_name("type")
            .map(<TypescriptSupertype<'tree> as TryFrom<_>>::try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for NominalTypeDeclaration<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "nominal_type_declaration" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for NominalTypeDeclaration<'tree> {
    const KIND: &'static str = "nominal_type_declaration";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `nominal_type_guard`\n\nThis node has these fields:\n- `body`: `statement_block` ([StatementBlock])\n- `bound`: `{identifier | undefined}` ([anon_unions::Identifier_Undefined])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct NominalTypeGuard<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> NominalTypeGuard<'tree> {
    #[doc = "Get the field `body` which has kind `statement_block` ([StatementBlock])"]
    #[allow(dead_code)]
    #[inline]
    pub fn body(&self) -> type_sitter_lib::NodeResult<'tree, StatementBlock<'tree>> {
        self . 0 . child_by_field_name ("body") . map (< StatementBlock < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `bound` which has kind `{identifier | undefined}` ([anon_unions::Identifier_Undefined])"]
    #[allow(dead_code)]
    #[inline]
    pub fn bound(
        &self,
    ) -> type_sitter_lib::NodeResult<'tree, anon_unions::Identifier_Undefined<'tree>> {
        self . 0 . child_by_field_name ("bound") . map (< anon_unions :: Identifier_Undefined < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for NominalTypeGuard<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "nominal_type_guard" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for NominalTypeGuard<'tree> {
    const KIND: &'static str = "nominal_type_guard";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `nominal_type_parameter`\n\nThis node has these fields:\n- `variance`: `{biv | con | cov | inv}?` ([anon_unions::Biv_Con_Cov_Inv])\n\nAnd additional children: `{nominal_supertypes | nominal_type_identifier}+`:\n- [NominalSupertypes]\n- [NominalTypeIdentifier]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct NominalTypeParameter<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> NominalTypeParameter<'tree> {
    #[doc = "Get the field `variance` which has kind `{biv | con | cov | inv}?` ([anon_unions::Biv_Con_Cov_Inv])"]
    #[allow(dead_code)]
    #[inline]
    pub fn variance(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, anon_unions::Biv_Con_Cov_Inv<'tree>>> {
        self.0
            .child_by_field_name("variance")
            .map(<anon_unions::Biv_Con_Cov_Inv<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::NominalSupertypes_NominalTypeIdentifier_Biv_Con_Cov_Inv<'tree>,
            >,
        >,
    > + 'a {
        self.0.named_children(c).map(|n| {
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::NominalSupertypes_NominalTypeIdentifier_Biv_Con_Cov_Inv<'tree>,
            > as TryFrom<_>>::try_from(n)
        })
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::NominalSupertypes_NominalTypeIdentifier_Biv_Con_Cov_Inv<'tree>,
            >,
        >,
    > {
        self.0.named_child(i).map(
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::NominalSupertypes_NominalTypeIdentifier_Biv_Con_Cov_Inv<'tree>,
            > as TryFrom<_>>::try_from,
        )
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for NominalTypeParameter<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "nominal_type_parameter" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for NominalTypeParameter<'tree> {
    const KIND: &'static str = "nominal_type_parameter";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `nominal_type_parameters`\n\nThis node has children: `nominal_type_parameter+` ([NominalTypeParameter])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct NominalTypeParameters<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> NominalTypeParameters<'tree> {
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, NominalTypeParameter<'tree>>,
        >,
    > + 'a {
        self.0.named_children(c).map(|n| {
            <type_sitter_lib::ExtraOr<'tree, NominalTypeParameter<'tree>> as TryFrom<_>>::try_from(
                n,
            )
        })
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, NominalTypeParameter<'tree>>,
        >,
    > {
        self.0.named_child(i).map(
            <type_sitter_lib::ExtraOr<'tree, NominalTypeParameter<'tree>> as TryFrom<_>>::try_from,
        )
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for NominalTypeParameters<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "nominal_type_parameters" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for NominalTypeParameters<'tree> {
    const KIND: &'static str = "nominal_type_parameters";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `nominal_wrap_expression`\n\nThis node has children: `{_primary_nominal_type | function_nominal_type | nullable_nominal_type | primary_expression}+`:\n- [PrimaryNominalType]\n- [FunctionNominalType]\n- [NullableNominalType]\n- [PrimaryExpression]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct NominalWrapExpression<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> NominalWrapExpression<'tree> {
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]    pub fn children < 'a > (& self , c : & 'a mut yak_sitter :: TreeCursor < 'tree >) -> impl ExactSizeIterator < Item = type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryNominalType_FunctionNominalType_NullableNominalType_PrimaryExpression < 'tree > > >> + 'a{
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryNominalType_FunctionNominalType_NullableNominalType_PrimaryExpression < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]    pub fn child (& self , i : usize) -> Option < type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryNominalType_FunctionNominalType_NullableNominalType_PrimaryExpression < 'tree > > >>{
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryNominalType_FunctionNominalType_NullableNominalType_PrimaryExpression < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for NominalWrapExpression<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "nominal_wrap_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for NominalWrapExpression<'tree> {
    const KIND: &'static str = "nominal_wrap_expression";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `nominal_wrap_unchecked_expression`\n\nThis node has children: `{_primary_nominal_type | function_nominal_type | nullable_nominal_type | primary_expression}+`:\n- [PrimaryNominalType]\n- [FunctionNominalType]\n- [NullableNominalType]\n- [PrimaryExpression]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct NominalWrapUncheckedExpression<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> NominalWrapUncheckedExpression<'tree> {
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]    pub fn children < 'a > (& self , c : & 'a mut yak_sitter :: TreeCursor < 'tree >) -> impl ExactSizeIterator < Item = type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryNominalType_FunctionNominalType_NullableNominalType_PrimaryExpression < 'tree > > >> + 'a{
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryNominalType_FunctionNominalType_NullableNominalType_PrimaryExpression < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]    pub fn child (& self , i : usize) -> Option < type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryNominalType_FunctionNominalType_NullableNominalType_PrimaryExpression < 'tree > > >>{
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryNominalType_FunctionNominalType_NullableNominalType_PrimaryExpression < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for NominalWrapUncheckedExpression<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "nominal_wrap_unchecked_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for NominalWrapUncheckedExpression<'tree> {
    const KIND: &'static str = "nominal_wrap_unchecked_expression";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `non_null_expression`\n\nThis node has a child: `expression` ([Expression])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct NonNullExpression<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> NonNullExpression<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(&self) -> type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        self . 0 . named_child (0) . map (< Expression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for NonNullExpression<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "non_null_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for NonNullExpression<'tree> {
    const KIND: &'static str = "non_null_expression";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `nullable_nominal_type`\n\nThis node has a child: `_primary_nominal_type` ([PrimaryNominalType])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct NullableNominalType<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> NullableNominalType<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(&self) -> type_sitter_lib::NodeResult<'tree, PrimaryNominalType<'tree>> {
        self . 0 . named_child (0) . map (< PrimaryNominalType < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for NullableNominalType<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "nullable_nominal_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for NullableNominalType<'tree> {
    const KIND: &'static str = "nullable_nominal_type";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `object`\n\nThis node has children: `{method_definition | pair | shorthand_property_identifier | spread_element}*`:\n- [MethodDefinition]\n- [Pair]\n- [ShorthandPropertyIdentifier]\n- [SpreadElement]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct Object<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> Object<'tree> {
    #[doc = "Get the node's named children"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::MethodDefinition_Pair_ShorthandPropertyIdentifier_SpreadElement<'tree>,
            >,
        >,
    > + 'a {
        self.0.named_children(c).map(|n| {
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::MethodDefinition_Pair_ShorthandPropertyIdentifier_SpreadElement<'tree>,
            > as TryFrom<_>>::try_from(n)
        })
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::MethodDefinition_Pair_ShorthandPropertyIdentifier_SpreadElement<'tree>,
            >,
        >,
    > {
        self.0.named_child(i).map(
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::MethodDefinition_Pair_ShorthandPropertyIdentifier_SpreadElement<'tree>,
            > as TryFrom<_>>::try_from,
        )
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Object<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "object" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for Object<'tree> {
    const KIND: &'static str = "object";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `object_assignment_pattern`\n\nThis node has these fields:\n- `left`: `{array_pattern | object_pattern | shorthand_property_identifier_pattern}` ([anon_unions::ArrayPattern_ObjectPattern_ShorthandPropertyIdentifierPattern])\n- `right`: `expression` ([Expression])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ObjectAssignmentPattern<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ObjectAssignmentPattern<'tree> {
    #[doc = "Get the field `left` which has kind `{array_pattern | object_pattern | shorthand_property_identifier_pattern}` ([anon_unions::ArrayPattern_ObjectPattern_ShorthandPropertyIdentifierPattern])"]
    #[allow(dead_code)]
    #[inline]
    pub fn left(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::ArrayPattern_ObjectPattern_ShorthandPropertyIdentifierPattern<'tree>,
    > {
        self . 0 . child_by_field_name ("left") . map (< anon_unions :: ArrayPattern_ObjectPattern_ShorthandPropertyIdentifierPattern < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `right` which has kind `expression` ([Expression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn right(&self) -> type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        self . 0 . child_by_field_name ("right") . map (< Expression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ObjectAssignmentPattern<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "object_assignment_pattern" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ObjectAssignmentPattern<'tree> {
    const KIND: &'static str = "object_assignment_pattern";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `object_nominal_type`\n\nThis node has children: `{nominal_method_signature | nominal_property_signature}*`:\n- [NominalMethodSignature]\n- [NominalPropertySignature]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ObjectNominalType<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ObjectNominalType<'tree> {
    #[doc = "Get the node's named children"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::NominalMethodSignature_NominalPropertySignature<'tree>,
            >,
        >,
    > + 'a {
        self.0.named_children(c).map(|n| {
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::NominalMethodSignature_NominalPropertySignature<'tree>,
            > as TryFrom<_>>::try_from(n)
        })
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::NominalMethodSignature_NominalPropertySignature<'tree>,
            >,
        >,
    > {
        self.0.named_child(i).map(
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::NominalMethodSignature_NominalPropertySignature<'tree>,
            > as TryFrom<_>>::try_from,
        )
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ObjectNominalType<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "object_nominal_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ObjectNominalType<'tree> {
    const KIND: &'static str = "object_nominal_type";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `object_pattern`\n\nThis node has children: `{object_assignment_pattern | pair_pattern | rest_pattern | shorthand_property_identifier_pattern}*`:\n- [ObjectAssignmentPattern]\n- [PairPattern]\n- [RestPattern]\n- [ShorthandPropertyIdentifierPattern]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ObjectPattern<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ObjectPattern<'tree> {
    #[doc = "Get the node's named children"]
    #[allow(dead_code)]
    #[inline]    pub fn children < 'a > (& self , c : & 'a mut yak_sitter :: TreeCursor < 'tree >) -> impl ExactSizeIterator < Item = type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: ObjectAssignmentPattern_PairPattern_RestPattern_ShorthandPropertyIdentifierPattern < 'tree > > >> + 'a{
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: ObjectAssignmentPattern_PairPattern_RestPattern_ShorthandPropertyIdentifierPattern < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]    pub fn child (& self , i : usize) -> Option < type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: ObjectAssignmentPattern_PairPattern_RestPattern_ShorthandPropertyIdentifierPattern < 'tree > > >>{
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: ObjectAssignmentPattern_PairPattern_RestPattern_ShorthandPropertyIdentifierPattern < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ObjectPattern<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "object_pattern" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ObjectPattern<'tree> {
    const KIND: &'static str = "object_pattern";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `object_type`\n\nThis node has children: `{call_signature | construct_signature | export_statement | index_signature | method_signature | property_signature}*`:\n- [CallSignature]\n- [ConstructSignature]\n- [ExportStatement]\n- [IndexSignature]\n- [MethodSignature]\n- [PropertySignature]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ObjectType<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ObjectType<'tree> {
    #[doc = "Get the node's named children"]
    #[allow(dead_code)]
    #[inline]    pub fn children < 'a > (& self , c : & 'a mut yak_sitter :: TreeCursor < 'tree >) -> impl ExactSizeIterator < Item = type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: CallSignature_ConstructSignature_ExportStatement_IndexSignature_MethodSignature_PropertySignature < 'tree > > >> + 'a{
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: CallSignature_ConstructSignature_ExportStatement_IndexSignature_MethodSignature_PropertySignature < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]    pub fn child (& self , i : usize) -> Option < type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: CallSignature_ConstructSignature_ExportStatement_IndexSignature_MethodSignature_PropertySignature < 'tree > > >>{
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: CallSignature_ConstructSignature_ExportStatement_IndexSignature_MethodSignature_PropertySignature < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ObjectType<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "object_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ObjectType<'tree> {
    const KIND: &'static str = "object_type";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `omitting_type_annotation`\n\nThis node has a child: `{_primary_type | constructor_type | function_type | infer_type | readonly_type}`:\n- [PrimaryType]\n- [ConstructorType]\n- [FunctionType]\n- [InferType]\n- [ReadonlyType]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct OmittingTypeAnnotation<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> OmittingTypeAnnotation<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
    > {
        self . 0 . named_child (0) . map (< anon_unions :: PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for OmittingTypeAnnotation<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "omitting_type_annotation" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for OmittingTypeAnnotation<'tree> {
    const KIND: &'static str = "omitting_type_annotation";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `opting_type_annotation`\n\nThis node has a child: `{_primary_type | constructor_type | function_type | infer_type | readonly_type}`:\n- [PrimaryType]\n- [ConstructorType]\n- [FunctionType]\n- [InferType]\n- [ReadonlyType]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct OptingTypeAnnotation<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> OptingTypeAnnotation<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
    > {
        self . 0 . named_child (0) . map (< anon_unions :: PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for OptingTypeAnnotation<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "opting_type_annotation" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for OptingTypeAnnotation<'tree> {
    const KIND: &'static str = "opting_type_annotation";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `optional_chain`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct OptionalChain<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> OptionalChain<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for OptionalChain<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "optional_chain" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for OptionalChain<'tree> {
    const KIND: &'static str = "optional_chain";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `optional_nominal_type`\n\nThis node has a child: `{_primary_nominal_type | function_nominal_type | nullable_nominal_type}`:\n- [PrimaryNominalType]\n- [FunctionNominalType]\n- [NullableNominalType]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct OptionalNominalType<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> OptionalNominalType<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::PrimaryNominalType_FunctionNominalType_NullableNominalType<'tree>,
    > {
        self . 0 . named_child (0) . map (< anon_unions :: PrimaryNominalType_FunctionNominalType_NullableNominalType < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for OptionalNominalType<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "optional_nominal_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for OptionalNominalType<'tree> {
    const KIND: &'static str = "optional_nominal_type";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `optional_parameter`\n\nThis node has these fields:\n- `decorator`: `decorator*` ([Decorator])\n- `name`: `identifier?` ([Identifier])\n- `nominal_type`: `nominal_type_annotation?` ([NominalTypeAnnotation])\n- `pattern`: `{pattern | this}?` ([anon_unions::Pattern_This])\n- `type`: `type_annotation?` ([TypeAnnotation])\n- `value`: `expression?` ([Expression])\n\nAnd additional children: `{accessibility_modifier | override_modifier}*`:\n- [AccessibilityModifier]\n- [OverrideModifier]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct OptionalParameter<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> OptionalParameter<'tree> {
    #[doc = "Get the field `decorator` which has kind `decorator*` ([Decorator])"]
    #[allow(dead_code)]
    #[inline]
    pub fn decorators<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, Decorator<'tree>>,
        >,
    > + 'a {
        self.0
            .children_by_field_name("decorator", c)
            .map(|n| <type_sitter_lib::ExtraOr<'tree, Decorator<'tree>> as TryFrom<_>>::try_from(n))
    }
    #[doc = "Get the field `name` which has kind `identifier?` ([Identifier])"]
    #[allow(dead_code)]
    #[inline]
    pub fn name(&self) -> Option<type_sitter_lib::NodeResult<'tree, Identifier<'tree>>> {
        self.0
            .child_by_field_name("name")
            .map(<Identifier<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `nominal_type` which has kind `nominal_type_annotation?` ([NominalTypeAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn nominal_type(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, NominalTypeAnnotation<'tree>>> {
        self.0
            .child_by_field_name("nominal_type")
            .map(<NominalTypeAnnotation<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `pattern` which has kind `{pattern | this}?` ([anon_unions::Pattern_This])"]
    #[allow(dead_code)]
    #[inline]
    pub fn pattern(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, anon_unions::Pattern_This<'tree>>> {
        self.0
            .child_by_field_name("pattern")
            .map(<anon_unions::Pattern_This<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `type` which has kind `type_annotation?` ([TypeAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn r#type(&self) -> Option<type_sitter_lib::NodeResult<'tree, TypeAnnotation<'tree>>> {
        self.0
            .child_by_field_name("type")
            .map(<TypeAnnotation<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `value` which has kind `expression?` ([Expression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn value(&self) -> Option<type_sitter_lib::NodeResult<'tree, Expression<'tree>>> {
        self.0
            .child_by_field_name("value")
            .map(<Expression<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the node's named children"]
    #[allow(dead_code)]
    #[inline]    pub fn children < 'a > (& self , c : & 'a mut yak_sitter :: TreeCursor < 'tree >) -> impl ExactSizeIterator < Item = type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AccessibilityModifier_OverrideModifier_Decorator_Identifier_NominalTypeAnnotation_Pattern_This_TypeAnnotation_Expression < 'tree > > >> + 'a{
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AccessibilityModifier_OverrideModifier_Decorator_Identifier_NominalTypeAnnotation_Pattern_This_TypeAnnotation_Expression < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]    pub fn child (& self , i : usize) -> Option < type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AccessibilityModifier_OverrideModifier_Decorator_Identifier_NominalTypeAnnotation_Pattern_This_TypeAnnotation_Expression < 'tree > > >>{
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AccessibilityModifier_OverrideModifier_Decorator_Identifier_NominalTypeAnnotation_Pattern_This_TypeAnnotation_Expression < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for OptionalParameter<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "optional_parameter" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for OptionalParameter<'tree> {
    const KIND: &'static str = "optional_parameter";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `optional_type`\n\nThis node has a child: `{_primary_type | constructor_type | function_type | infer_type | readonly_type}`:\n- [PrimaryType]\n- [ConstructorType]\n- [FunctionType]\n- [InferType]\n- [ReadonlyType]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct OptionalType<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> OptionalType<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
    > {
        self . 0 . named_child (0) . map (< anon_unions :: PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for OptionalType<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "optional_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for OptionalType<'tree> {
    const KIND: &'static str = "optional_type";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `override_modifier`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct OverrideModifier<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> OverrideModifier<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for OverrideModifier<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "override_modifier" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for OverrideModifier<'tree> {
    const KIND: &'static str = "override_modifier";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `pair`\n\nThis node has these fields:\n- `key`: `{computed_property_name | number | private_property_identifier | property_identifier | string}` ([anon_unions::ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String])\n- `value`: `expression` ([Expression])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct Pair<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> Pair<'tree> {
    #[doc = "Get the field `key` which has kind `{computed_property_name | number | private_property_identifier | property_identifier | string}` ([anon_unions::ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String])"]
    #[allow(dead_code)]
    #[inline]    pub fn key (& self) -> type_sitter_lib :: NodeResult < 'tree , anon_unions :: ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String < 'tree > >{
        self . 0 . child_by_field_name ("key") . map (< anon_unions :: ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `value` which has kind `expression` ([Expression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn value(&self) -> type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        self . 0 . child_by_field_name ("value") . map (< Expression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Pair<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "pair" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for Pair<'tree> {
    const KIND: &'static str = "pair";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `pair_pattern`\n\nThis node has these fields:\n- `key`: `{computed_property_name | number | private_property_identifier | property_identifier | string}` ([anon_unions::ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String])\n- `value`: `{assignment_pattern | pattern}` ([anon_unions::AssignmentPattern_Pattern])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct PairPattern<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> PairPattern<'tree> {
    #[doc = "Get the field `key` which has kind `{computed_property_name | number | private_property_identifier | property_identifier | string}` ([anon_unions::ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String])"]
    #[allow(dead_code)]
    #[inline]    pub fn key (& self) -> type_sitter_lib :: NodeResult < 'tree , anon_unions :: ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String < 'tree > >{
        self . 0 . child_by_field_name ("key") . map (< anon_unions :: ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `value` which has kind `{assignment_pattern | pattern}` ([anon_unions::AssignmentPattern_Pattern])"]
    #[allow(dead_code)]
    #[inline]
    pub fn value(
        &self,
    ) -> type_sitter_lib::NodeResult<'tree, anon_unions::AssignmentPattern_Pattern<'tree>> {
        self . 0 . child_by_field_name ("value") . map (< anon_unions :: AssignmentPattern_Pattern < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for PairPattern<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "pair_pattern" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for PairPattern<'tree> {
    const KIND: &'static str = "pair_pattern";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `parenthesized_expression`\n\nThis node has these fields:\n- `nominal_type`: `nominal_type_annotation?` ([NominalTypeAnnotation])\n- `type`: `type_annotation?` ([TypeAnnotation])\n\nAnd an additional child: `{expression | sequence_expression}`:\n- [Expression]\n- [SequenceExpression]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ParenthesizedExpression<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ParenthesizedExpression<'tree> {
    #[doc = "Get the field `nominal_type` which has kind `nominal_type_annotation?` ([NominalTypeAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn nominal_type(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, NominalTypeAnnotation<'tree>>> {
        self.0
            .child_by_field_name("nominal_type")
            .map(<NominalTypeAnnotation<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `type` which has kind `type_annotation?` ([TypeAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn r#type(&self) -> Option<type_sitter_lib::NodeResult<'tree, TypeAnnotation<'tree>>> {
        self.0
            .child_by_field_name("type")
            .map(<TypeAnnotation<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::Expression_SequenceExpression_NominalTypeAnnotation_TypeAnnotation<
                    'tree,
                >,
            >,
        >,
    > + 'a {
        self.0.named_children(c).map(|n| {
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::Expression_SequenceExpression_NominalTypeAnnotation_TypeAnnotation<
                    'tree,
                >,
            > as TryFrom<_>>::try_from(n)
        })
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::Expression_SequenceExpression_NominalTypeAnnotation_TypeAnnotation<
                    'tree,
                >,
            >,
        >,
    > {
        self.0.named_child(i).map(
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::Expression_SequenceExpression_NominalTypeAnnotation_TypeAnnotation<
                    'tree,
                >,
            > as TryFrom<_>>::try_from,
        )
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ParenthesizedExpression<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "parenthesized_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ParenthesizedExpression<'tree> {
    const KIND: &'static str = "parenthesized_expression";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `parenthesized_nominal_type`\n\nThis node has a child: `{_primary_nominal_type | function_nominal_type | nullable_nominal_type}`:\n- [PrimaryNominalType]\n- [FunctionNominalType]\n- [NullableNominalType]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ParenthesizedNominalType<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ParenthesizedNominalType<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::PrimaryNominalType_FunctionNominalType_NullableNominalType<'tree>,
    > {
        self . 0 . named_child (0) . map (< anon_unions :: PrimaryNominalType_FunctionNominalType_NullableNominalType < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ParenthesizedNominalType<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "parenthesized_nominal_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ParenthesizedNominalType<'tree> {
    const KIND: &'static str = "parenthesized_nominal_type";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `parenthesized_type`\n\nThis node has a child: `{_primary_type | constructor_type | function_type | infer_type | readonly_type}`:\n- [PrimaryType]\n- [ConstructorType]\n- [FunctionType]\n- [InferType]\n- [ReadonlyType]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ParenthesizedType<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ParenthesizedType<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
    > {
        self . 0 . named_child (0) . map (< anon_unions :: PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ParenthesizedType<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "parenthesized_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ParenthesizedType<'tree> {
    const KIND: &'static str = "parenthesized_type";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `predefined_type`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct PredefinedType<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> PredefinedType<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for PredefinedType<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "predefined_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for PredefinedType<'tree> {
    const KIND: &'static str = "predefined_type";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `program`\n\nThis node has children: `{hash_bang_line | statement}*`:\n- [HashBangLine]\n- [Statement]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct Program<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> Program<'tree> {
    #[doc = "Get the node's named children"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, anon_unions::HashBangLine_Statement<'tree>>,
        >,
    > + 'a {
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: HashBangLine_Statement < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, anon_unions::HashBangLine_Statement<'tree>>,
        >,
    > {
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: HashBangLine_Statement < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Program<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "program" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for Program<'tree> {
    const KIND: &'static str = "program";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `property_signature`\n\nThis node has these fields:\n- `is_optional`: `??` ([symbols::Question])\n- `name`: `{computed_property_name | number | private_property_identifier | property_identifier | string}` ([anon_unions::ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String])\n- `nominal_type`: `nominal_type_annotation?` ([NominalTypeAnnotation])\n- `type`: `type_annotation?` ([TypeAnnotation])\n\nAnd additional children: `{accessibility_modifier | override_modifier}*`:\n- [AccessibilityModifier]\n- [OverrideModifier]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct PropertySignature<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> PropertySignature<'tree> {
    #[doc = "Get the field `is_optional` which has kind `??` ([symbols::Question])"]
    #[allow(dead_code)]
    #[inline]
    pub fn is_optional(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, symbols::Question<'tree>>> {
        self.0
            .child_by_field_name("is_optional")
            .map(<symbols::Question<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `name` which has kind `{computed_property_name | number | private_property_identifier | property_identifier | string}` ([anon_unions::ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String])"]
    #[allow(dead_code)]
    #[inline]    pub fn name (& self) -> type_sitter_lib :: NodeResult < 'tree , anon_unions :: ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String < 'tree > >{
        self . 0 . child_by_field_name ("name") . map (< anon_unions :: ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `nominal_type` which has kind `nominal_type_annotation?` ([NominalTypeAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn nominal_type(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, NominalTypeAnnotation<'tree>>> {
        self.0
            .child_by_field_name("nominal_type")
            .map(<NominalTypeAnnotation<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `type` which has kind `type_annotation?` ([TypeAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn r#type(&self) -> Option<type_sitter_lib::NodeResult<'tree, TypeAnnotation<'tree>>> {
        self.0
            .child_by_field_name("type")
            .map(<TypeAnnotation<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]    pub fn children < 'a > (& self , c : & 'a mut yak_sitter :: TreeCursor < 'tree >) -> impl ExactSizeIterator < Item = type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AccessibilityModifier_OverrideModifier_Question_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_TypeAnnotation < 'tree > > >> + 'a{
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AccessibilityModifier_OverrideModifier_Question_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_TypeAnnotation < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]    pub fn child (& self , i : usize) -> Option < type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AccessibilityModifier_OverrideModifier_Question_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_TypeAnnotation < 'tree > > >>{
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AccessibilityModifier_OverrideModifier_Question_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_TypeAnnotation < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for PropertySignature<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "property_signature" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for PropertySignature<'tree> {
    const KIND: &'static str = "property_signature";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `public_field_definition`\n\nThis node has these fields:\n- `name`: `{computed_property_name | number | private_property_identifier | property_identifier | string}` ([anon_unions::ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String])\n- `nominal_type`: `nominal_type_annotation?` ([NominalTypeAnnotation])\n- `type`: `type_annotation?` ([TypeAnnotation])\n- `value`: `expression?` ([Expression])\n\nAnd additional children: `{accessibility_modifier | override_modifier}*`:\n- [AccessibilityModifier]\n- [OverrideModifier]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct PublicFieldDefinition<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> PublicFieldDefinition<'tree> {
    #[doc = "Get the field `name` which has kind `{computed_property_name | number | private_property_identifier | property_identifier | string}` ([anon_unions::ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String])"]
    #[allow(dead_code)]
    #[inline]    pub fn name (& self) -> type_sitter_lib :: NodeResult < 'tree , anon_unions :: ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String < 'tree > >{
        self . 0 . child_by_field_name ("name") . map (< anon_unions :: ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `nominal_type` which has kind `nominal_type_annotation?` ([NominalTypeAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn nominal_type(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, NominalTypeAnnotation<'tree>>> {
        self.0
            .child_by_field_name("nominal_type")
            .map(<NominalTypeAnnotation<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `type` which has kind `type_annotation?` ([TypeAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn r#type(&self) -> Option<type_sitter_lib::NodeResult<'tree, TypeAnnotation<'tree>>> {
        self.0
            .child_by_field_name("type")
            .map(<TypeAnnotation<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `value` which has kind `expression?` ([Expression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn value(&self) -> Option<type_sitter_lib::NodeResult<'tree, Expression<'tree>>> {
        self.0
            .child_by_field_name("value")
            .map(<Expression<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]    pub fn children < 'a > (& self , c : & 'a mut yak_sitter :: TreeCursor < 'tree >) -> impl ExactSizeIterator < Item = type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AccessibilityModifier_OverrideModifier_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_TypeAnnotation_Expression < 'tree > > >> + 'a{
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AccessibilityModifier_OverrideModifier_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_TypeAnnotation_Expression < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]    pub fn child (& self , i : usize) -> Option < type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AccessibilityModifier_OverrideModifier_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_TypeAnnotation_Expression < 'tree > > >>{
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AccessibilityModifier_OverrideModifier_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_TypeAnnotation_Expression < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for PublicFieldDefinition<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "public_field_definition" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for PublicFieldDefinition<'tree> {
    const KIND: &'static str = "public_field_definition";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `readonly_type`\n\nThis node has a child: `{_primary_type | constructor_type | function_type | infer_type | readonly_type}`:\n- [PrimaryType]\n- [ConstructorType]\n- [FunctionType]\n- [InferType]\n- [ReadonlyType]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ReadonlyType<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ReadonlyType<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
    > {
        self . 0 . named_child (0) . map (< anon_unions :: PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ReadonlyType<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "readonly_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ReadonlyType<'tree> {
    const KIND: &'static str = "readonly_type";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `regex`\n\nThis node has these fields:\n- `flags`: `regex_flags?` ([RegexFlags])\n- `pattern`: `regex_pattern` ([RegexPattern])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct Regex<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> Regex<'tree> {
    #[doc = "Get the field `flags` which has kind `regex_flags?` ([RegexFlags])"]
    #[allow(dead_code)]
    #[inline]
    pub fn flags(&self) -> Option<type_sitter_lib::NodeResult<'tree, RegexFlags<'tree>>> {
        self.0
            .child_by_field_name("flags")
            .map(<RegexFlags<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `pattern` which has kind `regex_pattern` ([RegexPattern])"]
    #[allow(dead_code)]
    #[inline]
    pub fn pattern(&self) -> type_sitter_lib::NodeResult<'tree, RegexPattern<'tree>> {
        self . 0 . child_by_field_name ("pattern") . map (< RegexPattern < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Regex<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "regex" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for Regex<'tree> {
    const KIND: &'static str = "regex";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `required_parameter`\n\nThis node has these fields:\n- `decorator`: `decorator*` ([Decorator])\n- `name`: `{identifier | rest_pattern}?` ([anon_unions::Identifier_RestPattern])\n- `nominal_type`: `nominal_type_annotation?` ([NominalTypeAnnotation])\n- `pattern`: `{pattern | this}?` ([anon_unions::Pattern_This])\n- `type`: `type_annotation?` ([TypeAnnotation])\n- `value`: `expression?` ([Expression])\n\nAnd additional children: `{accessibility_modifier | override_modifier}*`:\n- [AccessibilityModifier]\n- [OverrideModifier]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct RequiredParameter<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> RequiredParameter<'tree> {
    #[doc = "Get the field `decorator` which has kind `decorator*` ([Decorator])"]
    #[allow(dead_code)]
    #[inline]
    pub fn decorators<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, Decorator<'tree>>,
        >,
    > + 'a {
        self.0
            .children_by_field_name("decorator", c)
            .map(|n| <type_sitter_lib::ExtraOr<'tree, Decorator<'tree>> as TryFrom<_>>::try_from(n))
    }
    #[doc = "Get the field `name` which has kind `{identifier | rest_pattern}?` ([anon_unions::Identifier_RestPattern])"]
    #[allow(dead_code)]
    #[inline]
    pub fn name(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, anon_unions::Identifier_RestPattern<'tree>>>
    {
        self.0
            .child_by_field_name("name")
            .map(<anon_unions::Identifier_RestPattern<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `nominal_type` which has kind `nominal_type_annotation?` ([NominalTypeAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn nominal_type(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, NominalTypeAnnotation<'tree>>> {
        self.0
            .child_by_field_name("nominal_type")
            .map(<NominalTypeAnnotation<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `pattern` which has kind `{pattern | this}?` ([anon_unions::Pattern_This])"]
    #[allow(dead_code)]
    #[inline]
    pub fn pattern(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, anon_unions::Pattern_This<'tree>>> {
        self.0
            .child_by_field_name("pattern")
            .map(<anon_unions::Pattern_This<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `type` which has kind `type_annotation?` ([TypeAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn r#type(&self) -> Option<type_sitter_lib::NodeResult<'tree, TypeAnnotation<'tree>>> {
        self.0
            .child_by_field_name("type")
            .map(<TypeAnnotation<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `value` which has kind `expression?` ([Expression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn value(&self) -> Option<type_sitter_lib::NodeResult<'tree, Expression<'tree>>> {
        self.0
            .child_by_field_name("value")
            .map(<Expression<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the node's named children"]
    #[allow(dead_code)]
    #[inline]    pub fn children < 'a > (& self , c : & 'a mut yak_sitter :: TreeCursor < 'tree >) -> impl ExactSizeIterator < Item = type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AccessibilityModifier_OverrideModifier_Decorator_Identifier_RestPattern_NominalTypeAnnotation_Pattern_This_TypeAnnotation_Expression < 'tree > > >> + 'a{
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AccessibilityModifier_OverrideModifier_Decorator_Identifier_RestPattern_NominalTypeAnnotation_Pattern_This_TypeAnnotation_Expression < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]    pub fn child (& self , i : usize) -> Option < type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AccessibilityModifier_OverrideModifier_Decorator_Identifier_RestPattern_NominalTypeAnnotation_Pattern_This_TypeAnnotation_Expression < 'tree > > >>{
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: AccessibilityModifier_OverrideModifier_Decorator_Identifier_RestPattern_NominalTypeAnnotation_Pattern_This_TypeAnnotation_Expression < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for RequiredParameter<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "required_parameter" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for RequiredParameter<'tree> {
    const KIND: &'static str = "required_parameter";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `rest_pattern`\n\nThis node has a child: `{array_pattern | identifier | member_expression | non_null_expression | object_pattern | subscript_expression | undefined}`:\n- [ArrayPattern]\n- [Identifier]\n- [MemberExpression]\n- [NonNullExpression]\n- [ObjectPattern]\n- [SubscriptExpression]\n- [Undefined]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct RestPattern<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> RestPattern<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]    pub fn child (& self) -> type_sitter_lib :: NodeResult < 'tree , anon_unions :: ArrayPattern_Identifier_MemberExpression_NonNullExpression_ObjectPattern_SubscriptExpression_Undefined < 'tree > >{
        self . 0 . named_child (0) . map (< anon_unions :: ArrayPattern_Identifier_MemberExpression_NonNullExpression_ObjectPattern_SubscriptExpression_Undefined < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for RestPattern<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "rest_pattern" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for RestPattern<'tree> {
    const KIND: &'static str = "rest_pattern";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `rest_type`\n\nThis node has a child: `{_primary_type | constructor_type | function_type | infer_type | readonly_type}`:\n- [PrimaryType]\n- [ConstructorType]\n- [FunctionType]\n- [InferType]\n- [ReadonlyType]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct RestType<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> RestType<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
    > {
        self . 0 . named_child (0) . map (< anon_unions :: PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for RestType<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "rest_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for RestType<'tree> {
    const KIND: &'static str = "rest_type";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `return_statement`\n\nThis node has an (optional) child: `{expression | sequence_expression}?`:\n- [Expression]\n- [SequenceExpression]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ReturnStatement<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ReturnStatement<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, anon_unions::Expression_SequenceExpression<'tree>>>
    {
        self.0
            .named_child(0)
            .map(<anon_unions::Expression_SequenceExpression<'tree> as TryFrom<_>>::try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ReturnStatement<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "return_statement" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ReturnStatement<'tree> {
    const KIND: &'static str = "return_statement";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `satisfies_expression`\n\nThis node has children: `{_primary_type | constructor_type | expression | function_type | infer_type | readonly_type}+`:\n- [PrimaryType]\n- [ConstructorType]\n- [Expression]\n- [FunctionType]\n- [InferType]\n- [ReadonlyType]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct SatisfiesExpression<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> SatisfiesExpression<'tree> {
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]    pub fn children < 'a > (& self , c : & 'a mut yak_sitter :: TreeCursor < 'tree >) -> impl ExactSizeIterator < Item = type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryType_ConstructorType_Expression_FunctionType_InferType_ReadonlyType < 'tree > > >> + 'a{
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryType_ConstructorType_Expression_FunctionType_InferType_ReadonlyType < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]    pub fn child (& self , i : usize) -> Option < type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryType_ConstructorType_Expression_FunctionType_InferType_ReadonlyType < 'tree > > >>{
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryType_ConstructorType_Expression_FunctionType_InferType_ReadonlyType < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for SatisfiesExpression<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "satisfies_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for SatisfiesExpression<'tree> {
    const KIND: &'static str = "satisfies_expression";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `sequence_expression`\n\nThis node has these fields:\n- `left`: `expression` ([Expression])\n- `right`: `{expression | sequence_expression}` ([anon_unions::Expression_SequenceExpression])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct SequenceExpression<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> SequenceExpression<'tree> {
    #[doc = "Get the field `left` which has kind `expression` ([Expression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn left(&self) -> type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        self . 0 . child_by_field_name ("left") . map (< Expression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `right` which has kind `{expression | sequence_expression}` ([anon_unions::Expression_SequenceExpression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn right(
        &self,
    ) -> type_sitter_lib::NodeResult<'tree, anon_unions::Expression_SequenceExpression<'tree>> {
        self . 0 . child_by_field_name ("right") . map (< anon_unions :: Expression_SequenceExpression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for SequenceExpression<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "sequence_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for SequenceExpression<'tree> {
    const KIND: &'static str = "sequence_expression";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `spread_element`\n\nThis node has a child: `expression` ([Expression])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct SpreadElement<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> SpreadElement<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(&self) -> type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        self . 0 . named_child (0) . map (< Expression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for SpreadElement<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "spread_element" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for SpreadElement<'tree> {
    const KIND: &'static str = "spread_element";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `statement_block`\n\nThis node has children: `statement*` ([Statement])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct StatementBlock<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> StatementBlock<'tree> {
    #[doc = "Get the node's named children"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, Statement<'tree>>,
        >,
    > + 'a {
        self.0
            .named_children(c)
            .map(|n| <type_sitter_lib::ExtraOr<'tree, Statement<'tree>> as TryFrom<_>>::try_from(n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<type_sitter_lib::NodeResult<'tree, type_sitter_lib::ExtraOr<'tree, Statement<'tree>>>>
    {
        self.0
            .named_child(i)
            .map(<type_sitter_lib::ExtraOr<'tree, Statement<'tree>> as TryFrom<_>>::try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for StatementBlock<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "statement_block" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for StatementBlock<'tree> {
    const KIND: &'static str = "statement_block";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `string`\n\nThis node has children: `{escape_sequence | string_fragment}*`:\n- [EscapeSequence]\n- [StringFragment]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct String<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> String<'tree> {
    #[doc = "Get the node's named children"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, anon_unions::EscapeSequence_StringFragment<'tree>>,
        >,
    > + 'a {
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: EscapeSequence_StringFragment < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, anon_unions::EscapeSequence_StringFragment<'tree>>,
        >,
    > {
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: EscapeSequence_StringFragment < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for String<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "string" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for String<'tree> {
    const KIND: &'static str = "string";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `subscript_expression`\n\nThis node has these fields:\n- `index`: `{expression | number | predefined_type | sequence_expression | string}` ([anon_unions::Expression_Number_PredefinedType_SequenceExpression_String])\n- `object`: `expression` ([Expression])\n- `optional_chain`: `optional_chain?` ([OptionalChain])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct SubscriptExpression<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> SubscriptExpression<'tree> {
    #[doc = "Get the field `index` which has kind `{expression | number | predefined_type | sequence_expression | string}` ([anon_unions::Expression_Number_PredefinedType_SequenceExpression_String])"]
    #[allow(dead_code)]
    #[inline]
    pub fn index(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::Expression_Number_PredefinedType_SequenceExpression_String<'tree>,
    > {
        self . 0 . child_by_field_name ("index") . map (< anon_unions :: Expression_Number_PredefinedType_SequenceExpression_String < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `object` which has kind `expression` ([Expression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn object(&self) -> type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        self . 0 . child_by_field_name ("object") . map (< Expression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `optional_chain` which has kind `optional_chain?` ([OptionalChain])"]
    #[allow(dead_code)]
    #[inline]
    pub fn optional_chain(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, OptionalChain<'tree>>> {
        self.0
            .child_by_field_name("optional_chain")
            .map(<OptionalChain<'tree> as TryFrom<_>>::try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for SubscriptExpression<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "subscript_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for SubscriptExpression<'tree> {
    const KIND: &'static str = "subscript_expression";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `switch_body`\n\nThis node has children: `{switch_case | switch_default}*`:\n- [SwitchCase]\n- [SwitchDefault]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct SwitchBody<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> SwitchBody<'tree> {
    #[doc = "Get the node's named children"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, anon_unions::SwitchCase_SwitchDefault<'tree>>,
        >,
    > + 'a {
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: SwitchCase_SwitchDefault < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, anon_unions::SwitchCase_SwitchDefault<'tree>>,
        >,
    > {
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: SwitchCase_SwitchDefault < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for SwitchBody<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "switch_body" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for SwitchBody<'tree> {
    const KIND: &'static str = "switch_body";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `switch_case`\n\nThis node has these fields:\n- `body`: `statement*` ([Statement])\n- `value`: `{expression | sequence_expression}` ([anon_unions::Expression_SequenceExpression])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct SwitchCase<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> SwitchCase<'tree> {
    #[doc = "Get the field `body` which has kind `statement*` ([Statement])"]
    #[allow(dead_code)]
    #[inline]
    pub fn bodys<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, Statement<'tree>>,
        >,
    > + 'a {
        self.0
            .children_by_field_name("body", c)
            .map(|n| <type_sitter_lib::ExtraOr<'tree, Statement<'tree>> as TryFrom<_>>::try_from(n))
    }
    #[doc = "Get the field `value` which has kind `{expression | sequence_expression}` ([anon_unions::Expression_SequenceExpression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn value(
        &self,
    ) -> type_sitter_lib::NodeResult<'tree, anon_unions::Expression_SequenceExpression<'tree>> {
        self . 0 . child_by_field_name ("value") . map (< anon_unions :: Expression_SequenceExpression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for SwitchCase<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "switch_case" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for SwitchCase<'tree> {
    const KIND: &'static str = "switch_case";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `switch_default`\n\nThis node has these fields:\n- `body`: `statement*` ([Statement])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct SwitchDefault<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> SwitchDefault<'tree> {
    #[doc = "Get the field `body` which has kind `statement*` ([Statement])"]
    #[allow(dead_code)]
    #[inline]
    pub fn bodys<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, Statement<'tree>>,
        >,
    > + 'a {
        self.0
            .children_by_field_name("body", c)
            .map(|n| <type_sitter_lib::ExtraOr<'tree, Statement<'tree>> as TryFrom<_>>::try_from(n))
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for SwitchDefault<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "switch_default" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for SwitchDefault<'tree> {
    const KIND: &'static str = "switch_default";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `switch_statement`\n\nThis node has these fields:\n- `body`: `switch_body` ([SwitchBody])\n- `value`: `parenthesized_expression` ([ParenthesizedExpression])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct SwitchStatement<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> SwitchStatement<'tree> {
    #[doc = "Get the field `body` which has kind `switch_body` ([SwitchBody])"]
    #[allow(dead_code)]
    #[inline]
    pub fn body(&self) -> type_sitter_lib::NodeResult<'tree, SwitchBody<'tree>> {
        self . 0 . child_by_field_name ("body") . map (< SwitchBody < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `value` which has kind `parenthesized_expression` ([ParenthesizedExpression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn value(&self) -> type_sitter_lib::NodeResult<'tree, ParenthesizedExpression<'tree>> {
        self . 0 . child_by_field_name ("value") . map (< ParenthesizedExpression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for SwitchStatement<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "switch_statement" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for SwitchStatement<'tree> {
    const KIND: &'static str = "switch_statement";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `template_literal_type`\n\nThis node has children: `template_type*` ([TemplateType])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct TemplateLiteralType<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> TemplateLiteralType<'tree> {
    #[doc = "Get the node's named children"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, TemplateType<'tree>>,
        >,
    > + 'a {
        self.0.named_children(c).map(|n| {
            <type_sitter_lib::ExtraOr<'tree, TemplateType<'tree>> as TryFrom<_>>::try_from(n)
        })
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<'tree, type_sitter_lib::ExtraOr<'tree, TemplateType<'tree>>>,
    > {
        self.0
            .named_child(i)
            .map(<type_sitter_lib::ExtraOr<'tree, TemplateType<'tree>> as TryFrom<_>>::try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for TemplateLiteralType<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "template_literal_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for TemplateLiteralType<'tree> {
    const KIND: &'static str = "template_literal_type";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `template_string`\n\nThis node has children: `{escape_sequence | template_substitution}*`:\n- [EscapeSequence]\n- [TemplateSubstitution]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct TemplateString<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> TemplateString<'tree> {
    #[doc = "Get the node's named children"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::EscapeSequence_TemplateSubstitution<'tree>,
            >,
        >,
    > + 'a {
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: EscapeSequence_TemplateSubstitution < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::EscapeSequence_TemplateSubstitution<'tree>,
            >,
        >,
    > {
        self.0.named_child(i).map(
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::EscapeSequence_TemplateSubstitution<'tree>,
            > as TryFrom<_>>::try_from,
        )
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for TemplateString<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "template_string" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for TemplateString<'tree> {
    const KIND: &'static str = "template_string";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `template_substitution`\n\nThis node has a child: `{expression | sequence_expression}`:\n- [Expression]\n- [SequenceExpression]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct TemplateSubstitution<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> TemplateSubstitution<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
    ) -> type_sitter_lib::NodeResult<'tree, anon_unions::Expression_SequenceExpression<'tree>> {
        self . 0 . named_child (0) . map (< anon_unions :: Expression_SequenceExpression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for TemplateSubstitution<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "template_substitution" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for TemplateSubstitution<'tree> {
    const KIND: &'static str = "template_substitution";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `template_type`\n\nThis node has a child: `{_primary_type | infer_type}`:\n- [PrimaryType]\n- [InferType]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct TemplateType<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> TemplateType<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
    ) -> type_sitter_lib::NodeResult<'tree, anon_unions::PrimaryType_InferType<'tree>> {
        self . 0 . named_child (0) . map (< anon_unions :: PrimaryType_InferType < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for TemplateType<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "template_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for TemplateType<'tree> {
    const KIND: &'static str = "template_type";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `ternary_expression`\n\nThis node has these fields:\n- `alternative`: `expression` ([Expression])\n- `condition`: `expression` ([Expression])\n- `consequence`: `expression` ([Expression])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct TernaryExpression<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> TernaryExpression<'tree> {
    #[doc = "Get the field `alternative` which has kind `expression` ([Expression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn alternative(&self) -> type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        self . 0 . child_by_field_name ("alternative") . map (< Expression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `condition` which has kind `expression` ([Expression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn condition(&self) -> type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        self . 0 . child_by_field_name ("condition") . map (< Expression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `consequence` which has kind `expression` ([Expression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn consequence(&self) -> type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        self . 0 . child_by_field_name ("consequence") . map (< Expression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for TernaryExpression<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "ternary_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for TernaryExpression<'tree> {
    const KIND: &'static str = "ternary_expression";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `this`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct This<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> This<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for This<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "this" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for This<'tree> {
    const KIND: &'static str = "this";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `this_type`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ThisType<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ThisType<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ThisType<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "this_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ThisType<'tree> {
    const KIND: &'static str = "this_type";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `throw_statement`\n\nThis node has a child: `{expression | sequence_expression}`:\n- [Expression]\n- [SequenceExpression]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ThrowStatement<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ThrowStatement<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
    ) -> type_sitter_lib::NodeResult<'tree, anon_unions::Expression_SequenceExpression<'tree>> {
        self . 0 . named_child (0) . map (< anon_unions :: Expression_SequenceExpression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ThrowStatement<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "throw_statement" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ThrowStatement<'tree> {
    const KIND: &'static str = "throw_statement";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `try_statement`\n\nThis node has these fields:\n- `body`: `statement_block` ([StatementBlock])\n- `finalizer`: `finally_clause?` ([FinallyClause])\n- `handler`: `catch_clause?` ([CatchClause])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct TryStatement<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> TryStatement<'tree> {
    #[doc = "Get the field `body` which has kind `statement_block` ([StatementBlock])"]
    #[allow(dead_code)]
    #[inline]
    pub fn body(&self) -> type_sitter_lib::NodeResult<'tree, StatementBlock<'tree>> {
        self . 0 . child_by_field_name ("body") . map (< StatementBlock < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `finalizer` which has kind `finally_clause?` ([FinallyClause])"]
    #[allow(dead_code)]
    #[inline]
    pub fn finalizer(&self) -> Option<type_sitter_lib::NodeResult<'tree, FinallyClause<'tree>>> {
        self.0
            .child_by_field_name("finalizer")
            .map(<FinallyClause<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `handler` which has kind `catch_clause?` ([CatchClause])"]
    #[allow(dead_code)]
    #[inline]
    pub fn handler(&self) -> Option<type_sitter_lib::NodeResult<'tree, CatchClause<'tree>>> {
        self.0
            .child_by_field_name("handler")
            .map(<CatchClause<'tree> as TryFrom<_>>::try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for TryStatement<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "try_statement" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for TryStatement<'tree> {
    const KIND: &'static str = "try_statement";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `tuple_nominal_type`\n\nThis node has children: `{_primary_nominal_type | function_nominal_type | nullable_nominal_type | optional_nominal_type}*`:\n- [PrimaryNominalType]\n- [FunctionNominalType]\n- [NullableNominalType]\n- [OptionalNominalType]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct TupleNominalType<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> TupleNominalType<'tree> {
    #[doc = "Get the node's named children"]
    #[allow(dead_code)]
    #[inline]    pub fn children < 'a > (& self , c : & 'a mut yak_sitter :: TreeCursor < 'tree >) -> impl ExactSizeIterator < Item = type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryNominalType_FunctionNominalType_NullableNominalType_OptionalNominalType < 'tree > > >> + 'a{
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryNominalType_FunctionNominalType_NullableNominalType_OptionalNominalType < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]    pub fn child (& self , i : usize) -> Option < type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryNominalType_FunctionNominalType_NullableNominalType_OptionalNominalType < 'tree > > >>{
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryNominalType_FunctionNominalType_NullableNominalType_OptionalNominalType < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for TupleNominalType<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "tuple_nominal_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for TupleNominalType<'tree> {
    const KIND: &'static str = "tuple_nominal_type";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `tuple_type`\n\nThis node has children: `{_primary_type | constructor_type | function_type | infer_type | optional_parameter | optional_type | readonly_type | required_parameter | rest_type}*`:\n- [PrimaryType]\n- [ConstructorType]\n- [FunctionType]\n- [InferType]\n- [OptionalParameter]\n- [OptionalType]\n- [ReadonlyType]\n- [RequiredParameter]\n- [RestType]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct TupleType<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> TupleType<'tree> {
    #[doc = "Get the node's named children"]
    #[allow(dead_code)]
    #[inline]    pub fn children < 'a > (& self , c : & 'a mut yak_sitter :: TreeCursor < 'tree >) -> impl ExactSizeIterator < Item = type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryType_ConstructorType_FunctionType_InferType_OptionalParameter_OptionalType_ReadonlyType_RequiredParameter_RestType < 'tree > > >> + 'a{
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryType_ConstructorType_FunctionType_InferType_OptionalParameter_OptionalType_ReadonlyType_RequiredParameter_RestType < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]    pub fn child (& self , i : usize) -> Option < type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryType_ConstructorType_FunctionType_InferType_OptionalParameter_OptionalType_ReadonlyType_RequiredParameter_RestType < 'tree > > >>{
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryType_ConstructorType_FunctionType_InferType_OptionalParameter_OptionalType_ReadonlyType_RequiredParameter_RestType < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for TupleType<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "tuple_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for TupleType<'tree> {
    const KIND: &'static str = "tuple_type";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `type_alias_declaration`\n\nThis node has these fields:\n- `name`: `type_identifier` ([TypeIdentifier])\n- `type_parameters`: `type_parameters?` ([TypeParameters])\n- `value`: `{_primary_type | constructor_type | function_type | infer_type | readonly_type}` ([anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct TypeAliasDeclaration<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> TypeAliasDeclaration<'tree> {
    #[doc = "Get the field `name` which has kind `type_identifier` ([TypeIdentifier])"]
    #[allow(dead_code)]
    #[inline]
    pub fn name(&self) -> type_sitter_lib::NodeResult<'tree, TypeIdentifier<'tree>> {
        self . 0 . child_by_field_name ("name") . map (< TypeIdentifier < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `type_parameters` which has kind `type_parameters?` ([TypeParameters])"]
    #[allow(dead_code)]
    #[inline]
    pub fn type_parameters(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, TypeParameters<'tree>>> {
        self.0
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `value` which has kind `{_primary_type | constructor_type | function_type | infer_type | readonly_type}` ([anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType])"]
    #[allow(dead_code)]
    #[inline]
    pub fn value(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
    > {
        self . 0 . child_by_field_name ("value") . map (< anon_unions :: PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for TypeAliasDeclaration<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "type_alias_declaration" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for TypeAliasDeclaration<'tree> {
    const KIND: &'static str = "type_alias_declaration";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `type_annotation`\n\nThis node has a child: `{_primary_type | constructor_type | function_type | infer_type | readonly_type}`:\n- [PrimaryType]\n- [ConstructorType]\n- [FunctionType]\n- [InferType]\n- [ReadonlyType]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct TypeAnnotation<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> TypeAnnotation<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
    > {
        self . 0 . named_child (0) . map (< anon_unions :: PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for TypeAnnotation<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "type_annotation" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for TypeAnnotation<'tree> {
    const KIND: &'static str = "type_annotation";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `type_arguments`\n\nThis node has children: `{_primary_nominal_type | _primary_type | constructor_type | function_nominal_type | function_type | infer_type | nullable_nominal_type | readonly_type}+`:\n- [PrimaryNominalType]\n- [PrimaryType]\n- [ConstructorType]\n- [FunctionNominalType]\n- [FunctionType]\n- [InferType]\n- [NullableNominalType]\n- [ReadonlyType]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct TypeArguments<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> TypeArguments<'tree> {
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]    pub fn children < 'a > (& self , c : & 'a mut yak_sitter :: TreeCursor < 'tree >) -> impl ExactSizeIterator < Item = type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryNominalType_PrimaryType_ConstructorType_FunctionNominalType_FunctionType_InferType_NullableNominalType_ReadonlyType < 'tree > > >> + 'a{
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryNominalType_PrimaryType_ConstructorType_FunctionNominalType_FunctionType_InferType_NullableNominalType_ReadonlyType < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]    pub fn child (& self , i : usize) -> Option < type_sitter_lib :: NodeResult < 'tree , type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryNominalType_PrimaryType_ConstructorType_FunctionNominalType_FunctionType_InferType_NullableNominalType_ReadonlyType < 'tree > > >>{
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: PrimaryNominalType_PrimaryType_ConstructorType_FunctionNominalType_FunctionType_InferType_NullableNominalType_ReadonlyType < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for TypeArguments<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "type_arguments" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for TypeArguments<'tree> {
    const KIND: &'static str = "type_arguments";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `type_assertion`\n\nThis node has children: `{expression | type_arguments}+`:\n- [Expression]\n- [TypeArguments]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct TypeAssertion<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> TypeAssertion<'tree> {
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, anon_unions::Expression_TypeArguments<'tree>>,
        >,
    > + 'a {
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: Expression_TypeArguments < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, anon_unions::Expression_TypeArguments<'tree>>,
        >,
    > {
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: Expression_TypeArguments < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for TypeAssertion<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "type_assertion" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for TypeAssertion<'tree> {
    const KIND: &'static str = "type_assertion";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `type_parameter`\n\nThis node has these fields:\n- `constraint`: `constraint?` ([Constraint])\n- `name`: `type_identifier` ([TypeIdentifier])\n- `value`: `default_type?` ([DefaultType])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct TypeParameter<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> TypeParameter<'tree> {
    #[doc = "Get the field `constraint` which has kind `constraint?` ([Constraint])"]
    #[allow(dead_code)]
    #[inline]
    pub fn constraint(&self) -> Option<type_sitter_lib::NodeResult<'tree, Constraint<'tree>>> {
        self.0
            .child_by_field_name("constraint")
            .map(<Constraint<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `name` which has kind `type_identifier` ([TypeIdentifier])"]
    #[allow(dead_code)]
    #[inline]
    pub fn name(&self) -> type_sitter_lib::NodeResult<'tree, TypeIdentifier<'tree>> {
        self . 0 . child_by_field_name ("name") . map (< TypeIdentifier < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `value` which has kind `default_type?` ([DefaultType])"]
    #[allow(dead_code)]
    #[inline]
    pub fn value(&self) -> Option<type_sitter_lib::NodeResult<'tree, DefaultType<'tree>>> {
        self.0
            .child_by_field_name("value")
            .map(<DefaultType<'tree> as TryFrom<_>>::try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for TypeParameter<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "type_parameter" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for TypeParameter<'tree> {
    const KIND: &'static str = "type_parameter";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `type_parameters`\n\nThis node has children: `{nominal_type_parameter | type_parameter}+`:\n- [NominalTypeParameter]\n- [TypeParameter]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct TypeParameters<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> TypeParameters<'tree> {
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, anon_unions::NominalTypeParameter_TypeParameter<'tree>>,
        >,
    > + 'a {
        self . 0 . named_children (c) . map (| n | < type_sitter_lib :: ExtraOr < 'tree , anon_unions :: NominalTypeParameter_TypeParameter < 'tree > > as TryFrom < _ >> :: try_from (n))
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, anon_unions::NominalTypeParameter_TypeParameter<'tree>>,
        >,
    > {
        self . 0 . named_child (i) . map (< type_sitter_lib :: ExtraOr < 'tree , anon_unions :: NominalTypeParameter_TypeParameter < 'tree > > as TryFrom < _ >> :: try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for TypeParameters<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "type_parameters" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for TypeParameters<'tree> {
    const KIND: &'static str = "type_parameters";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `type_predicate`\n\nThis node has these fields:\n- `name`: `{identifier | this}` ([anon_unions::Identifier_This])\n- `type`: `{_primary_type | constructor_type | function_type | infer_type | readonly_type}` ([anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct TypePredicate<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> TypePredicate<'tree> {
    #[doc = "Get the field `name` which has kind `{identifier | this}` ([anon_unions::Identifier_This])"]
    #[allow(dead_code)]
    #[inline]
    pub fn name(&self) -> type_sitter_lib::NodeResult<'tree, anon_unions::Identifier_This<'tree>> {
        self . 0 . child_by_field_name ("name") . map (< anon_unions :: Identifier_This < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `type` which has kind `{_primary_type | constructor_type | function_type | infer_type | readonly_type}` ([anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType])"]
    #[allow(dead_code)]
    #[inline]
    pub fn r#type(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
    > {
        self . 0 . child_by_field_name ("type") . map (< anon_unions :: PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for TypePredicate<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "type_predicate" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for TypePredicate<'tree> {
    const KIND: &'static str = "type_predicate";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `type_predicate_annotation`\n\nThis node has a child: `type_predicate` ([TypePredicate])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct TypePredicateAnnotation<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> TypePredicateAnnotation<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(&self) -> type_sitter_lib::NodeResult<'tree, TypePredicate<'tree>> {
        self . 0 . named_child (0) . map (< TypePredicate < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for TypePredicateAnnotation<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "type_predicate_annotation" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for TypePredicateAnnotation<'tree> {
    const KIND: &'static str = "type_predicate_annotation";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `type_query`\n\nThis node has a child: `{call_expression | identifier | member_expression | subscript_expression}`:\n- [CallExpression]\n- [Identifier]\n- [MemberExpression]\n- [SubscriptExpression]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct TypeQuery<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> TypeQuery<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::CallExpression_Identifier_MemberExpression_SubscriptExpression<'tree>,
    > {
        self . 0 . named_child (0) . map (< anon_unions :: CallExpression_Identifier_MemberExpression_SubscriptExpression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for TypeQuery<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "type_query" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for TypeQuery<'tree> {
    const KIND: &'static str = "type_query";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `typescript_supertype`\n\nThis node has a child: `{_primary_type | constructor_type | function_type | infer_type | readonly_type}`:\n- [PrimaryType]\n- [ConstructorType]\n- [FunctionType]\n- [InferType]\n- [ReadonlyType]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct TypescriptSupertype<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> TypescriptSupertype<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
    ) -> type_sitter_lib::NodeResult<
        'tree,
        anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
    > {
        self . 0 . named_child (0) . map (< anon_unions :: PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for TypescriptSupertype<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "typescript_supertype" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for TypescriptSupertype<'tree> {
    const KIND: &'static str = "typescript_supertype";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `unary_expression`\n\nThis node has these fields:\n- `argument`: `{expression | number}` ([anon_unions::Expression_Number])\n- `operator`: `{! | + | - | delete | typeof | void | ~}` ([anon_unions::Not_Add_Sub_Delete_Typeof_Void_BitNot])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct UnaryExpression<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> UnaryExpression<'tree> {
    #[doc = "Get the field `argument` which has kind `{expression | number}` ([anon_unions::Expression_Number])"]
    #[allow(dead_code)]
    #[inline]
    pub fn argument(
        &self,
    ) -> type_sitter_lib::NodeResult<'tree, anon_unions::Expression_Number<'tree>> {
        self . 0 . child_by_field_name ("argument") . map (< anon_unions :: Expression_Number < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `operator` which has kind `{! | + | - | delete | typeof | void | ~}` ([anon_unions::Not_Add_Sub_Delete_Typeof_Void_BitNot])"]
    #[allow(dead_code)]
    #[inline]
    pub fn operator(
        &self,
    ) -> type_sitter_lib::NodeResult<'tree, anon_unions::Not_Add_Sub_Delete_Typeof_Void_BitNot<'tree>>
    {
        self . 0 . child_by_field_name ("operator") . map (< anon_unions :: Not_Add_Sub_Delete_Typeof_Void_BitNot < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for UnaryExpression<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "unary_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for UnaryExpression<'tree> {
    const KIND: &'static str = "unary_expression";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `union_type`\n\nThis node has children: `{_primary_type | constructor_type | function_type | infer_type | readonly_type}+`:\n- [PrimaryType]\n- [ConstructorType]\n- [FunctionType]\n- [InferType]\n- [ReadonlyType]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct UnionType<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> UnionType<'tree> {
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
            >,
        >,
    > + 'a {
        self.0.named_children(c).map(|n| {
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
            > as TryFrom<_>>::try_from(n)
        })
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
            >,
        >,
    > {
        self.0.named_child(i).map(
            <type_sitter_lib::ExtraOr<
                'tree,
                anon_unions::PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>,
            > as TryFrom<_>>::try_from,
        )
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for UnionType<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "union_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for UnionType<'tree> {
    const KIND: &'static str = "union_type";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `update_expression`\n\nThis node has these fields:\n- `argument`: `expression` ([Expression])\n- `operator`: `{++ | --}` ([anon_unions::AddAdd_SubSub])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct UpdateExpression<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> UpdateExpression<'tree> {
    #[doc = "Get the field `argument` which has kind `expression` ([Expression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn argument(&self) -> type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        self . 0 . child_by_field_name ("argument") . map (< Expression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `operator` which has kind `{++ | --}` ([anon_unions::AddAdd_SubSub])"]
    #[allow(dead_code)]
    #[inline]
    pub fn operator(
        &self,
    ) -> type_sitter_lib::NodeResult<'tree, anon_unions::AddAdd_SubSub<'tree>> {
        self . 0 . child_by_field_name ("operator") . map (< anon_unions :: AddAdd_SubSub < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for UpdateExpression<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "update_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for UpdateExpression<'tree> {
    const KIND: &'static str = "update_expression";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `variable_declaration`\n\nThis node has children: `variable_declarator+` ([VariableDeclarator])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct VariableDeclaration<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> VariableDeclaration<'tree> {
    #[doc = "Get the node's named children"]
    #[doc = "This is guaranteed to return at least one child"]
    #[allow(dead_code)]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut yak_sitter::TreeCursor<'tree>,
    ) -> impl ExactSizeIterator<
        Item = type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, VariableDeclarator<'tree>>,
        >,
    > + 'a {
        self.0.named_children(c).map(|n| {
            <type_sitter_lib::ExtraOr<'tree, VariableDeclarator<'tree>> as TryFrom<_>>::try_from(n)
        })
    }
    #[doc = "Get the node's named child #i"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(
        &self,
        i: usize,
    ) -> Option<
        type_sitter_lib::NodeResult<
            'tree,
            type_sitter_lib::ExtraOr<'tree, VariableDeclarator<'tree>>,
        >,
    > {
        self.0.named_child(i).map(
            <type_sitter_lib::ExtraOr<'tree, VariableDeclarator<'tree>> as TryFrom<_>>::try_from,
        )
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for VariableDeclaration<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "variable_declaration" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for VariableDeclaration<'tree> {
    const KIND: &'static str = "variable_declaration";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `variable_declarator`\n\nThis node has these fields:\n- `name`: `{array_pattern | identifier | object_pattern}` ([anon_unions::ArrayPattern_Identifier_ObjectPattern])\n- `nominal_type`: `nominal_type_annotation?` ([NominalTypeAnnotation])\n- `type`: `type_annotation?` ([TypeAnnotation])\n- `value`: `expression?` ([Expression])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct VariableDeclarator<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> VariableDeclarator<'tree> {
    #[doc = "Get the field `name` which has kind `{array_pattern | identifier | object_pattern}` ([anon_unions::ArrayPattern_Identifier_ObjectPattern])"]
    #[allow(dead_code)]
    #[inline]
    pub fn name(
        &self,
    ) -> type_sitter_lib::NodeResult<'tree, anon_unions::ArrayPattern_Identifier_ObjectPattern<'tree>>
    {
        self . 0 . child_by_field_name ("name") . map (< anon_unions :: ArrayPattern_Identifier_ObjectPattern < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `nominal_type` which has kind `nominal_type_annotation?` ([NominalTypeAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn nominal_type(
        &self,
    ) -> Option<type_sitter_lib::NodeResult<'tree, NominalTypeAnnotation<'tree>>> {
        self.0
            .child_by_field_name("nominal_type")
            .map(<NominalTypeAnnotation<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `type` which has kind `type_annotation?` ([TypeAnnotation])"]
    #[allow(dead_code)]
    #[inline]
    pub fn r#type(&self) -> Option<type_sitter_lib::NodeResult<'tree, TypeAnnotation<'tree>>> {
        self.0
            .child_by_field_name("type")
            .map(<TypeAnnotation<'tree> as TryFrom<_>>::try_from)
    }
    #[doc = "Get the field `value` which has kind `expression?` ([Expression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn value(&self) -> Option<type_sitter_lib::NodeResult<'tree, Expression<'tree>>> {
        self.0
            .child_by_field_name("value")
            .map(<Expression<'tree> as TryFrom<_>>::try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for VariableDeclarator<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "variable_declarator" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for VariableDeclarator<'tree> {
    const KIND: &'static str = "variable_declarator";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `while_statement`\n\nThis node has these fields:\n- `body`: `statement` ([Statement])\n- `condition`: `parenthesized_expression` ([ParenthesizedExpression])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct WhileStatement<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> WhileStatement<'tree> {
    #[doc = "Get the field `body` which has kind `statement` ([Statement])"]
    #[allow(dead_code)]
    #[inline]
    pub fn body(&self) -> type_sitter_lib::NodeResult<'tree, Statement<'tree>> {
        self . 0 . child_by_field_name ("body") . map (< Statement < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `condition` which has kind `parenthesized_expression` ([ParenthesizedExpression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn condition(&self) -> type_sitter_lib::NodeResult<'tree, ParenthesizedExpression<'tree>> {
        self . 0 . child_by_field_name ("condition") . map (< ParenthesizedExpression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for WhileStatement<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "while_statement" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for WhileStatement<'tree> {
    const KIND: &'static str = "while_statement";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `with_statement`\n\nThis node has these fields:\n- `body`: `statement` ([Statement])\n- `object`: `parenthesized_expression` ([ParenthesizedExpression])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct WithStatement<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> WithStatement<'tree> {
    #[doc = "Get the field `body` which has kind `statement` ([Statement])"]
    #[allow(dead_code)]
    #[inline]
    pub fn body(&self) -> type_sitter_lib::NodeResult<'tree, Statement<'tree>> {
        self . 0 . child_by_field_name ("body") . map (< Statement < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `object` which has kind `parenthesized_expression` ([ParenthesizedExpression])"]
    #[allow(dead_code)]
    #[inline]
    pub fn object(&self) -> type_sitter_lib::NodeResult<'tree, ParenthesizedExpression<'tree>> {
        self . 0 . child_by_field_name ("object") . map (< ParenthesizedExpression < 'tree > as TryFrom < _ >> :: try_from) . expect ("tree-sitter node missing its required child, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for WithStatement<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "with_statement" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for WithStatement<'tree> {
    const KIND: &'static str = "with_statement";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `yield_expression`\n\nThis node has an (optional) child: `expression?` ([Expression])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct YieldExpression<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> YieldExpression<'tree> {
    #[doc = "Get the node's only named child"]
    #[allow(dead_code)]
    #[inline]
    pub fn child(&self) -> Option<type_sitter_lib::NodeResult<'tree, Expression<'tree>>> {
        self.0
            .named_child(0)
            .map(<Expression<'tree> as TryFrom<_>>::try_from)
    }
}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for YieldExpression<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "yield_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for YieldExpression<'tree> {
    const KIND: &'static str = "yield_expression";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `comment`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct Comment<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> Comment<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Comment<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "comment" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for Comment<'tree> {
    const KIND: &'static str = "comment";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `escape_sequence`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct EscapeSequence<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> EscapeSequence<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for EscapeSequence<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "escape_sequence" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for EscapeSequence<'tree> {
    const KIND: &'static str = "escape_sequence";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `false`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct False<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> False<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for False<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "false" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for False<'tree> {
    const KIND: &'static str = "false";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `hash_bang_line`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct HashBangLine<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> HashBangLine<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for HashBangLine<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "hash_bang_line" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for HashBangLine<'tree> {
    const KIND: &'static str = "hash_bang_line";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `jsx_text`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct JsxText<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> JsxText<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for JsxText<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "jsx_text" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for JsxText<'tree> {
    const KIND: &'static str = "jsx_text";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `nominal_type_identifier`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct NominalTypeIdentifier<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> NominalTypeIdentifier<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for NominalTypeIdentifier<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "nominal_type_identifier" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for NominalTypeIdentifier<'tree> {
    const KIND: &'static str = "nominal_type_identifier";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `null`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct Null<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> Null<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Null<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "null" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for Null<'tree> {
    const KIND: &'static str = "null";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `number`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct Number<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> Number<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Number<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "number" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for Number<'tree> {
    const KIND: &'static str = "number";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `private_property_identifier`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct PrivatePropertyIdentifier<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> PrivatePropertyIdentifier<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for PrivatePropertyIdentifier<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "private_property_identifier" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for PrivatePropertyIdentifier<'tree> {
    const KIND: &'static str = "private_property_identifier";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `property_identifier`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct PropertyIdentifier<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> PropertyIdentifier<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for PropertyIdentifier<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "property_identifier" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for PropertyIdentifier<'tree> {
    const KIND: &'static str = "property_identifier";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `regex_flags`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct RegexFlags<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> RegexFlags<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for RegexFlags<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "regex_flags" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for RegexFlags<'tree> {
    const KIND: &'static str = "regex_flags";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `regex_pattern`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct RegexPattern<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> RegexPattern<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for RegexPattern<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "regex_pattern" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for RegexPattern<'tree> {
    const KIND: &'static str = "regex_pattern";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `shorthand_property_identifier`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ShorthandPropertyIdentifier<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ShorthandPropertyIdentifier<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ShorthandPropertyIdentifier<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "shorthand_property_identifier" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ShorthandPropertyIdentifier<'tree> {
    const KIND: &'static str = "shorthand_property_identifier";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `shorthand_property_identifier_pattern`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ShorthandPropertyIdentifierPattern<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> ShorthandPropertyIdentifierPattern<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ShorthandPropertyIdentifierPattern<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "shorthand_property_identifier_pattern" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for ShorthandPropertyIdentifierPattern<'tree> {
    const KIND: &'static str = "shorthand_property_identifier_pattern";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `statement_identifier`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct StatementIdentifier<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> StatementIdentifier<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for StatementIdentifier<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "statement_identifier" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for StatementIdentifier<'tree> {
    const KIND: &'static str = "statement_identifier";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `string_fragment`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct StringFragment<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> StringFragment<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for StringFragment<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "string_fragment" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for StringFragment<'tree> {
    const KIND: &'static str = "string_fragment";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `super`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct Super<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> Super<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Super<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "super" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for Super<'tree> {
    const KIND: &'static str = "super";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `true`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct True<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> True<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for True<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "true" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for True<'tree> {
    const KIND: &'static str = "true";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `type_identifier`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct TypeIdentifier<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> TypeIdentifier<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for TypeIdentifier<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "type_identifier" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for TypeIdentifier<'tree> {
    const KIND: &'static str = "type_identifier";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
#[doc = "Typed node `undefined`\n\nThis node has no children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct Undefined<'tree>(yak_sitter::Node<'tree>);
#[automatically_derived]
impl<'tree> Undefined<'tree> {}
#[automatically_derived]
impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Undefined<'tree> {
    type Error = type_sitter_lib::IncorrectKind<'tree>;
    #[inline]
    fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
        if node.kind() == "undefined" {
            Ok(Self(node))
        } else {
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter_lib::TypedNode<'tree> for Undefined<'tree> {
    const KIND: &'static str = "undefined";
    #[inline]
    fn node(&self) -> &yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_node(self) -> yak_sitter::Node<'tree> {
        self.0
    }
    #[inline]
    unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
        Self(node)
    }
}
pub mod unnamed {
    #[allow(unused_imports)]
    use super::*;
    #[doc = "Typed node `abstract`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Abstract<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Abstract<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Abstract<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "abstract" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Abstract<'tree> {
        const KIND: &'static str = "abstract";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `any`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Any<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Any<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Any<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "any" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Any<'tree> {
        const KIND: &'static str = "any";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `as`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct As<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> As<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for As<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "as" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for As<'tree> {
        const KIND: &'static str = "as";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `asserts`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Asserts<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Asserts<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Asserts<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "asserts" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Asserts<'tree> {
        const KIND: &'static str = "asserts";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `async`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Async<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Async<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Async<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "async" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Async<'tree> {
        const KIND: &'static str = "async";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `await`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Await<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Await<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Await<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "await" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Await<'tree> {
        const KIND: &'static str = "await";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `biv`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Biv<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Biv<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Biv<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "biv" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Biv<'tree> {
        const KIND: &'static str = "biv";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `boolean`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Boolean<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Boolean<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Boolean<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "boolean" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Boolean<'tree> {
        const KIND: &'static str = "boolean";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `break`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Break<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Break<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Break<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "break" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Break<'tree> {
        const KIND: &'static str = "break";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `case`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Case<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Case<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Case<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "case" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Case<'tree> {
        const KIND: &'static str = "case";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `catch`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Catch<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Catch<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Catch<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "catch" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Catch<'tree> {
        const KIND: &'static str = "catch";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `class`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Class<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Class<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Class<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "class" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Class<'tree> {
        const KIND: &'static str = "class";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `con`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Con<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Con<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Con<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "con" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Con<'tree> {
        const KIND: &'static str = "con";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `const`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Const<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Const<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Const<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "const" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Const<'tree> {
        const KIND: &'static str = "const";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `continue`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Continue<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Continue<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Continue<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "continue" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Continue<'tree> {
        const KIND: &'static str = "continue";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `cov`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Cov<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Cov<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Cov<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "cov" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Cov<'tree> {
        const KIND: &'static str = "cov";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `debugger`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Debugger<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Debugger<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Debugger<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "debugger" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Debugger<'tree> {
        const KIND: &'static str = "debugger";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `declare`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Declare<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Declare<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Declare<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "declare" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Declare<'tree> {
        const KIND: &'static str = "declare";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `default`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Default<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Default<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Default<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "default" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Default<'tree> {
        const KIND: &'static str = "default";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `delete`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Delete<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Delete<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Delete<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "delete" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Delete<'tree> {
        const KIND: &'static str = "delete";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `do`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Do<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Do<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Do<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "do" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Do<'tree> {
        const KIND: &'static str = "do";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `else`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Else<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Else<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Else<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "else" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Else<'tree> {
        const KIND: &'static str = "else";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `enum`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Enum<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Enum<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Enum<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "enum" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Enum<'tree> {
        const KIND: &'static str = "enum";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `export`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Export<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Export<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Export<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "export" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Export<'tree> {
        const KIND: &'static str = "export";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `extends`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Extends<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Extends<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Extends<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "extends" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Extends<'tree> {
        const KIND: &'static str = "extends";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `finally`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Finally<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Finally<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Finally<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "finally" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Finally<'tree> {
        const KIND: &'static str = "finally";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `for`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct For<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> For<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for For<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "for" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for For<'tree> {
        const KIND: &'static str = "for";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `from`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct From<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> From<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for From<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "from" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for From<'tree> {
        const KIND: &'static str = "from";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `function`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Function<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Function<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Function<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "function" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Function<'tree> {
        const KIND: &'static str = "function";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `get`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Get<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Get<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Get<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "get" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Get<'tree> {
        const KIND: &'static str = "get";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `global`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Global<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Global<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Global<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "global" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Global<'tree> {
        const KIND: &'static str = "global";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `guard`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Guard<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Guard<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Guard<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "guard" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Guard<'tree> {
        const KIND: &'static str = "guard";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `if`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct If<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> If<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for If<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "if" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for If<'tree> {
        const KIND: &'static str = "if";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `implements`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Implements<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Implements<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Implements<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "implements" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Implements<'tree> {
        const KIND: &'static str = "implements";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `import`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Import<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Import<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Import<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "import" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Import<'tree> {
        const KIND: &'static str = "import";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `in`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct In<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> In<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for In<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "in" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for In<'tree> {
        const KIND: &'static str = "in";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `infer`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Infer<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Infer<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Infer<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "infer" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Infer<'tree> {
        const KIND: &'static str = "infer";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `instanceof`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Instanceof<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Instanceof<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Instanceof<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "instanceof" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Instanceof<'tree> {
        const KIND: &'static str = "instanceof";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `interface`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Interface<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Interface<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Interface<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "interface" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Interface<'tree> {
        const KIND: &'static str = "interface";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `inv`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Inv<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Inv<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Inv<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "inv" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Inv<'tree> {
        const KIND: &'static str = "inv";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `is`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Is<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Is<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Is<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "is" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Is<'tree> {
        const KIND: &'static str = "is";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `keyof`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Keyof<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Keyof<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Keyof<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "keyof" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Keyof<'tree> {
        const KIND: &'static str = "keyof";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `let`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Let<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Let<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Let<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "let" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Let<'tree> {
        const KIND: &'static str = "let";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `module`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Module<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Module<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Module<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "module" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Module<'tree> {
        const KIND: &'static str = "module";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `namespace`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Namespace<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Namespace<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Namespace<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "namespace" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Namespace<'tree> {
        const KIND: &'static str = "namespace";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `never`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Never<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Never<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Never<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "never" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Never<'tree> {
        const KIND: &'static str = "never";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `new`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct New<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> New<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for New<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "new" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for New<'tree> {
        const KIND: &'static str = "new";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `number`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Number<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Number<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Number<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "number" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Number<'tree> {
        const KIND: &'static str = "number";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `object`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Object<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Object<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Object<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "object" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Object<'tree> {
        const KIND: &'static str = "object";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `of`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Of<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Of<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Of<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "of" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Of<'tree> {
        const KIND: &'static str = "of";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `override`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Override<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Override<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Override<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "override" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Override<'tree> {
        const KIND: &'static str = "override";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `private`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Private<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Private<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Private<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "private" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Private<'tree> {
        const KIND: &'static str = "private";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `protected`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Protected<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Protected<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Protected<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "protected" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Protected<'tree> {
        const KIND: &'static str = "protected";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `public`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Public<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Public<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Public<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "public" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Public<'tree> {
        const KIND: &'static str = "public";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `readonly`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Readonly<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Readonly<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Readonly<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "readonly" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Readonly<'tree> {
        const KIND: &'static str = "readonly";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `require`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Require<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Require<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Require<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "require" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Require<'tree> {
        const KIND: &'static str = "require";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `return`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Return<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Return<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Return<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "return" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Return<'tree> {
        const KIND: &'static str = "return";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `satisfies`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Satisfies<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Satisfies<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Satisfies<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "satisfies" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Satisfies<'tree> {
        const KIND: &'static str = "satisfies";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `set`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Set<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Set<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Set<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "set" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Set<'tree> {
        const KIND: &'static str = "set";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `static`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Static<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Static<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Static<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "static" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Static<'tree> {
        const KIND: &'static str = "static";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `string`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct String<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> String<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for String<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "string" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for String<'tree> {
        const KIND: &'static str = "string";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `switch`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Switch<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Switch<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Switch<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "switch" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Switch<'tree> {
        const KIND: &'static str = "switch";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `symbol`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Symbol<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Symbol<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Symbol<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "symbol" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Symbol<'tree> {
        const KIND: &'static str = "symbol";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `target`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Target<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Target<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Target<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "target" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Target<'tree> {
        const KIND: &'static str = "target";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `this`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct This<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> This<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for This<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "this" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for This<'tree> {
        const KIND: &'static str = "this";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `throw`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Throw<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Throw<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Throw<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "throw" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Throw<'tree> {
        const KIND: &'static str = "throw";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `try`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Try<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Try<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Try<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "try" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Try<'tree> {
        const KIND: &'static str = "try";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `type`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Type<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Type<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Type<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "type" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Type<'tree> {
        const KIND: &'static str = "type";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `typeof`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Typeof<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Typeof<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Typeof<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "typeof" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Typeof<'tree> {
        const KIND: &'static str = "typeof";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `unknown`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Unknown<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Unknown<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Unknown<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "unknown" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Unknown<'tree> {
        const KIND: &'static str = "unknown";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `var`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Var<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Var<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Var<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "var" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Var<'tree> {
        const KIND: &'static str = "var";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `void`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Void<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Void<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Void<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "void" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Void<'tree> {
        const KIND: &'static str = "void";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `while`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct While<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> While<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for While<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "while" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for While<'tree> {
        const KIND: &'static str = "while";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `with`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct With<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> With<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for With<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "with" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for With<'tree> {
        const KIND: &'static str = "with";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `yield`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Yield<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Yield<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Yield<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "yield" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Yield<'tree> {
        const KIND: &'static str = "yield";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
}
pub mod symbols {
    #[allow(unused_imports)]
    use super::*;
    #[doc = "Typed node `!`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Not<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Not<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Not<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "!" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Not<'tree> {
        const KIND: &'static str = "!";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `!=`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct NotEq<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> NotEq<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for NotEq<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "!=" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for NotEq<'tree> {
        const KIND: &'static str = "!=";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `!==`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct NotEqEq<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> NotEqEq<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for NotEqEq<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "!==" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for NotEqEq<'tree> {
        const KIND: &'static str = "!==";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `\"`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct DoubleQuote<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> DoubleQuote<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for DoubleQuote<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "\"" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for DoubleQuote<'tree> {
        const KIND: &'static str = "\"";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `${`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct DollarLBrace<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> DollarLBrace<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for DollarLBrace<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "${" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for DollarLBrace<'tree> {
        const KIND: &'static str = "${";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `%`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Mod<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Mod<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Mod<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "%" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Mod<'tree> {
        const KIND: &'static str = "%";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `%=`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct ModEq<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> ModEq<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ModEq<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "%=" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for ModEq<'tree> {
        const KIND: &'static str = "%=";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `&`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct And<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> And<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for And<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "&" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for And<'tree> {
        const KIND: &'static str = "&";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `&&`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct AndAnd<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> AndAnd<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for AndAnd<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "&&" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for AndAnd<'tree> {
        const KIND: &'static str = "&&";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `&&=`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct AndAndEq<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> AndAndEq<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for AndAndEq<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "&&=" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for AndAndEq<'tree> {
        const KIND: &'static str = "&&=";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `&=`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct AndEq<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> AndEq<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for AndEq<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "&=" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for AndEq<'tree> {
        const KIND: &'static str = "&=";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `'`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Quote<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Quote<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Quote<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "'" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Quote<'tree> {
        const KIND: &'static str = "'";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `(`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct LParen<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> LParen<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for LParen<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "(" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for LParen<'tree> {
        const KIND: &'static str = "(";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `)`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct RParen<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> RParen<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for RParen<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == ")" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for RParen<'tree> {
        const KIND: &'static str = ")";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `*`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Mul<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Mul<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Mul<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "*" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Mul<'tree> {
        const KIND: &'static str = "*";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `**`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct MulMul<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> MulMul<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for MulMul<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "**" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for MulMul<'tree> {
        const KIND: &'static str = "**";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `**=`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct MulMulEq<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> MulMulEq<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for MulMulEq<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "**=" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for MulMulEq<'tree> {
        const KIND: &'static str = "**=";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `*=`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct MulEq<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> MulEq<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for MulEq<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "*=" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for MulEq<'tree> {
        const KIND: &'static str = "*=";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `+`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Add<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Add<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Add<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "+" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Add<'tree> {
        const KIND: &'static str = "+";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `++`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct AddAdd<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> AddAdd<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for AddAdd<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "++" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for AddAdd<'tree> {
        const KIND: &'static str = "++";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `+=`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct AddEq<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> AddEq<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for AddEq<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "+=" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for AddEq<'tree> {
        const KIND: &'static str = "+=";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `,`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Comma<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Comma<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Comma<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "," {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Comma<'tree> {
        const KIND: &'static str = ",";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `-`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Sub<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Sub<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Sub<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "-" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Sub<'tree> {
        const KIND: &'static str = "-";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `--`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct SubSub<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> SubSub<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for SubSub<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "--" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for SubSub<'tree> {
        const KIND: &'static str = "--";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `-=`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct SubEq<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> SubEq<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for SubEq<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "-=" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for SubEq<'tree> {
        const KIND: &'static str = "-=";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `-?:`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct SubQuestionColon<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> SubQuestionColon<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for SubQuestionColon<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "-?:" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for SubQuestionColon<'tree> {
        const KIND: &'static str = "-?:";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `.`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Dot<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Dot<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Dot<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "." {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Dot<'tree> {
        const KIND: &'static str = ".";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `...`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct DotDotDot<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> DotDotDot<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for DotDotDot<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "..." {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for DotDotDot<'tree> {
        const KIND: &'static str = "...";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `/`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Div<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Div<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Div<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "/" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Div<'tree> {
        const KIND: &'static str = "/";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `/=`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct DivEq<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> DivEq<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for DivEq<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "/=" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for DivEq<'tree> {
        const KIND: &'static str = "/=";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `:`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Colon<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Colon<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Colon<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == ":" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Colon<'tree> {
        const KIND: &'static str = ":";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `;`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Semicolon<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Semicolon<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Semicolon<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == ";" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Semicolon<'tree> {
        const KIND: &'static str = ";";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `<`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Lt<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Lt<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Lt<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "<" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Lt<'tree> {
        const KIND: &'static str = "<";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `</template>`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct LtDivtemplateGt<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> LtDivtemplateGt<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for LtDivtemplateGt<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "</template>" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for LtDivtemplateGt<'tree> {
        const KIND: &'static str = "</template>";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `<:`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct LtColon<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> LtColon<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for LtColon<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "<:" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for LtColon<'tree> {
        const KIND: &'static str = "<:";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `<<`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct LtLt<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> LtLt<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for LtLt<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "<<" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for LtLt<'tree> {
        const KIND: &'static str = "<<";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `<<=`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct LtLtEq<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> LtLtEq<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for LtLtEq<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "<<=" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for LtLtEq<'tree> {
        const KIND: &'static str = "<<=";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `<=`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct LtEq<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> LtEq<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for LtEq<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "<=" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for LtEq<'tree> {
        const KIND: &'static str = "<=";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `<template>`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct LttemplateGt<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> LttemplateGt<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for LttemplateGt<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "<template>" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for LttemplateGt<'tree> {
        const KIND: &'static str = "<template>";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `=`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Eq<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Eq<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Eq<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "=" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Eq<'tree> {
        const KIND: &'static str = "=";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `==`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct EqEq<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> EqEq<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for EqEq<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "==" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for EqEq<'tree> {
        const KIND: &'static str = "==";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `===`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct EqEqEq<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> EqEqEq<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for EqEqEq<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "===" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for EqEqEq<'tree> {
        const KIND: &'static str = "===";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `=>`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct EqGt<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> EqGt<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for EqGt<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "=>" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for EqGt<'tree> {
        const KIND: &'static str = "=>";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `>`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Gt<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Gt<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Gt<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == ">" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Gt<'tree> {
        const KIND: &'static str = ">";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `>=`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct GtEq<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> GtEq<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for GtEq<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == ">=" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for GtEq<'tree> {
        const KIND: &'static str = ">=";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `>>`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct GtGt<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> GtGt<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for GtGt<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == ">>" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for GtGt<'tree> {
        const KIND: &'static str = ">>";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `>>=`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct GtGtEq<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> GtGtEq<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for GtGtEq<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == ">>=" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for GtGtEq<'tree> {
        const KIND: &'static str = ">>=";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `>>>`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct GtGtGt<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> GtGtGt<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for GtGtGt<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == ">>>" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for GtGtGt<'tree> {
        const KIND: &'static str = ">>>";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `>>>=`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct GtGtGtEq<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> GtGtGtEq<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for GtGtGtEq<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == ">>>=" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for GtGtGtEq<'tree> {
        const KIND: &'static str = ">>>=";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `?`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Question<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Question<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Question<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "?" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Question<'tree> {
        const KIND: &'static str = "?";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `?.`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct QuestionDot<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> QuestionDot<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for QuestionDot<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "?." {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for QuestionDot<'tree> {
        const KIND: &'static str = "?.";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `?:`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct QuestionColon<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> QuestionColon<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for QuestionColon<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "?:" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for QuestionColon<'tree> {
        const KIND: &'static str = "?:";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `??`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct QuestionQuestion<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> QuestionQuestion<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for QuestionQuestion<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "??" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for QuestionQuestion<'tree> {
        const KIND: &'static str = "??";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `??=`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct QuestionQuestionEq<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> QuestionQuestionEq<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for QuestionQuestionEq<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "??=" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for QuestionQuestionEq<'tree> {
        const KIND: &'static str = "??=";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `@`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct At<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> At<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for At<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "@" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for At<'tree> {
        const KIND: &'static str = "@";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `[`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct LBracket<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> LBracket<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for LBracket<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "[" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for LBracket<'tree> {
        const KIND: &'static str = "[";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `]`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct RBracket<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> RBracket<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for RBracket<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "]" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for RBracket<'tree> {
        const KIND: &'static str = "]";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `^`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct BitXor<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> BitXor<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for BitXor<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "^" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for BitXor<'tree> {
        const KIND: &'static str = "^";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `^=`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct BitXorEq<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> BitXorEq<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for BitXorEq<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "^=" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for BitXorEq<'tree> {
        const KIND: &'static str = "^=";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node ```\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Backtick<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Backtick<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Backtick<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "`" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Backtick<'tree> {
        const KIND: &'static str = "`";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `{`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct LBrace<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> LBrace<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for LBrace<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "{" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for LBrace<'tree> {
        const KIND: &'static str = "{";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `{|`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct LBraceOr<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> LBraceOr<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for LBraceOr<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "{|" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for LBraceOr<'tree> {
        const KIND: &'static str = "{|";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `|`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Or<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> Or<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Or<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "|" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Or<'tree> {
        const KIND: &'static str = "|";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `|=`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct OrEq<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> OrEq<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for OrEq<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "|=" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for OrEq<'tree> {
        const KIND: &'static str = "|=";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `||`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct OrOr<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> OrOr<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for OrOr<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "||" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for OrOr<'tree> {
        const KIND: &'static str = "||";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `||=`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct OrOrEq<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> OrOrEq<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for OrOrEq<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "||=" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for OrOrEq<'tree> {
        const KIND: &'static str = "||=";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `|}`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct OrRBrace<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> OrRBrace<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for OrRBrace<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "|}" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for OrRBrace<'tree> {
        const KIND: &'static str = "|}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `}`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct RBrace<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> RBrace<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for RBrace<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "}" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for RBrace<'tree> {
        const KIND: &'static str = "}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
    #[doc = "Typed node `~`\n\nThis node has no children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct BitNot<'tree>(yak_sitter::Node<'tree>);
    #[automatically_derived]
    impl<'tree> BitNot<'tree> {}
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for BitNot<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if node.kind() == "~" {
                Ok(Self(node))
            } else {
                Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                })
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for BitNot<'tree> {
        const KIND: &'static str = "~";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            self.0
        }
        #[inline]
        unsafe fn from_node_unchecked(node: yak_sitter::Node<'tree>) -> Self {
            Self(node)
        }
    }
}
pub mod anon_unions {
    #[allow(unused_imports)]
    use super::*;
    #[doc = "one of `{class_heritage | class_body | decorator | type_identifier | type_parameters}`:\n- [ClassHeritage]\n- [ClassBody]\n- [Decorator]\n- [TypeIdentifier]\n- [TypeParameters]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum ClassHeritage_ClassBody_Decorator_TypeIdentifier_TypeParameters<'tree> {
        ClassHeritage(ClassHeritage<'tree>),
        ClassBody(ClassBody<'tree>),
        Decorator(Decorator<'tree>),
        TypeIdentifier(TypeIdentifier<'tree>),
        TypeParameters(TypeParameters<'tree>),
    }
    #[automatically_derived]
    impl<'tree> ClassHeritage_ClassBody_Decorator_TypeIdentifier_TypeParameters<'tree> {
        #[doc = "Returns the node if it is of kind `class_heritage` ([ClassHeritage]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn class_heritage(self) -> Option<ClassHeritage<'tree>> {
            match self {
                Self::ClassHeritage(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `class_body` ([ClassBody]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn class_body(self) -> Option<ClassBody<'tree>> {
            match self {
                Self::ClassBody(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `decorator` ([Decorator]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn decorator(self) -> Option<Decorator<'tree>> {
            match self {
                Self::Decorator(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `type_identifier` ([TypeIdentifier]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn type_identifier(self) -> Option<TypeIdentifier<'tree>> {
            match self {
                Self::TypeIdentifier(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `type_parameters` ([TypeParameters]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn type_parameters(self) -> Option<TypeParameters<'tree>> {
            match self {
                Self::TypeParameters(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>>
        for ClassHeritage_ClassBody_Decorator_TypeIdentifier_TypeParameters<'tree>
    {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "class_heritage" => Ok(unsafe {
                    Self::ClassHeritage(<ClassHeritage<'tree> as type_sitter_lib::TypedNode<
                        'tree,
                    >>::from_node_unchecked(node))
                }),
                "class_body" => Ok(unsafe {
                    Self :: ClassBody (< ClassBody < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "decorator" => Ok(unsafe {
                    Self :: Decorator (< Decorator < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "type_identifier" => {
                    Ok(unsafe {
                        Self :: TypeIdentifier (< TypeIdentifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                "type_parameters" => {
                    Ok(unsafe {
                        Self :: TypeParameters (< TypeParameters < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree>
        for ClassHeritage_ClassBody_Decorator_TypeIdentifier_TypeParameters<'tree>
    {
        const KIND: &'static str =
            "{class_heritage | class_body | decorator | type_identifier | type_parameters}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::ClassHeritage(x) => x.node(),
                Self::ClassBody(x) => x.node(),
                Self::Decorator(x) => x.node(),
                Self::TypeIdentifier(x) => x.node(),
                Self::TypeParameters(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::ClassHeritage(x) => x.node_mut(),
                Self::ClassBody(x) => x.node_mut(),
                Self::Decorator(x) => x.node_mut(),
                Self::TypeIdentifier(x) => x.node_mut(),
                Self::TypeParameters(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::ClassHeritage(x) => x.into_node(),
                Self::ClassBody(x) => x.into_node(),
                Self::Decorator(x) => x.into_node(),
                Self::TypeIdentifier(x) => x.into_node(),
                Self::TypeParameters(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{accessibility_modifier | computed_property_name | number | private_property_identifier | property_identifier | string | nominal_type_annotation | formal_parameters | asserts | type_annotation | type_predicate_annotation | type_parameters}`:\n- [AccessibilityModifier]\n- [ComputedPropertyName]\n- [Number]\n- [PrivatePropertyIdentifier]\n- [PropertyIdentifier]\n- [String]\n- [NominalTypeAnnotation]\n- [FormalParameters]\n- [Asserts]\n- [TypeAnnotation]\n- [TypePredicateAnnotation]\n- [TypeParameters]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AccessibilityModifier_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_FormalParameters_Asserts_TypeAnnotation_TypePredicateAnnotation_TypeParameters<
        'tree,
    > {
        AccessibilityModifier(AccessibilityModifier<'tree>),
        ComputedPropertyName(ComputedPropertyName<'tree>),
        Number(Number<'tree>),
        PrivatePropertyIdentifier(PrivatePropertyIdentifier<'tree>),
        PropertyIdentifier(PropertyIdentifier<'tree>),
        String(String<'tree>),
        NominalTypeAnnotation(NominalTypeAnnotation<'tree>),
        FormalParameters(FormalParameters<'tree>),
        Asserts(Asserts<'tree>),
        TypeAnnotation(TypeAnnotation<'tree>),
        TypePredicateAnnotation(TypePredicateAnnotation<'tree>),
        TypeParameters(TypeParameters<'tree>),
    }
    #[automatically_derived]
    impl < 'tree > AccessibilityModifier_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_FormalParameters_Asserts_TypeAnnotation_TypePredicateAnnotation_TypeParameters < 'tree > { # [doc = "Returns the node if it is of kind `accessibility_modifier` ([AccessibilityModifier]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn accessibility_modifier (self) -> Option < AccessibilityModifier < 'tree > > { match self { Self :: AccessibilityModifier (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `computed_property_name` ([ComputedPropertyName]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn computed_property_name (self) -> Option < ComputedPropertyName < 'tree > > { match self { Self :: ComputedPropertyName (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `number` ([Number]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn number (self) -> Option < Number < 'tree > > { match self { Self :: Number (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `private_property_identifier` ([PrivatePropertyIdentifier]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn private_property_identifier (self) -> Option < PrivatePropertyIdentifier < 'tree > > { match self { Self :: PrivatePropertyIdentifier (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `property_identifier` ([PropertyIdentifier]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn property_identifier (self) -> Option < PropertyIdentifier < 'tree > > { match self { Self :: PropertyIdentifier (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `string` ([String]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn string (self) -> Option < String < 'tree > > { match self { Self :: String (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `nominal_type_annotation` ([NominalTypeAnnotation]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn nominal_type_annotation (self) -> Option < NominalTypeAnnotation < 'tree > > { match self { Self :: NominalTypeAnnotation (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `formal_parameters` ([FormalParameters]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn formal_parameters (self) -> Option < FormalParameters < 'tree > > { match self { Self :: FormalParameters (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `asserts` ([Asserts]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn asserts (self) -> Option < Asserts < 'tree > > { match self { Self :: Asserts (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `type_annotation` ([TypeAnnotation]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn type_annotation (self) -> Option < TypeAnnotation < 'tree > > { match self { Self :: TypeAnnotation (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `type_predicate_annotation` ([TypePredicateAnnotation]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn type_predicate_annotation (self) -> Option < TypePredicateAnnotation < 'tree > > { match self { Self :: TypePredicateAnnotation (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `type_parameters` ([TypeParameters]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn type_parameters (self) -> Option < TypeParameters < 'tree > > { match self { Self :: TypeParameters (x) => Some (x) , _ => None , } } }
    #[automatically_derived]
    impl < 'tree > TryFrom < yak_sitter :: Node < 'tree >> for AccessibilityModifier_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_FormalParameters_Asserts_TypeAnnotation_TypePredicateAnnotation_TypeParameters < 'tree > { type Error = type_sitter_lib :: IncorrectKind < 'tree > ; # [inline] fn try_from (node : yak_sitter :: Node < 'tree >) -> Result < Self , Self :: Error > { match node . kind () { "accessibility_modifier" => Ok (unsafe { Self :: AccessibilityModifier (< AccessibilityModifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "computed_property_name" => Ok (unsafe { Self :: ComputedPropertyName (< ComputedPropertyName < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "number" => Ok (unsafe { Self :: Number (< Number < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "private_property_identifier" => Ok (unsafe { Self :: PrivatePropertyIdentifier (< PrivatePropertyIdentifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "property_identifier" => Ok (unsafe { Self :: PropertyIdentifier (< PropertyIdentifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "string" => Ok (unsafe { Self :: String (< String < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "nominal_type_annotation" => Ok (unsafe { Self :: NominalTypeAnnotation (< NominalTypeAnnotation < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "formal_parameters" => Ok (unsafe { Self :: FormalParameters (< FormalParameters < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "asserts" => Ok (unsafe { Self :: Asserts (< Asserts < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "type_annotation" => Ok (unsafe { Self :: TypeAnnotation (< TypeAnnotation < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "type_predicate_annotation" => Ok (unsafe { Self :: TypePredicateAnnotation (< TypePredicateAnnotation < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "type_parameters" => Ok (unsafe { Self :: TypeParameters (< TypeParameters < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , _ => Err (type_sitter_lib :: IncorrectKind { node , kind : < Self as type_sitter_lib :: TypedNode < 'tree >> :: KIND , }) } } }
    #[automatically_derived]
    impl < 'tree > type_sitter_lib :: TypedNode < 'tree > for AccessibilityModifier_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_FormalParameters_Asserts_TypeAnnotation_TypePredicateAnnotation_TypeParameters < 'tree > { const KIND : & 'static str = "{accessibility_modifier | computed_property_name | number | private_property_identifier | property_identifier | string | nominal_type_annotation | formal_parameters | asserts | type_annotation | type_predicate_annotation | type_parameters}" ; # [inline] fn node (& self) -> & yak_sitter :: Node < 'tree > { match self { Self :: AccessibilityModifier (x) => x . node () , Self :: ComputedPropertyName (x) => x . node () , Self :: Number (x) => x . node () , Self :: PrivatePropertyIdentifier (x) => x . node () , Self :: PropertyIdentifier (x) => x . node () , Self :: String (x) => x . node () , Self :: NominalTypeAnnotation (x) => x . node () , Self :: FormalParameters (x) => x . node () , Self :: Asserts (x) => x . node () , Self :: TypeAnnotation (x) => x . node () , Self :: TypePredicateAnnotation (x) => x . node () , Self :: TypeParameters (x) => x . node () , } } # [inline] fn node_mut (& mut self) -> & mut yak_sitter :: Node < 'tree > { match self { Self :: AccessibilityModifier (x) => x . node_mut () , Self :: ComputedPropertyName (x) => x . node_mut () , Self :: Number (x) => x . node_mut () , Self :: PrivatePropertyIdentifier (x) => x . node_mut () , Self :: PropertyIdentifier (x) => x . node_mut () , Self :: String (x) => x . node_mut () , Self :: NominalTypeAnnotation (x) => x . node_mut () , Self :: FormalParameters (x) => x . node_mut () , Self :: Asserts (x) => x . node_mut () , Self :: TypeAnnotation (x) => x . node_mut () , Self :: TypePredicateAnnotation (x) => x . node_mut () , Self :: TypeParameters (x) => x . node_mut () , } } # [inline] fn into_node (self) -> yak_sitter :: Node < 'tree > { match self { Self :: AccessibilityModifier (x) => x . into_node () , Self :: ComputedPropertyName (x) => x . into_node () , Self :: Number (x) => x . into_node () , Self :: PrivatePropertyIdentifier (x) => x . into_node () , Self :: PropertyIdentifier (x) => x . into_node () , Self :: String (x) => x . into_node () , Self :: NominalTypeAnnotation (x) => x . into_node () , Self :: FormalParameters (x) => x . into_node () , Self :: Asserts (x) => x . into_node () , Self :: TypeAnnotation (x) => x . into_node () , Self :: TypePredicateAnnotation (x) => x . into_node () , Self :: TypeParameters (x) => x . into_node () , } } }
    #[doc = "one of `{computed_property_name | number | private_property_identifier | property_identifier | string}`:\n- [ComputedPropertyName]\n- [Number]\n- [PrivatePropertyIdentifier]\n- [PropertyIdentifier]\n- [String]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String<'tree> {
        ComputedPropertyName(ComputedPropertyName<'tree>),
        Number(Number<'tree>),
        PrivatePropertyIdentifier(PrivatePropertyIdentifier<'tree>),
        PropertyIdentifier(PropertyIdentifier<'tree>),
        String(String<'tree>),
    }
    #[automatically_derived]
    impl<'tree> ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String<'tree> {
        #[doc = "Returns the node if it is of kind `computed_property_name` ([ComputedPropertyName]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn computed_property_name(self) -> Option<ComputedPropertyName<'tree>> {
            match self {
                Self::ComputedPropertyName(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `number` ([Number]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn number(self) -> Option<Number<'tree>> {
            match self {
                Self::Number(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `private_property_identifier` ([PrivatePropertyIdentifier]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn private_property_identifier(self) -> Option<PrivatePropertyIdentifier<'tree>> {
            match self {
                Self::PrivatePropertyIdentifier(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `property_identifier` ([PropertyIdentifier]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn property_identifier(self) -> Option<PropertyIdentifier<'tree>> {
            match self {
                Self::PropertyIdentifier(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `string` ([String]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn string(self) -> Option<String<'tree>> {
            match self {
                Self::String(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>>
        for ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String<'tree>
    {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "computed_property_name" => Ok(unsafe {
                    Self :: ComputedPropertyName (< ComputedPropertyName < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "number" => {
                    Ok(unsafe {
                        Self :: Number (< Number < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                "private_property_identifier" => Ok(unsafe {
                    Self :: PrivatePropertyIdentifier (< PrivatePropertyIdentifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "property_identifier" => Ok(unsafe {
                    Self :: PropertyIdentifier (< PropertyIdentifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "string" => {
                    Ok(unsafe {
                        Self :: String (< String < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree>
        for ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String<'tree>
    {
        const KIND : & 'static str = "{computed_property_name | number | private_property_identifier | property_identifier | string}" ;
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::ComputedPropertyName(x) => x.node(),
                Self::Number(x) => x.node(),
                Self::PrivatePropertyIdentifier(x) => x.node(),
                Self::PropertyIdentifier(x) => x.node(),
                Self::String(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::ComputedPropertyName(x) => x.node_mut(),
                Self::Number(x) => x.node_mut(),
                Self::PrivatePropertyIdentifier(x) => x.node_mut(),
                Self::PropertyIdentifier(x) => x.node_mut(),
                Self::String(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::ComputedPropertyName(x) => x.into_node(),
                Self::Number(x) => x.into_node(),
                Self::PrivatePropertyIdentifier(x) => x.into_node(),
                Self::PropertyIdentifier(x) => x.into_node(),
                Self::String(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{asserts | type_annotation | type_predicate_annotation}`:\n- [Asserts]\n- [TypeAnnotation]\n- [TypePredicateAnnotation]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Asserts_TypeAnnotation_TypePredicateAnnotation<'tree> {
        Asserts(Asserts<'tree>),
        TypeAnnotation(TypeAnnotation<'tree>),
        TypePredicateAnnotation(TypePredicateAnnotation<'tree>),
    }
    #[automatically_derived]
    impl<'tree> Asserts_TypeAnnotation_TypePredicateAnnotation<'tree> {
        #[doc = "Returns the node if it is of kind `asserts` ([Asserts]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn asserts(self) -> Option<Asserts<'tree>> {
            match self {
                Self::Asserts(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `type_annotation` ([TypeAnnotation]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn type_annotation(self) -> Option<TypeAnnotation<'tree>> {
            match self {
                Self::TypeAnnotation(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `type_predicate_annotation` ([TypePredicateAnnotation]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn type_predicate_annotation(self) -> Option<TypePredicateAnnotation<'tree>> {
            match self {
                Self::TypePredicateAnnotation(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>>
        for Asserts_TypeAnnotation_TypePredicateAnnotation<'tree>
    {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "asserts" => {
                    Ok(unsafe {
                        Self :: Asserts (< Asserts < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                "type_annotation" => {
                    Ok(unsafe {
                        Self :: TypeAnnotation (< TypeAnnotation < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                "type_predicate_annotation" => Ok(unsafe {
                    Self :: TypePredicateAnnotation (< TypePredicateAnnotation < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree>
        for Asserts_TypeAnnotation_TypePredicateAnnotation<'tree>
    {
        const KIND: &'static str = "{asserts | type_annotation | type_predicate_annotation}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::Asserts(x) => x.node(),
                Self::TypeAnnotation(x) => x.node(),
                Self::TypePredicateAnnotation(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::Asserts(x) => x.node_mut(),
                Self::TypeAnnotation(x) => x.node_mut(),
                Self::TypePredicateAnnotation(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::Asserts(x) => x.into_node(),
                Self::TypeAnnotation(x) => x.into_node(),
                Self::TypePredicateAnnotation(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{_primary_type | constructor_type | declaration | function_type | infer_type | property_identifier | readonly_type | statement_block}`:\n- [PrimaryType]\n- [ConstructorType]\n- [Declaration]\n- [FunctionType]\n- [InferType]\n- [PropertyIdentifier]\n- [ReadonlyType]\n- [StatementBlock]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum PrimaryType_ConstructorType_Declaration_FunctionType_InferType_PropertyIdentifier_ReadonlyType_StatementBlock<
        'tree,
    > {
        PrimaryType(PrimaryType<'tree>),
        ConstructorType(ConstructorType<'tree>),
        Declaration(Declaration<'tree>),
        FunctionType(FunctionType<'tree>),
        InferType(InferType<'tree>),
        PropertyIdentifier(PropertyIdentifier<'tree>),
        ReadonlyType(ReadonlyType<'tree>),
        StatementBlock(StatementBlock<'tree>),
    }
    #[automatically_derived]
    impl < 'tree > PrimaryType_ConstructorType_Declaration_FunctionType_InferType_PropertyIdentifier_ReadonlyType_StatementBlock < 'tree > { # [doc = "Returns the node if it is of kind `_primary_type` ([PrimaryType]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn primary_type (self) -> Option < PrimaryType < 'tree > > { match self { Self :: PrimaryType (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `constructor_type` ([ConstructorType]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn constructor_type (self) -> Option < ConstructorType < 'tree > > { match self { Self :: ConstructorType (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `declaration` ([Declaration]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn declaration (self) -> Option < Declaration < 'tree > > { match self { Self :: Declaration (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `function_type` ([FunctionType]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn function_type (self) -> Option < FunctionType < 'tree > > { match self { Self :: FunctionType (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `infer_type` ([InferType]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn infer_type (self) -> Option < InferType < 'tree > > { match self { Self :: InferType (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `property_identifier` ([PropertyIdentifier]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn property_identifier (self) -> Option < PropertyIdentifier < 'tree > > { match self { Self :: PropertyIdentifier (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `readonly_type` ([ReadonlyType]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn readonly_type (self) -> Option < ReadonlyType < 'tree > > { match self { Self :: ReadonlyType (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `statement_block` ([StatementBlock]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn statement_block (self) -> Option < StatementBlock < 'tree > > { match self { Self :: StatementBlock (x) => Some (x) , _ => None , } } }
    #[automatically_derived]
    impl < 'tree > TryFrom < yak_sitter :: Node < 'tree >> for PrimaryType_ConstructorType_Declaration_FunctionType_InferType_PropertyIdentifier_ReadonlyType_StatementBlock < 'tree > { type Error = type_sitter_lib :: IncorrectKind < 'tree > ; # [inline] fn try_from (node : yak_sitter :: Node < 'tree >) -> Result < Self , Self :: Error > { if let Ok (this) = < PrimaryType < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: PrimaryType (this)) ; } if let Ok (this) = < ConstructorType < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: ConstructorType (this)) ; } if let Ok (this) = < Declaration < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: Declaration (this)) ; } if let Ok (this) = < FunctionType < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: FunctionType (this)) ; } if let Ok (this) = < InferType < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: InferType (this)) ; } if let Ok (this) = < PropertyIdentifier < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: PropertyIdentifier (this)) ; } if let Ok (this) = < ReadonlyType < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: ReadonlyType (this)) ; } if let Ok (this) = < StatementBlock < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: StatementBlock (this)) ; } Err (type_sitter_lib :: IncorrectKind { node , kind : < Self as type_sitter_lib :: TypedNode < 'tree >> :: KIND , }) } }
    #[automatically_derived]
    impl < 'tree > type_sitter_lib :: TypedNode < 'tree > for PrimaryType_ConstructorType_Declaration_FunctionType_InferType_PropertyIdentifier_ReadonlyType_StatementBlock < 'tree > { const KIND : & 'static str = "{_primary_type | constructor_type | declaration | function_type | infer_type | property_identifier | readonly_type | statement_block}" ; # [inline] fn node (& self) -> & yak_sitter :: Node < 'tree > { match self { Self :: PrimaryType (x) => x . node () , Self :: ConstructorType (x) => x . node () , Self :: Declaration (x) => x . node () , Self :: FunctionType (x) => x . node () , Self :: InferType (x) => x . node () , Self :: PropertyIdentifier (x) => x . node () , Self :: ReadonlyType (x) => x . node () , Self :: StatementBlock (x) => x . node () , } } # [inline] fn node_mut (& mut self) -> & mut yak_sitter :: Node < 'tree > { match self { Self :: PrimaryType (x) => x . node_mut () , Self :: ConstructorType (x) => x . node_mut () , Self :: Declaration (x) => x . node_mut () , Self :: FunctionType (x) => x . node_mut () , Self :: InferType (x) => x . node_mut () , Self :: PropertyIdentifier (x) => x . node_mut () , Self :: ReadonlyType (x) => x . node_mut () , Self :: StatementBlock (x) => x . node_mut () , } } # [inline] fn into_node (self) -> yak_sitter :: Node < 'tree > { match self { Self :: PrimaryType (x) => x . into_node () , Self :: ConstructorType (x) => x . into_node () , Self :: Declaration (x) => x . into_node () , Self :: FunctionType (x) => x . into_node () , Self :: InferType (x) => x . into_node () , Self :: PropertyIdentifier (x) => x . into_node () , Self :: ReadonlyType (x) => x . into_node () , Self :: StatementBlock (x) => x . into_node () , } } }
    #[doc = "one of `{expression | spread_element}`:\n- [Expression]\n- [SpreadElement]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Expression_SpreadElement<'tree> {
        Expression(Expression<'tree>),
        SpreadElement(SpreadElement<'tree>),
    }
    #[automatically_derived]
    impl<'tree> Expression_SpreadElement<'tree> {
        #[doc = "Returns the node if it is of kind `expression` ([Expression]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn expression(self) -> Option<Expression<'tree>> {
            match self {
                Self::Expression(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `spread_element` ([SpreadElement]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn spread_element(self) -> Option<SpreadElement<'tree>> {
            match self {
                Self::SpreadElement(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Expression_SpreadElement<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "expression" => Ok(unsafe {
                    Self :: Expression (< Expression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "spread_element" => Ok(unsafe {
                    Self::SpreadElement(<SpreadElement<'tree> as type_sitter_lib::TypedNode<
                        'tree,
                    >>::from_node_unchecked(node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Expression_SpreadElement<'tree> {
        const KIND: &'static str = "{expression | spread_element}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => x.node(),
                Self::SpreadElement(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => x.node_mut(),
                Self::SpreadElement(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => x.into_node(),
                Self::SpreadElement(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{assignment_pattern | pattern}`:\n- [AssignmentPattern]\n- [Pattern]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AssignmentPattern_Pattern<'tree> {
        AssignmentPattern(AssignmentPattern<'tree>),
        Pattern(Pattern<'tree>),
    }
    #[automatically_derived]
    impl<'tree> AssignmentPattern_Pattern<'tree> {
        #[doc = "Returns the node if it is of kind `assignment_pattern` ([AssignmentPattern]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn assignment_pattern(self) -> Option<AssignmentPattern<'tree>> {
            match self {
                Self::AssignmentPattern(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `pattern` ([Pattern]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn pattern(self) -> Option<Pattern<'tree>> {
            match self {
                Self::Pattern(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for AssignmentPattern_Pattern<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "assignment_pattern" => Ok(unsafe {
                    Self :: AssignmentPattern (< AssignmentPattern < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "pattern" => {
                    Ok(unsafe {
                        Self :: Pattern (< Pattern < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for AssignmentPattern_Pattern<'tree> {
        const KIND: &'static str = "{assignment_pattern | pattern}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::AssignmentPattern(x) => x.node(),
                Self::Pattern(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::AssignmentPattern(x) => x.node_mut(),
                Self::Pattern(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::AssignmentPattern(x) => x.into_node(),
                Self::Pattern(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{expression | statement_block}`:\n- [Expression]\n- [StatementBlock]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Expression_StatementBlock<'tree> {
        Expression(Expression<'tree>),
        StatementBlock(StatementBlock<'tree>),
    }
    #[automatically_derived]
    impl<'tree> Expression_StatementBlock<'tree> {
        #[doc = "Returns the node if it is of kind `expression` ([Expression]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn expression(self) -> Option<Expression<'tree>> {
            match self {
                Self::Expression(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `statement_block` ([StatementBlock]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn statement_block(self) -> Option<StatementBlock<'tree>> {
            match self {
                Self::StatementBlock(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Expression_StatementBlock<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "expression" => Ok(unsafe {
                    Self :: Expression (< Expression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "statement_block" => {
                    Ok(unsafe {
                        Self :: StatementBlock (< StatementBlock < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Expression_StatementBlock<'tree> {
        const KIND: &'static str = "{expression | statement_block}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => x.node(),
                Self::StatementBlock(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => x.node_mut(),
                Self::StatementBlock(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => x.into_node(),
                Self::StatementBlock(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{_primary_type | constructor_type | expression | function_type | infer_type | readonly_type}`:\n- [PrimaryType]\n- [ConstructorType]\n- [Expression]\n- [FunctionType]\n- [InferType]\n- [ReadonlyType]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum PrimaryType_ConstructorType_Expression_FunctionType_InferType_ReadonlyType<'tree> {
        PrimaryType(PrimaryType<'tree>),
        ConstructorType(ConstructorType<'tree>),
        Expression(Expression<'tree>),
        FunctionType(FunctionType<'tree>),
        InferType(InferType<'tree>),
        ReadonlyType(ReadonlyType<'tree>),
    }
    #[automatically_derived]
    impl<'tree> PrimaryType_ConstructorType_Expression_FunctionType_InferType_ReadonlyType<'tree> {
        #[doc = "Returns the node if it is of kind `_primary_type` ([PrimaryType]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn primary_type(self) -> Option<PrimaryType<'tree>> {
            match self {
                Self::PrimaryType(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `constructor_type` ([ConstructorType]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn constructor_type(self) -> Option<ConstructorType<'tree>> {
            match self {
                Self::ConstructorType(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `expression` ([Expression]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn expression(self) -> Option<Expression<'tree>> {
            match self {
                Self::Expression(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `function_type` ([FunctionType]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn function_type(self) -> Option<FunctionType<'tree>> {
            match self {
                Self::FunctionType(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `infer_type` ([InferType]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn infer_type(self) -> Option<InferType<'tree>> {
            match self {
                Self::InferType(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `readonly_type` ([ReadonlyType]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn readonly_type(self) -> Option<ReadonlyType<'tree>> {
            match self {
                Self::ReadonlyType(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>>
        for PrimaryType_ConstructorType_Expression_FunctionType_InferType_ReadonlyType<'tree>
    {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if let Ok(this) = <PrimaryType<'tree> as TryFrom<_>>::try_from(node) {
                return Ok(Self::PrimaryType(this));
            }
            if let Ok(this) = <ConstructorType<'tree> as TryFrom<_>>::try_from(node) {
                return Ok(Self::ConstructorType(this));
            }
            if let Ok(this) = <Expression<'tree> as TryFrom<_>>::try_from(node) {
                return Ok(Self::Expression(this));
            }
            if let Ok(this) = <FunctionType<'tree> as TryFrom<_>>::try_from(node) {
                return Ok(Self::FunctionType(this));
            }
            if let Ok(this) = <InferType<'tree> as TryFrom<_>>::try_from(node) {
                return Ok(Self::InferType(this));
            }
            if let Ok(this) = <ReadonlyType<'tree> as TryFrom<_>>::try_from(node) {
                return Ok(Self::ReadonlyType(this));
            }
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree>
        for PrimaryType_ConstructorType_Expression_FunctionType_InferType_ReadonlyType<'tree>
    {
        const KIND : & 'static str = "{_primary_type | constructor_type | expression | function_type | infer_type | readonly_type}" ;
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::PrimaryType(x) => x.node(),
                Self::ConstructorType(x) => x.node(),
                Self::Expression(x) => x.node(),
                Self::FunctionType(x) => x.node(),
                Self::InferType(x) => x.node(),
                Self::ReadonlyType(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::PrimaryType(x) => x.node_mut(),
                Self::ConstructorType(x) => x.node_mut(),
                Self::Expression(x) => x.node_mut(),
                Self::FunctionType(x) => x.node_mut(),
                Self::InferType(x) => x.node_mut(),
                Self::ReadonlyType(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::PrimaryType(x) => x.into_node(),
                Self::ConstructorType(x) => x.into_node(),
                Self::Expression(x) => x.into_node(),
                Self::FunctionType(x) => x.into_node(),
                Self::InferType(x) => x.into_node(),
                Self::ReadonlyType(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{identifier | this | type_predicate}`:\n- [Identifier]\n- [This]\n- [TypePredicate]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Identifier_This_TypePredicate<'tree> {
        Identifier(Identifier<'tree>),
        This(This<'tree>),
        TypePredicate(TypePredicate<'tree>),
    }
    #[automatically_derived]
    impl<'tree> Identifier_This_TypePredicate<'tree> {
        #[doc = "Returns the node if it is of kind `identifier` ([Identifier]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn identifier(self) -> Option<Identifier<'tree>> {
            match self {
                Self::Identifier(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `this` ([This]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn this(self) -> Option<This<'tree>> {
            match self {
                Self::This(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `type_predicate` ([TypePredicate]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn type_predicate(self) -> Option<TypePredicate<'tree>> {
            match self {
                Self::TypePredicate(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Identifier_This_TypePredicate<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "identifier" => Ok(unsafe {
                    Self :: Identifier (< Identifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "this" => Ok(unsafe {
                    Self::This(
                        <This<'tree> as type_sitter_lib::TypedNode<'tree>>::from_node_unchecked(
                            node,
                        ),
                    )
                }),
                "type_predicate" => Ok(unsafe {
                    Self::TypePredicate(<TypePredicate<'tree> as type_sitter_lib::TypedNode<
                        'tree,
                    >>::from_node_unchecked(node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Identifier_This_TypePredicate<'tree> {
        const KIND: &'static str = "{identifier | this | type_predicate}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => x.node(),
                Self::This(x) => x.node(),
                Self::TypePredicate(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => x.node_mut(),
                Self::This(x) => x.node_mut(),
                Self::TypePredicate(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => x.into_node(),
                Self::This(x) => x.into_node(),
                Self::TypePredicate(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{array_pattern | identifier | member_expression | non_null_expression | object_pattern | parenthesized_expression | subscript_expression | undefined}`:\n- [ArrayPattern]\n- [Identifier]\n- [MemberExpression]\n- [NonNullExpression]\n- [ObjectPattern]\n- [ParenthesizedExpression]\n- [SubscriptExpression]\n- [Undefined]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum ArrayPattern_Identifier_MemberExpression_NonNullExpression_ObjectPattern_ParenthesizedExpression_SubscriptExpression_Undefined<
        'tree,
    > {
        ArrayPattern(ArrayPattern<'tree>),
        Identifier(Identifier<'tree>),
        MemberExpression(MemberExpression<'tree>),
        NonNullExpression(NonNullExpression<'tree>),
        ObjectPattern(ObjectPattern<'tree>),
        ParenthesizedExpression(ParenthesizedExpression<'tree>),
        SubscriptExpression(SubscriptExpression<'tree>),
        Undefined(Undefined<'tree>),
    }
    #[automatically_derived]
    impl < 'tree > ArrayPattern_Identifier_MemberExpression_NonNullExpression_ObjectPattern_ParenthesizedExpression_SubscriptExpression_Undefined < 'tree > { # [doc = "Returns the node if it is of kind `array_pattern` ([ArrayPattern]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn array_pattern (self) -> Option < ArrayPattern < 'tree > > { match self { Self :: ArrayPattern (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `identifier` ([Identifier]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn identifier (self) -> Option < Identifier < 'tree > > { match self { Self :: Identifier (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `member_expression` ([MemberExpression]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn member_expression (self) -> Option < MemberExpression < 'tree > > { match self { Self :: MemberExpression (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `non_null_expression` ([NonNullExpression]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn non_null_expression (self) -> Option < NonNullExpression < 'tree > > { match self { Self :: NonNullExpression (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `object_pattern` ([ObjectPattern]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn object_pattern (self) -> Option < ObjectPattern < 'tree > > { match self { Self :: ObjectPattern (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `parenthesized_expression` ([ParenthesizedExpression]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn parenthesized_expression (self) -> Option < ParenthesizedExpression < 'tree > > { match self { Self :: ParenthesizedExpression (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `subscript_expression` ([SubscriptExpression]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn subscript_expression (self) -> Option < SubscriptExpression < 'tree > > { match self { Self :: SubscriptExpression (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `undefined` ([Undefined]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn undefined (self) -> Option < Undefined < 'tree > > { match self { Self :: Undefined (x) => Some (x) , _ => None , } } }
    #[automatically_derived]
    impl < 'tree > TryFrom < yak_sitter :: Node < 'tree >> for ArrayPattern_Identifier_MemberExpression_NonNullExpression_ObjectPattern_ParenthesizedExpression_SubscriptExpression_Undefined < 'tree > { type Error = type_sitter_lib :: IncorrectKind < 'tree > ; # [inline] fn try_from (node : yak_sitter :: Node < 'tree >) -> Result < Self , Self :: Error > { match node . kind () { "array_pattern" => Ok (unsafe { Self :: ArrayPattern (< ArrayPattern < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "identifier" => Ok (unsafe { Self :: Identifier (< Identifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "member_expression" => Ok (unsafe { Self :: MemberExpression (< MemberExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "non_null_expression" => Ok (unsafe { Self :: NonNullExpression (< NonNullExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "object_pattern" => Ok (unsafe { Self :: ObjectPattern (< ObjectPattern < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "parenthesized_expression" => Ok (unsafe { Self :: ParenthesizedExpression (< ParenthesizedExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "subscript_expression" => Ok (unsafe { Self :: SubscriptExpression (< SubscriptExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "undefined" => Ok (unsafe { Self :: Undefined (< Undefined < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , _ => Err (type_sitter_lib :: IncorrectKind { node , kind : < Self as type_sitter_lib :: TypedNode < 'tree >> :: KIND , }) } } }
    #[automatically_derived]
    impl < 'tree > type_sitter_lib :: TypedNode < 'tree > for ArrayPattern_Identifier_MemberExpression_NonNullExpression_ObjectPattern_ParenthesizedExpression_SubscriptExpression_Undefined < 'tree > { const KIND : & 'static str = "{array_pattern | identifier | member_expression | non_null_expression | object_pattern | parenthesized_expression | subscript_expression | undefined}" ; # [inline] fn node (& self) -> & yak_sitter :: Node < 'tree > { match self { Self :: ArrayPattern (x) => x . node () , Self :: Identifier (x) => x . node () , Self :: MemberExpression (x) => x . node () , Self :: NonNullExpression (x) => x . node () , Self :: ObjectPattern (x) => x . node () , Self :: ParenthesizedExpression (x) => x . node () , Self :: SubscriptExpression (x) => x . node () , Self :: Undefined (x) => x . node () , } } # [inline] fn node_mut (& mut self) -> & mut yak_sitter :: Node < 'tree > { match self { Self :: ArrayPattern (x) => x . node_mut () , Self :: Identifier (x) => x . node_mut () , Self :: MemberExpression (x) => x . node_mut () , Self :: NonNullExpression (x) => x . node_mut () , Self :: ObjectPattern (x) => x . node_mut () , Self :: ParenthesizedExpression (x) => x . node_mut () , Self :: SubscriptExpression (x) => x . node_mut () , Self :: Undefined (x) => x . node_mut () , } } # [inline] fn into_node (self) -> yak_sitter :: Node < 'tree > { match self { Self :: ArrayPattern (x) => x . into_node () , Self :: Identifier (x) => x . into_node () , Self :: MemberExpression (x) => x . into_node () , Self :: NonNullExpression (x) => x . into_node () , Self :: ObjectPattern (x) => x . into_node () , Self :: ParenthesizedExpression (x) => x . into_node () , Self :: SubscriptExpression (x) => x . into_node () , Self :: Undefined (x) => x . into_node () , } } }
    #[doc = "one of `{identifier | member_expression | non_null_expression | parenthesized_expression | subscript_expression}`:\n- [Identifier]\n- [MemberExpression]\n- [NonNullExpression]\n- [ParenthesizedExpression]\n- [SubscriptExpression]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Identifier_MemberExpression_NonNullExpression_ParenthesizedExpression_SubscriptExpression<
        'tree,
    > {
        Identifier(Identifier<'tree>),
        MemberExpression(MemberExpression<'tree>),
        NonNullExpression(NonNullExpression<'tree>),
        ParenthesizedExpression(ParenthesizedExpression<'tree>),
        SubscriptExpression(SubscriptExpression<'tree>),
    }
    #[automatically_derived]
    impl<'tree>
        Identifier_MemberExpression_NonNullExpression_ParenthesizedExpression_SubscriptExpression<
            'tree,
        >
    {
        #[doc = "Returns the node if it is of kind `identifier` ([Identifier]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn identifier(self) -> Option<Identifier<'tree>> {
            match self {
                Self::Identifier(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `member_expression` ([MemberExpression]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn member_expression(self) -> Option<MemberExpression<'tree>> {
            match self {
                Self::MemberExpression(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `non_null_expression` ([NonNullExpression]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn non_null_expression(self) -> Option<NonNullExpression<'tree>> {
            match self {
                Self::NonNullExpression(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `parenthesized_expression` ([ParenthesizedExpression]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn parenthesized_expression(self) -> Option<ParenthesizedExpression<'tree>> {
            match self {
                Self::ParenthesizedExpression(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `subscript_expression` ([SubscriptExpression]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn subscript_expression(self) -> Option<SubscriptExpression<'tree>> {
            match self {
                Self::SubscriptExpression(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl < 'tree > TryFrom < yak_sitter :: Node < 'tree >> for Identifier_MemberExpression_NonNullExpression_ParenthesizedExpression_SubscriptExpression < 'tree > { type Error = type_sitter_lib :: IncorrectKind < 'tree > ; # [inline] fn try_from (node : yak_sitter :: Node < 'tree >) -> Result < Self , Self :: Error > { match node . kind () { "identifier" => Ok (unsafe { Self :: Identifier (< Identifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "member_expression" => Ok (unsafe { Self :: MemberExpression (< MemberExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "non_null_expression" => Ok (unsafe { Self :: NonNullExpression (< NonNullExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "parenthesized_expression" => Ok (unsafe { Self :: ParenthesizedExpression (< ParenthesizedExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "subscript_expression" => Ok (unsafe { Self :: SubscriptExpression (< SubscriptExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , _ => Err (type_sitter_lib :: IncorrectKind { node , kind : < Self as type_sitter_lib :: TypedNode < 'tree >> :: KIND , }) } } }
    #[automatically_derived]
    impl < 'tree > type_sitter_lib :: TypedNode < 'tree > for Identifier_MemberExpression_NonNullExpression_ParenthesizedExpression_SubscriptExpression < 'tree > { const KIND : & 'static str = "{identifier | member_expression | non_null_expression | parenthesized_expression | subscript_expression}" ; # [inline] fn node (& self) -> & yak_sitter :: Node < 'tree > { match self { Self :: Identifier (x) => x . node () , Self :: MemberExpression (x) => x . node () , Self :: NonNullExpression (x) => x . node () , Self :: ParenthesizedExpression (x) => x . node () , Self :: SubscriptExpression (x) => x . node () , } } # [inline] fn node_mut (& mut self) -> & mut yak_sitter :: Node < 'tree > { match self { Self :: Identifier (x) => x . node_mut () , Self :: MemberExpression (x) => x . node_mut () , Self :: NonNullExpression (x) => x . node_mut () , Self :: ParenthesizedExpression (x) => x . node_mut () , Self :: SubscriptExpression (x) => x . node_mut () , } } # [inline] fn into_node (self) -> yak_sitter :: Node < 'tree > { match self { Self :: Identifier (x) => x . into_node () , Self :: MemberExpression (x) => x . into_node () , Self :: NonNullExpression (x) => x . into_node () , Self :: ParenthesizedExpression (x) => x . into_node () , Self :: SubscriptExpression (x) => x . into_node () , } } }
    #[doc = "one of `{%= | &&= | &= | **= | *= | += | -= | /= | <<= | >>= | >>>= | ??= | ^= | |= | ||=}`:\n- [symbols::ModEq]\n- [symbols::AndAndEq]\n- [symbols::AndEq]\n- [symbols::MulMulEq]\n- [symbols::MulEq]\n- [symbols::AddEq]\n- [symbols::SubEq]\n- [symbols::DivEq]\n- [symbols::LtLtEq]\n- [symbols::GtGtEq]\n- [symbols::GtGtGtEq]\n- [symbols::QuestionQuestionEq]\n- [symbols::BitXorEq]\n- [symbols::OrEq]\n- [symbols::OrOrEq]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum ModEq_AndAndEq_AndEq_MulMulEq_MulEq_AddEq_SubEq_DivEq_LtLtEq_GtGtEq_GtGtGtEq_QuestionQuestionEq_BitXorEq_OrEq_OrOrEq<
        'tree,
    > {
        ModEq(symbols::ModEq<'tree>),
        AndAndEq(symbols::AndAndEq<'tree>),
        AndEq(symbols::AndEq<'tree>),
        MulMulEq(symbols::MulMulEq<'tree>),
        MulEq(symbols::MulEq<'tree>),
        AddEq(symbols::AddEq<'tree>),
        SubEq(symbols::SubEq<'tree>),
        DivEq(symbols::DivEq<'tree>),
        LtLtEq(symbols::LtLtEq<'tree>),
        GtGtEq(symbols::GtGtEq<'tree>),
        GtGtGtEq(symbols::GtGtGtEq<'tree>),
        QuestionQuestionEq(symbols::QuestionQuestionEq<'tree>),
        BitXorEq(symbols::BitXorEq<'tree>),
        OrEq(symbols::OrEq<'tree>),
        OrOrEq(symbols::OrOrEq<'tree>),
    }
    #[automatically_derived]
    impl < 'tree > ModEq_AndAndEq_AndEq_MulMulEq_MulEq_AddEq_SubEq_DivEq_LtLtEq_GtGtEq_GtGtGtEq_QuestionQuestionEq_BitXorEq_OrEq_OrOrEq < 'tree > { # [doc = "Returns the node if it is of kind `%=` ([symbols::ModEq]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn mod_eq (self) -> Option < symbols :: ModEq < 'tree > > { match self { Self :: ModEq (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `&&=` ([symbols::AndAndEq]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn and_and_eq (self) -> Option < symbols :: AndAndEq < 'tree > > { match self { Self :: AndAndEq (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `&=` ([symbols::AndEq]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn and_eq (self) -> Option < symbols :: AndEq < 'tree > > { match self { Self :: AndEq (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `**=` ([symbols::MulMulEq]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn mul_mul_eq (self) -> Option < symbols :: MulMulEq < 'tree > > { match self { Self :: MulMulEq (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `*=` ([symbols::MulEq]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn mul_eq (self) -> Option < symbols :: MulEq < 'tree > > { match self { Self :: MulEq (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `+=` ([symbols::AddEq]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn add_eq (self) -> Option < symbols :: AddEq < 'tree > > { match self { Self :: AddEq (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `-=` ([symbols::SubEq]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn sub_eq (self) -> Option < symbols :: SubEq < 'tree > > { match self { Self :: SubEq (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `/=` ([symbols::DivEq]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn div_eq (self) -> Option < symbols :: DivEq < 'tree > > { match self { Self :: DivEq (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `<<=` ([symbols::LtLtEq]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn lt_lt_eq (self) -> Option < symbols :: LtLtEq < 'tree > > { match self { Self :: LtLtEq (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `>>=` ([symbols::GtGtEq]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn gt_gt_eq (self) -> Option < symbols :: GtGtEq < 'tree > > { match self { Self :: GtGtEq (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `>>>=` ([symbols::GtGtGtEq]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn gt_gt_gt_eq (self) -> Option < symbols :: GtGtGtEq < 'tree > > { match self { Self :: GtGtGtEq (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `??=` ([symbols::QuestionQuestionEq]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn question_question_eq (self) -> Option < symbols :: QuestionQuestionEq < 'tree > > { match self { Self :: QuestionQuestionEq (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `^=` ([symbols::BitXorEq]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn bit_xor_eq (self) -> Option < symbols :: BitXorEq < 'tree > > { match self { Self :: BitXorEq (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `|=` ([symbols::OrEq]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn or_eq (self) -> Option < symbols :: OrEq < 'tree > > { match self { Self :: OrEq (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `||=` ([symbols::OrOrEq]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn or_or_eq (self) -> Option < symbols :: OrOrEq < 'tree > > { match self { Self :: OrOrEq (x) => Some (x) , _ => None , } } }
    #[automatically_derived]
    impl < 'tree > TryFrom < yak_sitter :: Node < 'tree >> for ModEq_AndAndEq_AndEq_MulMulEq_MulEq_AddEq_SubEq_DivEq_LtLtEq_GtGtEq_GtGtGtEq_QuestionQuestionEq_BitXorEq_OrEq_OrOrEq < 'tree > { type Error = type_sitter_lib :: IncorrectKind < 'tree > ; # [inline] fn try_from (node : yak_sitter :: Node < 'tree >) -> Result < Self , Self :: Error > { match node . kind () { "%=" => Ok (unsafe { Self :: ModEq (< symbols :: ModEq < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "&&=" => Ok (unsafe { Self :: AndAndEq (< symbols :: AndAndEq < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "&=" => Ok (unsafe { Self :: AndEq (< symbols :: AndEq < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "**=" => Ok (unsafe { Self :: MulMulEq (< symbols :: MulMulEq < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "*=" => Ok (unsafe { Self :: MulEq (< symbols :: MulEq < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "+=" => Ok (unsafe { Self :: AddEq (< symbols :: AddEq < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "-=" => Ok (unsafe { Self :: SubEq (< symbols :: SubEq < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "/=" => Ok (unsafe { Self :: DivEq (< symbols :: DivEq < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "<<=" => Ok (unsafe { Self :: LtLtEq (< symbols :: LtLtEq < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , ">>=" => Ok (unsafe { Self :: GtGtEq (< symbols :: GtGtEq < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , ">>>=" => Ok (unsafe { Self :: GtGtGtEq (< symbols :: GtGtGtEq < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "??=" => Ok (unsafe { Self :: QuestionQuestionEq (< symbols :: QuestionQuestionEq < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "^=" => Ok (unsafe { Self :: BitXorEq (< symbols :: BitXorEq < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "|=" => Ok (unsafe { Self :: OrEq (< symbols :: OrEq < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "||=" => Ok (unsafe { Self :: OrOrEq (< symbols :: OrOrEq < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , _ => Err (type_sitter_lib :: IncorrectKind { node , kind : < Self as type_sitter_lib :: TypedNode < 'tree >> :: KIND , }) } } }
    #[automatically_derived]
    impl < 'tree > type_sitter_lib :: TypedNode < 'tree > for ModEq_AndAndEq_AndEq_MulMulEq_MulEq_AddEq_SubEq_DivEq_LtLtEq_GtGtEq_GtGtGtEq_QuestionQuestionEq_BitXorEq_OrEq_OrOrEq < 'tree > { const KIND : & 'static str = "{%= | &&= | &= | **= | *= | += | -= | /= | <<= | >>= | >>>= | ??= | ^= | |= | ||=}" ; # [inline] fn node (& self) -> & yak_sitter :: Node < 'tree > { match self { Self :: ModEq (x) => x . node () , Self :: AndAndEq (x) => x . node () , Self :: AndEq (x) => x . node () , Self :: MulMulEq (x) => x . node () , Self :: MulEq (x) => x . node () , Self :: AddEq (x) => x . node () , Self :: SubEq (x) => x . node () , Self :: DivEq (x) => x . node () , Self :: LtLtEq (x) => x . node () , Self :: GtGtEq (x) => x . node () , Self :: GtGtGtEq (x) => x . node () , Self :: QuestionQuestionEq (x) => x . node () , Self :: BitXorEq (x) => x . node () , Self :: OrEq (x) => x . node () , Self :: OrOrEq (x) => x . node () , } } # [inline] fn node_mut (& mut self) -> & mut yak_sitter :: Node < 'tree > { match self { Self :: ModEq (x) => x . node_mut () , Self :: AndAndEq (x) => x . node_mut () , Self :: AndEq (x) => x . node_mut () , Self :: MulMulEq (x) => x . node_mut () , Self :: MulEq (x) => x . node_mut () , Self :: AddEq (x) => x . node_mut () , Self :: SubEq (x) => x . node_mut () , Self :: DivEq (x) => x . node_mut () , Self :: LtLtEq (x) => x . node_mut () , Self :: GtGtEq (x) => x . node_mut () , Self :: GtGtGtEq (x) => x . node_mut () , Self :: QuestionQuestionEq (x) => x . node_mut () , Self :: BitXorEq (x) => x . node_mut () , Self :: OrEq (x) => x . node_mut () , Self :: OrOrEq (x) => x . node_mut () , } } # [inline] fn into_node (self) -> yak_sitter :: Node < 'tree > { match self { Self :: ModEq (x) => x . into_node () , Self :: AndAndEq (x) => x . into_node () , Self :: AndEq (x) => x . into_node () , Self :: MulMulEq (x) => x . into_node () , Self :: MulEq (x) => x . into_node () , Self :: AddEq (x) => x . into_node () , Self :: SubEq (x) => x . into_node () , Self :: DivEq (x) => x . into_node () , Self :: LtLtEq (x) => x . into_node () , Self :: GtGtEq (x) => x . into_node () , Self :: GtGtGtEq (x) => x . into_node () , Self :: QuestionQuestionEq (x) => x . into_node () , Self :: BitXorEq (x) => x . into_node () , Self :: OrEq (x) => x . into_node () , Self :: OrOrEq (x) => x . into_node () , } } }
    #[doc = "one of `{!= | !== | % | & | && | * | ** | + | - | / | < | << | <= | == | === | > | >= | >> | >>> | ?? | ^ | in | instanceof | | | ||}`:\n- [symbols::NotEq]\n- [symbols::NotEqEq]\n- [symbols::Mod]\n- [symbols::And]\n- [symbols::AndAnd]\n- [symbols::Mul]\n- [symbols::MulMul]\n- [symbols::Add]\n- [symbols::Sub]\n- [symbols::Div]\n- [symbols::Lt]\n- [symbols::LtLt]\n- [symbols::LtEq]\n- [symbols::EqEq]\n- [symbols::EqEqEq]\n- [symbols::Gt]\n- [symbols::GtEq]\n- [symbols::GtGt]\n- [symbols::GtGtGt]\n- [symbols::QuestionQuestion]\n- [symbols::BitXor]\n- [unnamed::In]\n- [unnamed::Instanceof]\n- [symbols::Or]\n- [symbols::OrOr]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum NotEq_NotEqEq_Mod_And_AndAnd_Mul_MulMul_Add_Sub_Div_Lt_LtLt_LtEq_EqEq_EqEqEq_Gt_GtEq_GtGt_GtGtGt_QuestionQuestion_BitXor_In_Instanceof_Or_OrOr<
        'tree,
    > {
        NotEq(symbols::NotEq<'tree>),
        NotEqEq(symbols::NotEqEq<'tree>),
        Mod(symbols::Mod<'tree>),
        And(symbols::And<'tree>),
        AndAnd(symbols::AndAnd<'tree>),
        Mul(symbols::Mul<'tree>),
        MulMul(symbols::MulMul<'tree>),
        Add(symbols::Add<'tree>),
        Sub(symbols::Sub<'tree>),
        Div(symbols::Div<'tree>),
        Lt(symbols::Lt<'tree>),
        LtLt(symbols::LtLt<'tree>),
        LtEq(symbols::LtEq<'tree>),
        EqEq(symbols::EqEq<'tree>),
        EqEqEq(symbols::EqEqEq<'tree>),
        Gt(symbols::Gt<'tree>),
        GtEq(symbols::GtEq<'tree>),
        GtGt(symbols::GtGt<'tree>),
        GtGtGt(symbols::GtGtGt<'tree>),
        QuestionQuestion(symbols::QuestionQuestion<'tree>),
        BitXor(symbols::BitXor<'tree>),
        In(unnamed::In<'tree>),
        Instanceof(unnamed::Instanceof<'tree>),
        Or(symbols::Or<'tree>),
        OrOr(symbols::OrOr<'tree>),
    }
    #[automatically_derived]
    impl < 'tree > NotEq_NotEqEq_Mod_And_AndAnd_Mul_MulMul_Add_Sub_Div_Lt_LtLt_LtEq_EqEq_EqEqEq_Gt_GtEq_GtGt_GtGtGt_QuestionQuestion_BitXor_In_Instanceof_Or_OrOr < 'tree > { # [doc = "Returns the node if it is of kind `!=` ([symbols::NotEq]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn not_eq (self) -> Option < symbols :: NotEq < 'tree > > { match self { Self :: NotEq (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `!==` ([symbols::NotEqEq]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn not_eq_eq (self) -> Option < symbols :: NotEqEq < 'tree > > { match self { Self :: NotEqEq (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `%` ([symbols::Mod]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn r#mod (self) -> Option < symbols :: Mod < 'tree > > { match self { Self :: Mod (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `&` ([symbols::And]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn and (self) -> Option < symbols :: And < 'tree > > { match self { Self :: And (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `&&` ([symbols::AndAnd]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn and_and (self) -> Option < symbols :: AndAnd < 'tree > > { match self { Self :: AndAnd (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `*` ([symbols::Mul]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn mul (self) -> Option < symbols :: Mul < 'tree > > { match self { Self :: Mul (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `**` ([symbols::MulMul]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn mul_mul (self) -> Option < symbols :: MulMul < 'tree > > { match self { Self :: MulMul (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `+` ([symbols::Add]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn add (self) -> Option < symbols :: Add < 'tree > > { match self { Self :: Add (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `-` ([symbols::Sub]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn sub (self) -> Option < symbols :: Sub < 'tree > > { match self { Self :: Sub (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `/` ([symbols::Div]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn div (self) -> Option < symbols :: Div < 'tree > > { match self { Self :: Div (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `<` ([symbols::Lt]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn lt (self) -> Option < symbols :: Lt < 'tree > > { match self { Self :: Lt (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `<<` ([symbols::LtLt]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn lt_lt (self) -> Option < symbols :: LtLt < 'tree > > { match self { Self :: LtLt (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `<=` ([symbols::LtEq]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn lt_eq (self) -> Option < symbols :: LtEq < 'tree > > { match self { Self :: LtEq (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `==` ([symbols::EqEq]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn eq_eq (self) -> Option < symbols :: EqEq < 'tree > > { match self { Self :: EqEq (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `===` ([symbols::EqEqEq]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn eq_eq_eq (self) -> Option < symbols :: EqEqEq < 'tree > > { match self { Self :: EqEqEq (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `>` ([symbols::Gt]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn gt (self) -> Option < symbols :: Gt < 'tree > > { match self { Self :: Gt (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `>=` ([symbols::GtEq]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn gt_eq (self) -> Option < symbols :: GtEq < 'tree > > { match self { Self :: GtEq (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `>>` ([symbols::GtGt]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn gt_gt (self) -> Option < symbols :: GtGt < 'tree > > { match self { Self :: GtGt (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `>>>` ([symbols::GtGtGt]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn gt_gt_gt (self) -> Option < symbols :: GtGtGt < 'tree > > { match self { Self :: GtGtGt (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `??` ([symbols::QuestionQuestion]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn question_question (self) -> Option < symbols :: QuestionQuestion < 'tree > > { match self { Self :: QuestionQuestion (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `^` ([symbols::BitXor]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn bit_xor (self) -> Option < symbols :: BitXor < 'tree > > { match self { Self :: BitXor (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `in` ([unnamed::In]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn r#in (self) -> Option < unnamed :: In < 'tree > > { match self { Self :: In (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `instanceof` ([unnamed::Instanceof]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn instanceof (self) -> Option < unnamed :: Instanceof < 'tree > > { match self { Self :: Instanceof (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `|` ([symbols::Or]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn or (self) -> Option < symbols :: Or < 'tree > > { match self { Self :: Or (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `||` ([symbols::OrOr]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn or_or (self) -> Option < symbols :: OrOr < 'tree > > { match self { Self :: OrOr (x) => Some (x) , _ => None , } } }
    #[automatically_derived]
    impl < 'tree > TryFrom < yak_sitter :: Node < 'tree >> for NotEq_NotEqEq_Mod_And_AndAnd_Mul_MulMul_Add_Sub_Div_Lt_LtLt_LtEq_EqEq_EqEqEq_Gt_GtEq_GtGt_GtGtGt_QuestionQuestion_BitXor_In_Instanceof_Or_OrOr < 'tree > { type Error = type_sitter_lib :: IncorrectKind < 'tree > ; # [inline] fn try_from (node : yak_sitter :: Node < 'tree >) -> Result < Self , Self :: Error > { match node . kind () { "!=" => Ok (unsafe { Self :: NotEq (< symbols :: NotEq < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "!==" => Ok (unsafe { Self :: NotEqEq (< symbols :: NotEqEq < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "%" => Ok (unsafe { Self :: Mod (< symbols :: Mod < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "&" => Ok (unsafe { Self :: And (< symbols :: And < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "&&" => Ok (unsafe { Self :: AndAnd (< symbols :: AndAnd < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "*" => Ok (unsafe { Self :: Mul (< symbols :: Mul < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "**" => Ok (unsafe { Self :: MulMul (< symbols :: MulMul < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "+" => Ok (unsafe { Self :: Add (< symbols :: Add < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "-" => Ok (unsafe { Self :: Sub (< symbols :: Sub < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "/" => Ok (unsafe { Self :: Div (< symbols :: Div < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "<" => Ok (unsafe { Self :: Lt (< symbols :: Lt < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "<<" => Ok (unsafe { Self :: LtLt (< symbols :: LtLt < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "<=" => Ok (unsafe { Self :: LtEq (< symbols :: LtEq < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "==" => Ok (unsafe { Self :: EqEq (< symbols :: EqEq < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "===" => Ok (unsafe { Self :: EqEqEq (< symbols :: EqEqEq < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , ">" => Ok (unsafe { Self :: Gt (< symbols :: Gt < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , ">=" => Ok (unsafe { Self :: GtEq (< symbols :: GtEq < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , ">>" => Ok (unsafe { Self :: GtGt (< symbols :: GtGt < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , ">>>" => Ok (unsafe { Self :: GtGtGt (< symbols :: GtGtGt < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "??" => Ok (unsafe { Self :: QuestionQuestion (< symbols :: QuestionQuestion < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "^" => Ok (unsafe { Self :: BitXor (< symbols :: BitXor < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "in" => Ok (unsafe { Self :: In (< unnamed :: In < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "instanceof" => Ok (unsafe { Self :: Instanceof (< unnamed :: Instanceof < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "|" => Ok (unsafe { Self :: Or (< symbols :: Or < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "||" => Ok (unsafe { Self :: OrOr (< symbols :: OrOr < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , _ => Err (type_sitter_lib :: IncorrectKind { node , kind : < Self as type_sitter_lib :: TypedNode < 'tree >> :: KIND , }) } } }
    #[automatically_derived]
    impl < 'tree > type_sitter_lib :: TypedNode < 'tree > for NotEq_NotEqEq_Mod_And_AndAnd_Mul_MulMul_Add_Sub_Div_Lt_LtLt_LtEq_EqEq_EqEqEq_Gt_GtEq_GtGt_GtGtGt_QuestionQuestion_BitXor_In_Instanceof_Or_OrOr < 'tree > { const KIND : & 'static str = "{!= | !== | % | & | && | * | ** | + | - | / | < | << | <= | == | === | > | >= | >> | >>> | ?? | ^ | in | instanceof | | | ||}" ; # [inline] fn node (& self) -> & yak_sitter :: Node < 'tree > { match self { Self :: NotEq (x) => x . node () , Self :: NotEqEq (x) => x . node () , Self :: Mod (x) => x . node () , Self :: And (x) => x . node () , Self :: AndAnd (x) => x . node () , Self :: Mul (x) => x . node () , Self :: MulMul (x) => x . node () , Self :: Add (x) => x . node () , Self :: Sub (x) => x . node () , Self :: Div (x) => x . node () , Self :: Lt (x) => x . node () , Self :: LtLt (x) => x . node () , Self :: LtEq (x) => x . node () , Self :: EqEq (x) => x . node () , Self :: EqEqEq (x) => x . node () , Self :: Gt (x) => x . node () , Self :: GtEq (x) => x . node () , Self :: GtGt (x) => x . node () , Self :: GtGtGt (x) => x . node () , Self :: QuestionQuestion (x) => x . node () , Self :: BitXor (x) => x . node () , Self :: In (x) => x . node () , Self :: Instanceof (x) => x . node () , Self :: Or (x) => x . node () , Self :: OrOr (x) => x . node () , } } # [inline] fn node_mut (& mut self) -> & mut yak_sitter :: Node < 'tree > { match self { Self :: NotEq (x) => x . node_mut () , Self :: NotEqEq (x) => x . node_mut () , Self :: Mod (x) => x . node_mut () , Self :: And (x) => x . node_mut () , Self :: AndAnd (x) => x . node_mut () , Self :: Mul (x) => x . node_mut () , Self :: MulMul (x) => x . node_mut () , Self :: Add (x) => x . node_mut () , Self :: Sub (x) => x . node_mut () , Self :: Div (x) => x . node_mut () , Self :: Lt (x) => x . node_mut () , Self :: LtLt (x) => x . node_mut () , Self :: LtEq (x) => x . node_mut () , Self :: EqEq (x) => x . node_mut () , Self :: EqEqEq (x) => x . node_mut () , Self :: Gt (x) => x . node_mut () , Self :: GtEq (x) => x . node_mut () , Self :: GtGt (x) => x . node_mut () , Self :: GtGtGt (x) => x . node_mut () , Self :: QuestionQuestion (x) => x . node_mut () , Self :: BitXor (x) => x . node_mut () , Self :: In (x) => x . node_mut () , Self :: Instanceof (x) => x . node_mut () , Self :: Or (x) => x . node_mut () , Self :: OrOr (x) => x . node_mut () , } } # [inline] fn into_node (self) -> yak_sitter :: Node < 'tree > { match self { Self :: NotEq (x) => x . into_node () , Self :: NotEqEq (x) => x . into_node () , Self :: Mod (x) => x . into_node () , Self :: And (x) => x . into_node () , Self :: AndAnd (x) => x . into_node () , Self :: Mul (x) => x . into_node () , Self :: MulMul (x) => x . into_node () , Self :: Add (x) => x . into_node () , Self :: Sub (x) => x . into_node () , Self :: Div (x) => x . into_node () , Self :: Lt (x) => x . into_node () , Self :: LtLt (x) => x . into_node () , Self :: LtEq (x) => x . into_node () , Self :: EqEq (x) => x . into_node () , Self :: EqEqEq (x) => x . into_node () , Self :: Gt (x) => x . into_node () , Self :: GtEq (x) => x . into_node () , Self :: GtGt (x) => x . into_node () , Self :: GtGtGt (x) => x . into_node () , Self :: QuestionQuestion (x) => x . into_node () , Self :: BitXor (x) => x . into_node () , Self :: In (x) => x . into_node () , Self :: Instanceof (x) => x . into_node () , Self :: Or (x) => x . into_node () , Self :: OrOr (x) => x . into_node () , } } }
    #[doc = "one of `{arguments | template_string}`:\n- [Arguments]\n- [TemplateString]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Arguments_TemplateString<'tree> {
        Arguments(Arguments<'tree>),
        TemplateString(TemplateString<'tree>),
    }
    #[automatically_derived]
    impl<'tree> Arguments_TemplateString<'tree> {
        #[doc = "Returns the node if it is of kind `arguments` ([Arguments]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn arguments(self) -> Option<Arguments<'tree>> {
            match self {
                Self::Arguments(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `template_string` ([TemplateString]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn template_string(self) -> Option<TemplateString<'tree>> {
            match self {
                Self::TemplateString(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Arguments_TemplateString<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "arguments" => Ok(unsafe {
                    Self :: Arguments (< Arguments < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "template_string" => {
                    Ok(unsafe {
                        Self :: TemplateString (< TemplateString < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Arguments_TemplateString<'tree> {
        const KIND: &'static str = "{arguments | template_string}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::Arguments(x) => x.node(),
                Self::TemplateString(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::Arguments(x) => x.node_mut(),
                Self::TemplateString(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::Arguments(x) => x.into_node(),
                Self::TemplateString(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{array_pattern | identifier | object_pattern}`:\n- [ArrayPattern]\n- [Identifier]\n- [ObjectPattern]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum ArrayPattern_Identifier_ObjectPattern<'tree> {
        ArrayPattern(ArrayPattern<'tree>),
        Identifier(Identifier<'tree>),
        ObjectPattern(ObjectPattern<'tree>),
    }
    #[automatically_derived]
    impl<'tree> ArrayPattern_Identifier_ObjectPattern<'tree> {
        #[doc = "Returns the node if it is of kind `array_pattern` ([ArrayPattern]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn array_pattern(self) -> Option<ArrayPattern<'tree>> {
            match self {
                Self::ArrayPattern(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `identifier` ([Identifier]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn identifier(self) -> Option<Identifier<'tree>> {
            match self {
                Self::Identifier(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `object_pattern` ([ObjectPattern]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn object_pattern(self) -> Option<ObjectPattern<'tree>> {
            match self {
                Self::ObjectPattern(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ArrayPattern_Identifier_ObjectPattern<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "array_pattern" => Ok(unsafe {
                    Self :: ArrayPattern (< ArrayPattern < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "identifier" => Ok(unsafe {
                    Self :: Identifier (< Identifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "object_pattern" => Ok(unsafe {
                    Self::ObjectPattern(<ObjectPattern<'tree> as type_sitter_lib::TypedNode<
                        'tree,
                    >>::from_node_unchecked(node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for ArrayPattern_Identifier_ObjectPattern<'tree> {
        const KIND: &'static str = "{array_pattern | identifier | object_pattern}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::ArrayPattern(x) => x.node(),
                Self::Identifier(x) => x.node(),
                Self::ObjectPattern(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::ArrayPattern(x) => x.node_mut(),
                Self::Identifier(x) => x.node_mut(),
                Self::ObjectPattern(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::ArrayPattern(x) => x.into_node(),
                Self::Identifier(x) => x.into_node(),
                Self::ObjectPattern(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{abstract_method_signature | class_static_block | decorator | index_signature | method_definition | method_signature | public_field_definition}`:\n- [AbstractMethodSignature]\n- [ClassStaticBlock]\n- [Decorator]\n- [IndexSignature]\n- [MethodDefinition]\n- [MethodSignature]\n- [PublicFieldDefinition]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AbstractMethodSignature_ClassStaticBlock_Decorator_IndexSignature_MethodDefinition_MethodSignature_PublicFieldDefinition<
        'tree,
    > {
        AbstractMethodSignature(AbstractMethodSignature<'tree>),
        ClassStaticBlock(ClassStaticBlock<'tree>),
        Decorator(Decorator<'tree>),
        IndexSignature(IndexSignature<'tree>),
        MethodDefinition(MethodDefinition<'tree>),
        MethodSignature(MethodSignature<'tree>),
        PublicFieldDefinition(PublicFieldDefinition<'tree>),
    }
    #[automatically_derived]
    impl < 'tree > AbstractMethodSignature_ClassStaticBlock_Decorator_IndexSignature_MethodDefinition_MethodSignature_PublicFieldDefinition < 'tree > { # [doc = "Returns the node if it is of kind `abstract_method_signature` ([AbstractMethodSignature]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn abstract_method_signature (self) -> Option < AbstractMethodSignature < 'tree > > { match self { Self :: AbstractMethodSignature (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `class_static_block` ([ClassStaticBlock]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn class_static_block (self) -> Option < ClassStaticBlock < 'tree > > { match self { Self :: ClassStaticBlock (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `decorator` ([Decorator]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn decorator (self) -> Option < Decorator < 'tree > > { match self { Self :: Decorator (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `index_signature` ([IndexSignature]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn index_signature (self) -> Option < IndexSignature < 'tree > > { match self { Self :: IndexSignature (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `method_definition` ([MethodDefinition]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn method_definition (self) -> Option < MethodDefinition < 'tree > > { match self { Self :: MethodDefinition (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `method_signature` ([MethodSignature]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn method_signature (self) -> Option < MethodSignature < 'tree > > { match self { Self :: MethodSignature (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `public_field_definition` ([PublicFieldDefinition]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn public_field_definition (self) -> Option < PublicFieldDefinition < 'tree > > { match self { Self :: PublicFieldDefinition (x) => Some (x) , _ => None , } } }
    #[automatically_derived]
    impl < 'tree > TryFrom < yak_sitter :: Node < 'tree >> for AbstractMethodSignature_ClassStaticBlock_Decorator_IndexSignature_MethodDefinition_MethodSignature_PublicFieldDefinition < 'tree > { type Error = type_sitter_lib :: IncorrectKind < 'tree > ; # [inline] fn try_from (node : yak_sitter :: Node < 'tree >) -> Result < Self , Self :: Error > { match node . kind () { "abstract_method_signature" => Ok (unsafe { Self :: AbstractMethodSignature (< AbstractMethodSignature < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "class_static_block" => Ok (unsafe { Self :: ClassStaticBlock (< ClassStaticBlock < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "decorator" => Ok (unsafe { Self :: Decorator (< Decorator < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "index_signature" => Ok (unsafe { Self :: IndexSignature (< IndexSignature < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "method_definition" => Ok (unsafe { Self :: MethodDefinition (< MethodDefinition < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "method_signature" => Ok (unsafe { Self :: MethodSignature (< MethodSignature < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "public_field_definition" => Ok (unsafe { Self :: PublicFieldDefinition (< PublicFieldDefinition < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , _ => Err (type_sitter_lib :: IncorrectKind { node , kind : < Self as type_sitter_lib :: TypedNode < 'tree >> :: KIND , }) } } }
    #[automatically_derived]
    impl < 'tree > type_sitter_lib :: TypedNode < 'tree > for AbstractMethodSignature_ClassStaticBlock_Decorator_IndexSignature_MethodDefinition_MethodSignature_PublicFieldDefinition < 'tree > { const KIND : & 'static str = "{abstract_method_signature | class_static_block | decorator | index_signature | method_definition | method_signature | public_field_definition}" ; # [inline] fn node (& self) -> & yak_sitter :: Node < 'tree > { match self { Self :: AbstractMethodSignature (x) => x . node () , Self :: ClassStaticBlock (x) => x . node () , Self :: Decorator (x) => x . node () , Self :: IndexSignature (x) => x . node () , Self :: MethodDefinition (x) => x . node () , Self :: MethodSignature (x) => x . node () , Self :: PublicFieldDefinition (x) => x . node () , } } # [inline] fn node_mut (& mut self) -> & mut yak_sitter :: Node < 'tree > { match self { Self :: AbstractMethodSignature (x) => x . node_mut () , Self :: ClassStaticBlock (x) => x . node_mut () , Self :: Decorator (x) => x . node_mut () , Self :: IndexSignature (x) => x . node_mut () , Self :: MethodDefinition (x) => x . node_mut () , Self :: MethodSignature (x) => x . node_mut () , Self :: PublicFieldDefinition (x) => x . node_mut () , } } # [inline] fn into_node (self) -> yak_sitter :: Node < 'tree > { match self { Self :: AbstractMethodSignature (x) => x . into_node () , Self :: ClassStaticBlock (x) => x . into_node () , Self :: Decorator (x) => x . into_node () , Self :: IndexSignature (x) => x . into_node () , Self :: MethodDefinition (x) => x . into_node () , Self :: MethodSignature (x) => x . into_node () , Self :: PublicFieldDefinition (x) => x . into_node () , } } }
    #[doc = "one of `{extends_clause | implements_clause}`:\n- [ExtendsClause]\n- [ImplementsClause]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum ExtendsClause_ImplementsClause<'tree> {
        ExtendsClause(ExtendsClause<'tree>),
        ImplementsClause(ImplementsClause<'tree>),
    }
    #[automatically_derived]
    impl<'tree> ExtendsClause_ImplementsClause<'tree> {
        #[doc = "Returns the node if it is of kind `extends_clause` ([ExtendsClause]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn extends_clause(self) -> Option<ExtendsClause<'tree>> {
            match self {
                Self::ExtendsClause(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `implements_clause` ([ImplementsClause]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn implements_clause(self) -> Option<ImplementsClause<'tree>> {
            match self {
                Self::ImplementsClause(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ExtendsClause_ImplementsClause<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "extends_clause" => Ok(unsafe {
                    Self::ExtendsClause(<ExtendsClause<'tree> as type_sitter_lib::TypedNode<
                        'tree,
                    >>::from_node_unchecked(node))
                }),
                "implements_clause" => Ok(unsafe {
                    Self :: ImplementsClause (< ImplementsClause < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for ExtendsClause_ImplementsClause<'tree> {
        const KIND: &'static str = "{extends_clause | implements_clause}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::ExtendsClause(x) => x.node(),
                Self::ImplementsClause(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::ExtendsClause(x) => x.node_mut(),
                Self::ImplementsClause(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::ExtendsClause(x) => x.into_node(),
                Self::ImplementsClause(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{_primary_type | constructor_type | function_type | infer_type | readonly_type}`:\n- [PrimaryType]\n- [ConstructorType]\n- [FunctionType]\n- [InferType]\n- [ReadonlyType]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree> {
        PrimaryType(PrimaryType<'tree>),
        ConstructorType(ConstructorType<'tree>),
        FunctionType(FunctionType<'tree>),
        InferType(InferType<'tree>),
        ReadonlyType(ReadonlyType<'tree>),
    }
    #[automatically_derived]
    impl<'tree> PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree> {
        #[doc = "Returns the node if it is of kind `_primary_type` ([PrimaryType]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn primary_type(self) -> Option<PrimaryType<'tree>> {
            match self {
                Self::PrimaryType(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `constructor_type` ([ConstructorType]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn constructor_type(self) -> Option<ConstructorType<'tree>> {
            match self {
                Self::ConstructorType(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `function_type` ([FunctionType]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn function_type(self) -> Option<FunctionType<'tree>> {
            match self {
                Self::FunctionType(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `infer_type` ([InferType]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn infer_type(self) -> Option<InferType<'tree>> {
            match self {
                Self::InferType(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `readonly_type` ([ReadonlyType]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn readonly_type(self) -> Option<ReadonlyType<'tree>> {
            match self {
                Self::ReadonlyType(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>>
        for PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>
    {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if let Ok(this) = <PrimaryType<'tree> as TryFrom<_>>::try_from(node) {
                return Ok(Self::PrimaryType(this));
            }
            if let Ok(this) = <ConstructorType<'tree> as TryFrom<_>>::try_from(node) {
                return Ok(Self::ConstructorType(this));
            }
            if let Ok(this) = <FunctionType<'tree> as TryFrom<_>>::try_from(node) {
                return Ok(Self::FunctionType(this));
            }
            if let Ok(this) = <InferType<'tree> as TryFrom<_>>::try_from(node) {
                return Ok(Self::InferType(this));
            }
            if let Ok(this) = <ReadonlyType<'tree> as TryFrom<_>>::try_from(node) {
                return Ok(Self::ReadonlyType(this));
            }
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree>
        for PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType<'tree>
    {
        const KIND: &'static str =
            "{_primary_type | constructor_type | function_type | infer_type | readonly_type}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::PrimaryType(x) => x.node(),
                Self::ConstructorType(x) => x.node(),
                Self::FunctionType(x) => x.node(),
                Self::InferType(x) => x.node(),
                Self::ReadonlyType(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::PrimaryType(x) => x.node_mut(),
                Self::ConstructorType(x) => x.node_mut(),
                Self::FunctionType(x) => x.node_mut(),
                Self::InferType(x) => x.node_mut(),
                Self::ReadonlyType(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::PrimaryType(x) => x.into_node(),
                Self::ConstructorType(x) => x.into_node(),
                Self::FunctionType(x) => x.into_node(),
                Self::InferType(x) => x.into_node(),
                Self::ReadonlyType(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{call_expression | identifier | member_expression}`:\n- [CallExpression]\n- [Identifier]\n- [MemberExpression]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum CallExpression_Identifier_MemberExpression<'tree> {
        CallExpression(CallExpression<'tree>),
        Identifier(Identifier<'tree>),
        MemberExpression(MemberExpression<'tree>),
    }
    #[automatically_derived]
    impl<'tree> CallExpression_Identifier_MemberExpression<'tree> {
        #[doc = "Returns the node if it is of kind `call_expression` ([CallExpression]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn call_expression(self) -> Option<CallExpression<'tree>> {
            match self {
                Self::CallExpression(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `identifier` ([Identifier]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn identifier(self) -> Option<Identifier<'tree>> {
            match self {
                Self::Identifier(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `member_expression` ([MemberExpression]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn member_expression(self) -> Option<MemberExpression<'tree>> {
            match self {
                Self::MemberExpression(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for CallExpression_Identifier_MemberExpression<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "call_expression" => {
                    Ok(unsafe {
                        Self :: CallExpression (< CallExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                "identifier" => Ok(unsafe {
                    Self :: Identifier (< Identifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "member_expression" => Ok(unsafe {
                    Self :: MemberExpression (< MemberExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree>
        for CallExpression_Identifier_MemberExpression<'tree>
    {
        const KIND: &'static str = "{call_expression | identifier | member_expression}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::CallExpression(x) => x.node(),
                Self::Identifier(x) => x.node(),
                Self::MemberExpression(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::CallExpression(x) => x.node_mut(),
                Self::Identifier(x) => x.node_mut(),
                Self::MemberExpression(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::CallExpression(x) => x.into_node(),
                Self::Identifier(x) => x.into_node(),
                Self::MemberExpression(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{enum_assignment | computed_property_name | number | private_property_identifier | property_identifier | string}`:\n- [EnumAssignment]\n- [ComputedPropertyName]\n- [Number]\n- [PrivatePropertyIdentifier]\n- [PropertyIdentifier]\n- [String]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum EnumAssignment_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String<
        'tree,
    > {
        EnumAssignment(EnumAssignment<'tree>),
        ComputedPropertyName(ComputedPropertyName<'tree>),
        Number(Number<'tree>),
        PrivatePropertyIdentifier(PrivatePropertyIdentifier<'tree>),
        PropertyIdentifier(PropertyIdentifier<'tree>),
        String(String<'tree>),
    }
    #[automatically_derived]
    impl < 'tree > EnumAssignment_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String < 'tree > { # [doc = "Returns the node if it is of kind `enum_assignment` ([EnumAssignment]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn enum_assignment (self) -> Option < EnumAssignment < 'tree > > { match self { Self :: EnumAssignment (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `computed_property_name` ([ComputedPropertyName]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn computed_property_name (self) -> Option < ComputedPropertyName < 'tree > > { match self { Self :: ComputedPropertyName (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `number` ([Number]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn number (self) -> Option < Number < 'tree > > { match self { Self :: Number (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `private_property_identifier` ([PrivatePropertyIdentifier]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn private_property_identifier (self) -> Option < PrivatePropertyIdentifier < 'tree > > { match self { Self :: PrivatePropertyIdentifier (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `property_identifier` ([PropertyIdentifier]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn property_identifier (self) -> Option < PropertyIdentifier < 'tree > > { match self { Self :: PropertyIdentifier (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `string` ([String]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn string (self) -> Option < String < 'tree > > { match self { Self :: String (x) => Some (x) , _ => None , } } }
    #[automatically_derived]
    impl < 'tree > TryFrom < yak_sitter :: Node < 'tree >> for EnumAssignment_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String < 'tree > { type Error = type_sitter_lib :: IncorrectKind < 'tree > ; # [inline] fn try_from (node : yak_sitter :: Node < 'tree >) -> Result < Self , Self :: Error > { match node . kind () { "enum_assignment" => Ok (unsafe { Self :: EnumAssignment (< EnumAssignment < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "computed_property_name" => Ok (unsafe { Self :: ComputedPropertyName (< ComputedPropertyName < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "number" => Ok (unsafe { Self :: Number (< Number < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "private_property_identifier" => Ok (unsafe { Self :: PrivatePropertyIdentifier (< PrivatePropertyIdentifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "property_identifier" => Ok (unsafe { Self :: PropertyIdentifier (< PropertyIdentifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "string" => Ok (unsafe { Self :: String (< String < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , _ => Err (type_sitter_lib :: IncorrectKind { node , kind : < Self as type_sitter_lib :: TypedNode < 'tree >> :: KIND , }) } } }
    #[automatically_derived]
    impl < 'tree > type_sitter_lib :: TypedNode < 'tree > for EnumAssignment_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String < 'tree > { const KIND : & 'static str = "{enum_assignment | computed_property_name | number | private_property_identifier | property_identifier | string}" ; # [inline] fn node (& self) -> & yak_sitter :: Node < 'tree > { match self { Self :: EnumAssignment (x) => x . node () , Self :: ComputedPropertyName (x) => x . node () , Self :: Number (x) => x . node () , Self :: PrivatePropertyIdentifier (x) => x . node () , Self :: PropertyIdentifier (x) => x . node () , Self :: String (x) => x . node () , } } # [inline] fn node_mut (& mut self) -> & mut yak_sitter :: Node < 'tree > { match self { Self :: EnumAssignment (x) => x . node_mut () , Self :: ComputedPropertyName (x) => x . node_mut () , Self :: Number (x) => x . node_mut () , Self :: PrivatePropertyIdentifier (x) => x . node_mut () , Self :: PropertyIdentifier (x) => x . node_mut () , Self :: String (x) => x . node_mut () , } } # [inline] fn into_node (self) -> yak_sitter :: Node < 'tree > { match self { Self :: EnumAssignment (x) => x . into_node () , Self :: ComputedPropertyName (x) => x . into_node () , Self :: Number (x) => x . into_node () , Self :: PrivatePropertyIdentifier (x) => x . into_node () , Self :: PropertyIdentifier (x) => x . into_node () , Self :: String (x) => x . into_node () , } } }
    #[doc = "one of `{nominal_type_identifier | identifier | string}`:\n- [NominalTypeIdentifier]\n- [Identifier]\n- [String]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum NominalTypeIdentifier_Identifier_String<'tree> {
        NominalTypeIdentifier(NominalTypeIdentifier<'tree>),
        Identifier(Identifier<'tree>),
        String(String<'tree>),
    }
    #[automatically_derived]
    impl<'tree> NominalTypeIdentifier_Identifier_String<'tree> {
        #[doc = "Returns the node if it is of kind `nominal_type_identifier` ([NominalTypeIdentifier]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn nominal_type_identifier(self) -> Option<NominalTypeIdentifier<'tree>> {
            match self {
                Self::NominalTypeIdentifier(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `identifier` ([Identifier]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn identifier(self) -> Option<Identifier<'tree>> {
            match self {
                Self::Identifier(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `string` ([String]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn string(self) -> Option<String<'tree>> {
            match self {
                Self::String(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for NominalTypeIdentifier_Identifier_String<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "nominal_type_identifier" => Ok(unsafe {
                    Self :: NominalTypeIdentifier (< NominalTypeIdentifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "identifier" => Ok(unsafe {
                    Self :: Identifier (< Identifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "string" => {
                    Ok(unsafe {
                        Self :: String (< String < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for NominalTypeIdentifier_Identifier_String<'tree> {
        const KIND: &'static str = "{nominal_type_identifier | identifier | string}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::NominalTypeIdentifier(x) => x.node(),
                Self::Identifier(x) => x.node(),
                Self::String(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::NominalTypeIdentifier(x) => x.node_mut(),
                Self::Identifier(x) => x.node_mut(),
                Self::String(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::NominalTypeIdentifier(x) => x.into_node(),
                Self::Identifier(x) => x.into_node(),
                Self::String(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{identifier | string}`:\n- [Identifier]\n- [String]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Identifier_String<'tree> {
        Identifier(Identifier<'tree>),
        String(String<'tree>),
    }
    #[automatically_derived]
    impl<'tree> Identifier_String<'tree> {
        #[doc = "Returns the node if it is of kind `identifier` ([Identifier]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn identifier(self) -> Option<Identifier<'tree>> {
            match self {
                Self::Identifier(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `string` ([String]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn string(self) -> Option<String<'tree>> {
            match self {
                Self::String(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Identifier_String<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "identifier" => Ok(unsafe {
                    Self :: Identifier (< Identifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "string" => {
                    Ok(unsafe {
                        Self :: String (< String < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Identifier_String<'tree> {
        const KIND: &'static str = "{identifier | string}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => x.node(),
                Self::String(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => x.node_mut(),
                Self::String(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => x.into_node(),
                Self::String(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{export_clause | expression | identifier | namespace_export | declaration | decorator | string}`:\n- [ExportClause]\n- [Expression]\n- [Identifier]\n- [NamespaceExport]\n- [Declaration]\n- [Decorator]\n- [String]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum ExportClause_Expression_Identifier_NamespaceExport_Declaration_Decorator_String<'tree> {
        ExportClause(ExportClause<'tree>),
        Expression(Expression<'tree>),
        Identifier(Identifier<'tree>),
        NamespaceExport(NamespaceExport<'tree>),
        Declaration(Declaration<'tree>),
        Decorator(Decorator<'tree>),
        String(String<'tree>),
    }
    #[automatically_derived]
    impl<'tree> ExportClause_Expression_Identifier_NamespaceExport_Declaration_Decorator_String<'tree> {
        #[doc = "Returns the node if it is of kind `export_clause` ([ExportClause]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn export_clause(self) -> Option<ExportClause<'tree>> {
            match self {
                Self::ExportClause(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `expression` ([Expression]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn expression(self) -> Option<Expression<'tree>> {
            match self {
                Self::Expression(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `identifier` ([Identifier]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn identifier(self) -> Option<Identifier<'tree>> {
            match self {
                Self::Identifier(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `namespace_export` ([NamespaceExport]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn namespace_export(self) -> Option<NamespaceExport<'tree>> {
            match self {
                Self::NamespaceExport(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `declaration` ([Declaration]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn declaration(self) -> Option<Declaration<'tree>> {
            match self {
                Self::Declaration(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `decorator` ([Decorator]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn decorator(self) -> Option<Decorator<'tree>> {
            match self {
                Self::Decorator(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `string` ([String]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn string(self) -> Option<String<'tree>> {
            match self {
                Self::String(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>>
        for ExportClause_Expression_Identifier_NamespaceExport_Declaration_Decorator_String<'tree>
    {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "export_clause" => Ok(unsafe {
                    Self :: ExportClause (< ExportClause < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "expression" => Ok(unsafe {
                    Self :: Expression (< Expression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "identifier" => Ok(unsafe {
                    Self :: Identifier (< Identifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "namespace_export" => {
                    Ok(unsafe {
                        Self :: NamespaceExport (< NamespaceExport < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                "declaration" => Ok(unsafe {
                    Self :: Declaration (< Declaration < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "decorator" => Ok(unsafe {
                    Self :: Decorator (< Decorator < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "string" => {
                    Ok(unsafe {
                        Self :: String (< String < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree>
        for ExportClause_Expression_Identifier_NamespaceExport_Declaration_Decorator_String<'tree>
    {
        const KIND : & 'static str = "{export_clause | expression | identifier | namespace_export | declaration | decorator | string}" ;
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::ExportClause(x) => x.node(),
                Self::Expression(x) => x.node(),
                Self::Identifier(x) => x.node(),
                Self::NamespaceExport(x) => x.node(),
                Self::Declaration(x) => x.node(),
                Self::Decorator(x) => x.node(),
                Self::String(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::ExportClause(x) => x.node_mut(),
                Self::Expression(x) => x.node_mut(),
                Self::Identifier(x) => x.node_mut(),
                Self::NamespaceExport(x) => x.node_mut(),
                Self::Declaration(x) => x.node_mut(),
                Self::Decorator(x) => x.node_mut(),
                Self::String(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::ExportClause(x) => x.into_node(),
                Self::Expression(x) => x.into_node(),
                Self::Identifier(x) => x.into_node(),
                Self::NamespaceExport(x) => x.into_node(),
                Self::Declaration(x) => x.into_node(),
                Self::Decorator(x) => x.into_node(),
                Self::String(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{expression | sequence_expression}`:\n- [Expression]\n- [SequenceExpression]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Expression_SequenceExpression<'tree> {
        Expression(Expression<'tree>),
        SequenceExpression(SequenceExpression<'tree>),
    }
    #[automatically_derived]
    impl<'tree> Expression_SequenceExpression<'tree> {
        #[doc = "Returns the node if it is of kind `expression` ([Expression]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn expression(self) -> Option<Expression<'tree>> {
            match self {
                Self::Expression(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `sequence_expression` ([SequenceExpression]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn sequence_expression(self) -> Option<SequenceExpression<'tree>> {
            match self {
                Self::SequenceExpression(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Expression_SequenceExpression<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "expression" => Ok(unsafe {
                    Self :: Expression (< Expression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "sequence_expression" => Ok(unsafe {
                    Self :: SequenceExpression (< SequenceExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Expression_SequenceExpression<'tree> {
        const KIND: &'static str = "{expression | sequence_expression}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => x.node(),
                Self::SequenceExpression(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => x.node_mut(),
                Self::SequenceExpression(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => x.into_node(),
                Self::SequenceExpression(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{generic_type | nested_type_identifier | type_identifier}`:\n- [GenericType]\n- [NestedTypeIdentifier]\n- [TypeIdentifier]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum GenericType_NestedTypeIdentifier_TypeIdentifier<'tree> {
        GenericType(GenericType<'tree>),
        NestedTypeIdentifier(NestedTypeIdentifier<'tree>),
        TypeIdentifier(TypeIdentifier<'tree>),
    }
    #[automatically_derived]
    impl<'tree> GenericType_NestedTypeIdentifier_TypeIdentifier<'tree> {
        #[doc = "Returns the node if it is of kind `generic_type` ([GenericType]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn generic_type(self) -> Option<GenericType<'tree>> {
            match self {
                Self::GenericType(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `nested_type_identifier` ([NestedTypeIdentifier]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn nested_type_identifier(self) -> Option<NestedTypeIdentifier<'tree>> {
            match self {
                Self::NestedTypeIdentifier(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `type_identifier` ([TypeIdentifier]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn type_identifier(self) -> Option<TypeIdentifier<'tree>> {
            match self {
                Self::TypeIdentifier(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>>
        for GenericType_NestedTypeIdentifier_TypeIdentifier<'tree>
    {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "generic_type" => Ok(unsafe {
                    Self :: GenericType (< GenericType < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "nested_type_identifier" => Ok(unsafe {
                    Self :: NestedTypeIdentifier (< NestedTypeIdentifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "type_identifier" => {
                    Ok(unsafe {
                        Self :: TypeIdentifier (< TypeIdentifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree>
        for GenericType_NestedTypeIdentifier_TypeIdentifier<'tree>
    {
        const KIND: &'static str = "{generic_type | nested_type_identifier | type_identifier}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::GenericType(x) => x.node(),
                Self::NestedTypeIdentifier(x) => x.node(),
                Self::TypeIdentifier(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::GenericType(x) => x.node_mut(),
                Self::NestedTypeIdentifier(x) => x.node_mut(),
                Self::TypeIdentifier(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::GenericType(x) => x.into_node(),
                Self::NestedTypeIdentifier(x) => x.into_node(),
                Self::TypeIdentifier(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{const | let | var}`:\n- [unnamed::Const]\n- [unnamed::Let]\n- [unnamed::Var]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Const_Let_Var<'tree> {
        Const(unnamed::Const<'tree>),
        Let(unnamed::Let<'tree>),
        Var(unnamed::Var<'tree>),
    }
    #[automatically_derived]
    impl<'tree> Const_Let_Var<'tree> {
        #[doc = "Returns the node if it is of kind `const` ([unnamed::Const]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn r#const(self) -> Option<unnamed::Const<'tree>> {
            match self {
                Self::Const(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `let` ([unnamed::Let]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn r#let(self) -> Option<unnamed::Let<'tree>> {
            match self {
                Self::Let(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `var` ([unnamed::Var]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn var(self) -> Option<unnamed::Var<'tree>> {
            match self {
                Self::Var(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Const_Let_Var<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "const" => Ok(unsafe {
                    Self::Const(<unnamed::Const<'tree> as type_sitter_lib::TypedNode<
                        'tree,
                    >>::from_node_unchecked(node))
                }),
                "let" => Ok(unsafe {
                    Self :: Let (< unnamed :: Let < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "var" => Ok(unsafe {
                    Self :: Var (< unnamed :: Var < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Const_Let_Var<'tree> {
        const KIND: &'static str = "{const | let | var}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::Const(x) => x.node(),
                Self::Let(x) => x.node(),
                Self::Var(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::Const(x) => x.node_mut(),
                Self::Let(x) => x.node_mut(),
                Self::Var(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::Const(x) => x.into_node(),
                Self::Let(x) => x.into_node(),
                Self::Var(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{in | of}`:\n- [unnamed::In]\n- [unnamed::Of]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum In_Of<'tree> {
        In(unnamed::In<'tree>),
        Of(unnamed::Of<'tree>),
    }
    #[automatically_derived]
    impl<'tree> In_Of<'tree> {
        #[doc = "Returns the node if it is of kind `in` ([unnamed::In]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn r#in(self) -> Option<unnamed::In<'tree>> {
            match self {
                Self::In(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `of` ([unnamed::Of]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn of(self) -> Option<unnamed::Of<'tree>> {
            match self {
                Self::Of(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for In_Of<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "in" => Ok(unsafe {
                    Self :: In (< unnamed :: In < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "of" => Ok(unsafe {
                    Self :: Of (< unnamed :: Of < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for In_Of<'tree> {
        const KIND: &'static str = "{in | of}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::In(x) => x.node(),
                Self::Of(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::In(x) => x.node_mut(),
                Self::Of(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::In(x) => x.into_node(),
                Self::Of(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{empty_statement | expression_statement}`:\n- [EmptyStatement]\n- [ExpressionStatement]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum EmptyStatement_ExpressionStatement<'tree> {
        EmptyStatement(EmptyStatement<'tree>),
        ExpressionStatement(ExpressionStatement<'tree>),
    }
    #[automatically_derived]
    impl<'tree> EmptyStatement_ExpressionStatement<'tree> {
        #[doc = "Returns the node if it is of kind `empty_statement` ([EmptyStatement]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn empty_statement(self) -> Option<EmptyStatement<'tree>> {
            match self {
                Self::EmptyStatement(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `expression_statement` ([ExpressionStatement]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn expression_statement(self) -> Option<ExpressionStatement<'tree>> {
            match self {
                Self::ExpressionStatement(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for EmptyStatement_ExpressionStatement<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "empty_statement" => {
                    Ok(unsafe {
                        Self :: EmptyStatement (< EmptyStatement < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                "expression_statement" => Ok(unsafe {
                    Self :: ExpressionStatement (< ExpressionStatement < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for EmptyStatement_ExpressionStatement<'tree> {
        const KIND: &'static str = "{empty_statement | expression_statement}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::EmptyStatement(x) => x.node(),
                Self::ExpressionStatement(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::EmptyStatement(x) => x.node_mut(),
                Self::ExpressionStatement(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::EmptyStatement(x) => x.into_node(),
                Self::ExpressionStatement(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{empty_statement | expression_statement | lexical_declaration | variable_declaration}`:\n- [EmptyStatement]\n- [ExpressionStatement]\n- [LexicalDeclaration]\n- [VariableDeclaration]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum EmptyStatement_ExpressionStatement_LexicalDeclaration_VariableDeclaration<'tree> {
        EmptyStatement(EmptyStatement<'tree>),
        ExpressionStatement(ExpressionStatement<'tree>),
        LexicalDeclaration(LexicalDeclaration<'tree>),
        VariableDeclaration(VariableDeclaration<'tree>),
    }
    #[automatically_derived]
    impl<'tree> EmptyStatement_ExpressionStatement_LexicalDeclaration_VariableDeclaration<'tree> {
        #[doc = "Returns the node if it is of kind `empty_statement` ([EmptyStatement]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn empty_statement(self) -> Option<EmptyStatement<'tree>> {
            match self {
                Self::EmptyStatement(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `expression_statement` ([ExpressionStatement]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn expression_statement(self) -> Option<ExpressionStatement<'tree>> {
            match self {
                Self::ExpressionStatement(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `lexical_declaration` ([LexicalDeclaration]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn lexical_declaration(self) -> Option<LexicalDeclaration<'tree>> {
            match self {
                Self::LexicalDeclaration(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `variable_declaration` ([VariableDeclaration]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn variable_declaration(self) -> Option<VariableDeclaration<'tree>> {
            match self {
                Self::VariableDeclaration(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>>
        for EmptyStatement_ExpressionStatement_LexicalDeclaration_VariableDeclaration<'tree>
    {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "empty_statement" => {
                    Ok(unsafe {
                        Self :: EmptyStatement (< EmptyStatement < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                "expression_statement" => Ok(unsafe {
                    Self :: ExpressionStatement (< ExpressionStatement < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "lexical_declaration" => Ok(unsafe {
                    Self :: LexicalDeclaration (< LexicalDeclaration < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "variable_declaration" => Ok(unsafe {
                    Self :: VariableDeclaration (< VariableDeclaration < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree>
        for EmptyStatement_ExpressionStatement_LexicalDeclaration_VariableDeclaration<'tree>
    {
        const KIND: &'static str =
            "{empty_statement | expression_statement | lexical_declaration | variable_declaration}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::EmptyStatement(x) => x.node(),
                Self::ExpressionStatement(x) => x.node(),
                Self::LexicalDeclaration(x) => x.node(),
                Self::VariableDeclaration(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::EmptyStatement(x) => x.node_mut(),
                Self::ExpressionStatement(x) => x.node_mut(),
                Self::LexicalDeclaration(x) => x.node_mut(),
                Self::VariableDeclaration(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::EmptyStatement(x) => x.into_node(),
                Self::ExpressionStatement(x) => x.into_node(),
                Self::LexicalDeclaration(x) => x.into_node(),
                Self::VariableDeclaration(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{optional_parameter | required_parameter}`:\n- [OptionalParameter]\n- [RequiredParameter]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum OptionalParameter_RequiredParameter<'tree> {
        OptionalParameter(OptionalParameter<'tree>),
        RequiredParameter(RequiredParameter<'tree>),
    }
    #[automatically_derived]
    impl<'tree> OptionalParameter_RequiredParameter<'tree> {
        #[doc = "Returns the node if it is of kind `optional_parameter` ([OptionalParameter]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn optional_parameter(self) -> Option<OptionalParameter<'tree>> {
            match self {
                Self::OptionalParameter(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `required_parameter` ([RequiredParameter]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn required_parameter(self) -> Option<RequiredParameter<'tree>> {
            match self {
                Self::RequiredParameter(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for OptionalParameter_RequiredParameter<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "optional_parameter" => Ok(unsafe {
                    Self :: OptionalParameter (< OptionalParameter < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "required_parameter" => Ok(unsafe {
                    Self :: RequiredParameter (< RequiredParameter < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for OptionalParameter_RequiredParameter<'tree> {
        const KIND: &'static str = "{optional_parameter | required_parameter}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::OptionalParameter(x) => x.node(),
                Self::RequiredParameter(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::OptionalParameter(x) => x.node_mut(),
                Self::RequiredParameter(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::OptionalParameter(x) => x.into_node(),
                Self::RequiredParameter(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{_primary_nominal_type | function_nominal_type | nullable_nominal_type}`:\n- [PrimaryNominalType]\n- [FunctionNominalType]\n- [NullableNominalType]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum PrimaryNominalType_FunctionNominalType_NullableNominalType<'tree> {
        PrimaryNominalType(PrimaryNominalType<'tree>),
        FunctionNominalType(FunctionNominalType<'tree>),
        NullableNominalType(NullableNominalType<'tree>),
    }
    #[automatically_derived]
    impl<'tree> PrimaryNominalType_FunctionNominalType_NullableNominalType<'tree> {
        #[doc = "Returns the node if it is of kind `_primary_nominal_type` ([PrimaryNominalType]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn primary_nominal_type(self) -> Option<PrimaryNominalType<'tree>> {
            match self {
                Self::PrimaryNominalType(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `function_nominal_type` ([FunctionNominalType]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn function_nominal_type(self) -> Option<FunctionNominalType<'tree>> {
            match self {
                Self::FunctionNominalType(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `nullable_nominal_type` ([NullableNominalType]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn nullable_nominal_type(self) -> Option<NullableNominalType<'tree>> {
            match self {
                Self::NullableNominalType(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>>
        for PrimaryNominalType_FunctionNominalType_NullableNominalType<'tree>
    {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if let Ok(this) = <PrimaryNominalType<'tree> as TryFrom<_>>::try_from(node) {
                return Ok(Self::PrimaryNominalType(this));
            }
            if let Ok(this) = <FunctionNominalType<'tree> as TryFrom<_>>::try_from(node) {
                return Ok(Self::FunctionNominalType(this));
            }
            if let Ok(this) = <NullableNominalType<'tree> as TryFrom<_>>::try_from(node) {
                return Ok(Self::NullableNominalType(this));
            }
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree>
        for PrimaryNominalType_FunctionNominalType_NullableNominalType<'tree>
    {
        const KIND: &'static str =
            "{_primary_nominal_type | function_nominal_type | nullable_nominal_type}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::PrimaryNominalType(x) => x.node(),
                Self::FunctionNominalType(x) => x.node(),
                Self::NullableNominalType(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::PrimaryNominalType(x) => x.node_mut(),
                Self::FunctionNominalType(x) => x.node_mut(),
                Self::NullableNominalType(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::PrimaryNominalType(x) => x.into_node(),
                Self::FunctionNominalType(x) => x.into_node(),
                Self::NullableNominalType(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{_primary_type | constructor_type | function_type | infer_type | readonly_type | type_predicate}`:\n- [PrimaryType]\n- [ConstructorType]\n- [FunctionType]\n- [InferType]\n- [ReadonlyType]\n- [TypePredicate]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType_TypePredicate<'tree> {
        PrimaryType(PrimaryType<'tree>),
        ConstructorType(ConstructorType<'tree>),
        FunctionType(FunctionType<'tree>),
        InferType(InferType<'tree>),
        ReadonlyType(ReadonlyType<'tree>),
        TypePredicate(TypePredicate<'tree>),
    }
    #[automatically_derived]
    impl<'tree> PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType_TypePredicate<'tree> {
        #[doc = "Returns the node if it is of kind `_primary_type` ([PrimaryType]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn primary_type(self) -> Option<PrimaryType<'tree>> {
            match self {
                Self::PrimaryType(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `constructor_type` ([ConstructorType]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn constructor_type(self) -> Option<ConstructorType<'tree>> {
            match self {
                Self::ConstructorType(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `function_type` ([FunctionType]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn function_type(self) -> Option<FunctionType<'tree>> {
            match self {
                Self::FunctionType(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `infer_type` ([InferType]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn infer_type(self) -> Option<InferType<'tree>> {
            match self {
                Self::InferType(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `readonly_type` ([ReadonlyType]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn readonly_type(self) -> Option<ReadonlyType<'tree>> {
            match self {
                Self::ReadonlyType(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `type_predicate` ([TypePredicate]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn type_predicate(self) -> Option<TypePredicate<'tree>> {
            match self {
                Self::TypePredicate(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>>
        for PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType_TypePredicate<'tree>
    {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if let Ok(this) = <PrimaryType<'tree> as TryFrom<_>>::try_from(node) {
                return Ok(Self::PrimaryType(this));
            }
            if let Ok(this) = <ConstructorType<'tree> as TryFrom<_>>::try_from(node) {
                return Ok(Self::ConstructorType(this));
            }
            if let Ok(this) = <FunctionType<'tree> as TryFrom<_>>::try_from(node) {
                return Ok(Self::FunctionType(this));
            }
            if let Ok(this) = <InferType<'tree> as TryFrom<_>>::try_from(node) {
                return Ok(Self::InferType(this));
            }
            if let Ok(this) = <ReadonlyType<'tree> as TryFrom<_>>::try_from(node) {
                return Ok(Self::ReadonlyType(this));
            }
            if let Ok(this) = <TypePredicate<'tree> as TryFrom<_>>::try_from(node) {
                return Ok(Self::TypePredicate(this));
            }
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree>
        for PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType_TypePredicate<'tree>
    {
        const KIND : & 'static str = "{_primary_type | constructor_type | function_type | infer_type | readonly_type | type_predicate}" ;
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::PrimaryType(x) => x.node(),
                Self::ConstructorType(x) => x.node(),
                Self::FunctionType(x) => x.node(),
                Self::InferType(x) => x.node(),
                Self::ReadonlyType(x) => x.node(),
                Self::TypePredicate(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::PrimaryType(x) => x.node_mut(),
                Self::ConstructorType(x) => x.node_mut(),
                Self::FunctionType(x) => x.node_mut(),
                Self::InferType(x) => x.node_mut(),
                Self::ReadonlyType(x) => x.node_mut(),
                Self::TypePredicate(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::PrimaryType(x) => x.into_node(),
                Self::ConstructorType(x) => x.into_node(),
                Self::FunctionType(x) => x.into_node(),
                Self::InferType(x) => x.into_node(),
                Self::ReadonlyType(x) => x.into_node(),
                Self::TypePredicate(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{nested_type_identifier | type_identifier}`:\n- [NestedTypeIdentifier]\n- [TypeIdentifier]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum NestedTypeIdentifier_TypeIdentifier<'tree> {
        NestedTypeIdentifier(NestedTypeIdentifier<'tree>),
        TypeIdentifier(TypeIdentifier<'tree>),
    }
    #[automatically_derived]
    impl<'tree> NestedTypeIdentifier_TypeIdentifier<'tree> {
        #[doc = "Returns the node if it is of kind `nested_type_identifier` ([NestedTypeIdentifier]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn nested_type_identifier(self) -> Option<NestedTypeIdentifier<'tree>> {
            match self {
                Self::NestedTypeIdentifier(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `type_identifier` ([TypeIdentifier]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn type_identifier(self) -> Option<TypeIdentifier<'tree>> {
            match self {
                Self::TypeIdentifier(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for NestedTypeIdentifier_TypeIdentifier<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "nested_type_identifier" => Ok(unsafe {
                    Self :: NestedTypeIdentifier (< NestedTypeIdentifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "type_identifier" => {
                    Ok(unsafe {
                        Self :: TypeIdentifier (< TypeIdentifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for NestedTypeIdentifier_TypeIdentifier<'tree> {
        const KIND: &'static str = "{nested_type_identifier | type_identifier}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::NestedTypeIdentifier(x) => x.node(),
                Self::TypeIdentifier(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::NestedTypeIdentifier(x) => x.node_mut(),
                Self::TypeIdentifier(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::NestedTypeIdentifier(x) => x.into_node(),
                Self::TypeIdentifier(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{identifier | nested_identifier}`:\n- [Identifier]\n- [NestedIdentifier]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Identifier_NestedIdentifier<'tree> {
        Identifier(Identifier<'tree>),
        NestedIdentifier(NestedIdentifier<'tree>),
    }
    #[automatically_derived]
    impl<'tree> Identifier_NestedIdentifier<'tree> {
        #[doc = "Returns the node if it is of kind `identifier` ([Identifier]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn identifier(self) -> Option<Identifier<'tree>> {
            match self {
                Self::Identifier(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `nested_identifier` ([NestedIdentifier]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn nested_identifier(self) -> Option<NestedIdentifier<'tree>> {
            match self {
                Self::NestedIdentifier(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Identifier_NestedIdentifier<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "identifier" => Ok(unsafe {
                    Self :: Identifier (< Identifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "nested_identifier" => Ok(unsafe {
                    Self :: NestedIdentifier (< NestedIdentifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Identifier_NestedIdentifier<'tree> {
        const KIND: &'static str = "{identifier | nested_identifier}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => x.node(),
                Self::NestedIdentifier(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => x.node_mut(),
                Self::NestedIdentifier(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => x.into_node(),
                Self::NestedIdentifier(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{identifier | named_imports | namespace_import}`:\n- [Identifier]\n- [NamedImports]\n- [NamespaceImport]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Identifier_NamedImports_NamespaceImport<'tree> {
        Identifier(Identifier<'tree>),
        NamedImports(NamedImports<'tree>),
        NamespaceImport(NamespaceImport<'tree>),
    }
    #[automatically_derived]
    impl<'tree> Identifier_NamedImports_NamespaceImport<'tree> {
        #[doc = "Returns the node if it is of kind `identifier` ([Identifier]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn identifier(self) -> Option<Identifier<'tree>> {
            match self {
                Self::Identifier(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `named_imports` ([NamedImports]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn named_imports(self) -> Option<NamedImports<'tree>> {
            match self {
                Self::NamedImports(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `namespace_import` ([NamespaceImport]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn namespace_import(self) -> Option<NamespaceImport<'tree>> {
            match self {
                Self::NamespaceImport(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Identifier_NamedImports_NamespaceImport<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "identifier" => Ok(unsafe {
                    Self :: Identifier (< Identifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "named_imports" => Ok(unsafe {
                    Self :: NamedImports (< NamedImports < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "namespace_import" => {
                    Ok(unsafe {
                        Self :: NamespaceImport (< NamespaceImport < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Identifier_NamedImports_NamespaceImport<'tree> {
        const KIND: &'static str = "{identifier | named_imports | namespace_import}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => x.node(),
                Self::NamedImports(x) => x.node(),
                Self::NamespaceImport(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => x.node_mut(),
                Self::NamedImports(x) => x.node_mut(),
                Self::NamespaceImport(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => x.into_node(),
                Self::NamedImports(x) => x.into_node(),
                Self::NamespaceImport(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{import_clause | import_require_clause | string}`:\n- [ImportClause]\n- [ImportRequireClause]\n- [String]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum ImportClause_ImportRequireClause_String<'tree> {
        ImportClause(ImportClause<'tree>),
        ImportRequireClause(ImportRequireClause<'tree>),
        String(String<'tree>),
    }
    #[automatically_derived]
    impl<'tree> ImportClause_ImportRequireClause_String<'tree> {
        #[doc = "Returns the node if it is of kind `import_clause` ([ImportClause]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn import_clause(self) -> Option<ImportClause<'tree>> {
            match self {
                Self::ImportClause(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `import_require_clause` ([ImportRequireClause]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn import_require_clause(self) -> Option<ImportRequireClause<'tree>> {
            match self {
                Self::ImportRequireClause(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `string` ([String]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn string(self) -> Option<String<'tree>> {
            match self {
                Self::String(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for ImportClause_ImportRequireClause_String<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "import_clause" => Ok(unsafe {
                    Self :: ImportClause (< ImportClause < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "import_require_clause" => Ok(unsafe {
                    Self :: ImportRequireClause (< ImportRequireClause < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "string" => {
                    Ok(unsafe {
                        Self :: String (< String < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for ImportClause_ImportRequireClause_String<'tree> {
        const KIND: &'static str = "{import_clause | import_require_clause | string}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::ImportClause(x) => x.node(),
                Self::ImportRequireClause(x) => x.node(),
                Self::String(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::ImportClause(x) => x.node_mut(),
                Self::ImportRequireClause(x) => x.node_mut(),
                Self::String(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::ImportClause(x) => x.into_node(),
                Self::ImportRequireClause(x) => x.into_node(),
                Self::String(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{mapped_type_clause | _primary_type | constructor_type | function_type | infer_type | readonly_type | identifier | - | omitting_type_annotation | opting_type_annotation | type_annotation}`:\n- [MappedTypeClause]\n- [PrimaryType]\n- [ConstructorType]\n- [FunctionType]\n- [InferType]\n- [ReadonlyType]\n- [Identifier]\n- [symbols::Sub]\n- [OmittingTypeAnnotation]\n- [OptingTypeAnnotation]\n- [TypeAnnotation]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum MappedTypeClause_PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType_Identifier_Sub_OmittingTypeAnnotation_OptingTypeAnnotation_TypeAnnotation<
        'tree,
    > {
        MappedTypeClause(MappedTypeClause<'tree>),
        PrimaryType(PrimaryType<'tree>),
        ConstructorType(ConstructorType<'tree>),
        FunctionType(FunctionType<'tree>),
        InferType(InferType<'tree>),
        ReadonlyType(ReadonlyType<'tree>),
        Identifier(Identifier<'tree>),
        Sub(symbols::Sub<'tree>),
        OmittingTypeAnnotation(OmittingTypeAnnotation<'tree>),
        OptingTypeAnnotation(OptingTypeAnnotation<'tree>),
        TypeAnnotation(TypeAnnotation<'tree>),
    }
    #[automatically_derived]
    impl < 'tree > MappedTypeClause_PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType_Identifier_Sub_OmittingTypeAnnotation_OptingTypeAnnotation_TypeAnnotation < 'tree > { # [doc = "Returns the node if it is of kind `mapped_type_clause` ([MappedTypeClause]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn mapped_type_clause (self) -> Option < MappedTypeClause < 'tree > > { match self { Self :: MappedTypeClause (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `_primary_type` ([PrimaryType]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn primary_type (self) -> Option < PrimaryType < 'tree > > { match self { Self :: PrimaryType (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `constructor_type` ([ConstructorType]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn constructor_type (self) -> Option < ConstructorType < 'tree > > { match self { Self :: ConstructorType (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `function_type` ([FunctionType]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn function_type (self) -> Option < FunctionType < 'tree > > { match self { Self :: FunctionType (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `infer_type` ([InferType]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn infer_type (self) -> Option < InferType < 'tree > > { match self { Self :: InferType (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `readonly_type` ([ReadonlyType]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn readonly_type (self) -> Option < ReadonlyType < 'tree > > { match self { Self :: ReadonlyType (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `identifier` ([Identifier]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn identifier (self) -> Option < Identifier < 'tree > > { match self { Self :: Identifier (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `-` ([symbols::Sub]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn sub (self) -> Option < symbols :: Sub < 'tree > > { match self { Self :: Sub (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `omitting_type_annotation` ([OmittingTypeAnnotation]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn omitting_type_annotation (self) -> Option < OmittingTypeAnnotation < 'tree > > { match self { Self :: OmittingTypeAnnotation (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `opting_type_annotation` ([OptingTypeAnnotation]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn opting_type_annotation (self) -> Option < OptingTypeAnnotation < 'tree > > { match self { Self :: OptingTypeAnnotation (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `type_annotation` ([TypeAnnotation]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn type_annotation (self) -> Option < TypeAnnotation < 'tree > > { match self { Self :: TypeAnnotation (x) => Some (x) , _ => None , } } }
    #[automatically_derived]
    impl < 'tree > TryFrom < yak_sitter :: Node < 'tree >> for MappedTypeClause_PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType_Identifier_Sub_OmittingTypeAnnotation_OptingTypeAnnotation_TypeAnnotation < 'tree > { type Error = type_sitter_lib :: IncorrectKind < 'tree > ; # [inline] fn try_from (node : yak_sitter :: Node < 'tree >) -> Result < Self , Self :: Error > { if let Ok (this) = < MappedTypeClause < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: MappedTypeClause (this)) ; } if let Ok (this) = < PrimaryType < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: PrimaryType (this)) ; } if let Ok (this) = < ConstructorType < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: ConstructorType (this)) ; } if let Ok (this) = < FunctionType < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: FunctionType (this)) ; } if let Ok (this) = < InferType < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: InferType (this)) ; } if let Ok (this) = < ReadonlyType < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: ReadonlyType (this)) ; } if let Ok (this) = < Identifier < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: Identifier (this)) ; } if let Ok (this) = < symbols :: Sub < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: Sub (this)) ; } if let Ok (this) = < OmittingTypeAnnotation < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: OmittingTypeAnnotation (this)) ; } if let Ok (this) = < OptingTypeAnnotation < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: OptingTypeAnnotation (this)) ; } if let Ok (this) = < TypeAnnotation < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: TypeAnnotation (this)) ; } Err (type_sitter_lib :: IncorrectKind { node , kind : < Self as type_sitter_lib :: TypedNode < 'tree >> :: KIND , }) } }
    #[automatically_derived]
    impl < 'tree > type_sitter_lib :: TypedNode < 'tree > for MappedTypeClause_PrimaryType_ConstructorType_FunctionType_InferType_ReadonlyType_Identifier_Sub_OmittingTypeAnnotation_OptingTypeAnnotation_TypeAnnotation < 'tree > { const KIND : & 'static str = "{mapped_type_clause | _primary_type | constructor_type | function_type | infer_type | readonly_type | identifier | - | omitting_type_annotation | opting_type_annotation | type_annotation}" ; # [inline] fn node (& self) -> & yak_sitter :: Node < 'tree > { match self { Self :: MappedTypeClause (x) => x . node () , Self :: PrimaryType (x) => x . node () , Self :: ConstructorType (x) => x . node () , Self :: FunctionType (x) => x . node () , Self :: InferType (x) => x . node () , Self :: ReadonlyType (x) => x . node () , Self :: Identifier (x) => x . node () , Self :: Sub (x) => x . node () , Self :: OmittingTypeAnnotation (x) => x . node () , Self :: OptingTypeAnnotation (x) => x . node () , Self :: TypeAnnotation (x) => x . node () , } } # [inline] fn node_mut (& mut self) -> & mut yak_sitter :: Node < 'tree > { match self { Self :: MappedTypeClause (x) => x . node_mut () , Self :: PrimaryType (x) => x . node_mut () , Self :: ConstructorType (x) => x . node_mut () , Self :: FunctionType (x) => x . node_mut () , Self :: InferType (x) => x . node_mut () , Self :: ReadonlyType (x) => x . node_mut () , Self :: Identifier (x) => x . node_mut () , Self :: Sub (x) => x . node_mut () , Self :: OmittingTypeAnnotation (x) => x . node_mut () , Self :: OptingTypeAnnotation (x) => x . node_mut () , Self :: TypeAnnotation (x) => x . node_mut () , } } # [inline] fn into_node (self) -> yak_sitter :: Node < 'tree > { match self { Self :: MappedTypeClause (x) => x . into_node () , Self :: PrimaryType (x) => x . into_node () , Self :: ConstructorType (x) => x . into_node () , Self :: FunctionType (x) => x . into_node () , Self :: InferType (x) => x . into_node () , Self :: ReadonlyType (x) => x . into_node () , Self :: Identifier (x) => x . into_node () , Self :: Sub (x) => x . into_node () , Self :: OmittingTypeAnnotation (x) => x . into_node () , Self :: OptingTypeAnnotation (x) => x . into_node () , Self :: TypeAnnotation (x) => x . into_node () , } } }
    #[doc = "one of `{omitting_type_annotation | opting_type_annotation | type_annotation}`:\n- [OmittingTypeAnnotation]\n- [OptingTypeAnnotation]\n- [TypeAnnotation]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum OmittingTypeAnnotation_OptingTypeAnnotation_TypeAnnotation<'tree> {
        OmittingTypeAnnotation(OmittingTypeAnnotation<'tree>),
        OptingTypeAnnotation(OptingTypeAnnotation<'tree>),
        TypeAnnotation(TypeAnnotation<'tree>),
    }
    #[automatically_derived]
    impl<'tree> OmittingTypeAnnotation_OptingTypeAnnotation_TypeAnnotation<'tree> {
        #[doc = "Returns the node if it is of kind `omitting_type_annotation` ([OmittingTypeAnnotation]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn omitting_type_annotation(self) -> Option<OmittingTypeAnnotation<'tree>> {
            match self {
                Self::OmittingTypeAnnotation(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `opting_type_annotation` ([OptingTypeAnnotation]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn opting_type_annotation(self) -> Option<OptingTypeAnnotation<'tree>> {
            match self {
                Self::OptingTypeAnnotation(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `type_annotation` ([TypeAnnotation]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn type_annotation(self) -> Option<TypeAnnotation<'tree>> {
            match self {
                Self::TypeAnnotation(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>>
        for OmittingTypeAnnotation_OptingTypeAnnotation_TypeAnnotation<'tree>
    {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "omitting_type_annotation" => Ok(unsafe {
                    Self :: OmittingTypeAnnotation (< OmittingTypeAnnotation < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "opting_type_annotation" => Ok(unsafe {
                    Self :: OptingTypeAnnotation (< OptingTypeAnnotation < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "type_annotation" => {
                    Ok(unsafe {
                        Self :: TypeAnnotation (< TypeAnnotation < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree>
        for OmittingTypeAnnotation_OptingTypeAnnotation_TypeAnnotation<'tree>
    {
        const KIND: &'static str =
            "{omitting_type_annotation | opting_type_annotation | type_annotation}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::OmittingTypeAnnotation(x) => x.node(),
                Self::OptingTypeAnnotation(x) => x.node(),
                Self::TypeAnnotation(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::OmittingTypeAnnotation(x) => x.node_mut(),
                Self::OptingTypeAnnotation(x) => x.node_mut(),
                Self::TypeAnnotation(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::OmittingTypeAnnotation(x) => x.into_node(),
                Self::OptingTypeAnnotation(x) => x.into_node(),
                Self::TypeAnnotation(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{extends_type_clause | object_type | type_identifier | type_parameters}`:\n- [ExtendsTypeClause]\n- [ObjectType]\n- [TypeIdentifier]\n- [TypeParameters]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum ExtendsTypeClause_ObjectType_TypeIdentifier_TypeParameters<'tree> {
        ExtendsTypeClause(ExtendsTypeClause<'tree>),
        ObjectType(ObjectType<'tree>),
        TypeIdentifier(TypeIdentifier<'tree>),
        TypeParameters(TypeParameters<'tree>),
    }
    #[automatically_derived]
    impl<'tree> ExtendsTypeClause_ObjectType_TypeIdentifier_TypeParameters<'tree> {
        #[doc = "Returns the node if it is of kind `extends_type_clause` ([ExtendsTypeClause]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn extends_type_clause(self) -> Option<ExtendsTypeClause<'tree>> {
            match self {
                Self::ExtendsTypeClause(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `object_type` ([ObjectType]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn object_type(self) -> Option<ObjectType<'tree>> {
            match self {
                Self::ObjectType(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `type_identifier` ([TypeIdentifier]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn type_identifier(self) -> Option<TypeIdentifier<'tree>> {
            match self {
                Self::TypeIdentifier(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `type_parameters` ([TypeParameters]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn type_parameters(self) -> Option<TypeParameters<'tree>> {
            match self {
                Self::TypeParameters(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>>
        for ExtendsTypeClause_ObjectType_TypeIdentifier_TypeParameters<'tree>
    {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "extends_type_clause" => Ok(unsafe {
                    Self :: ExtendsTypeClause (< ExtendsTypeClause < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "object_type" => Ok(unsafe {
                    Self :: ObjectType (< ObjectType < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "type_identifier" => {
                    Ok(unsafe {
                        Self :: TypeIdentifier (< TypeIdentifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                "type_parameters" => {
                    Ok(unsafe {
                        Self :: TypeParameters (< TypeParameters < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree>
        for ExtendsTypeClause_ObjectType_TypeIdentifier_TypeParameters<'tree>
    {
        const KIND: &'static str =
            "{extends_type_clause | object_type | type_identifier | type_parameters}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::ExtendsTypeClause(x) => x.node(),
                Self::ObjectType(x) => x.node(),
                Self::TypeIdentifier(x) => x.node(),
                Self::TypeParameters(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::ExtendsTypeClause(x) => x.node_mut(),
                Self::ObjectType(x) => x.node_mut(),
                Self::TypeIdentifier(x) => x.node_mut(),
                Self::TypeParameters(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::ExtendsTypeClause(x) => x.into_node(),
                Self::ObjectType(x) => x.into_node(),
                Self::TypeIdentifier(x) => x.into_node(),
                Self::TypeParameters(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{identifier | nested_identifier | string}`:\n- [Identifier]\n- [NestedIdentifier]\n- [String]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Identifier_NestedIdentifier_String<'tree> {
        Identifier(Identifier<'tree>),
        NestedIdentifier(NestedIdentifier<'tree>),
        String(String<'tree>),
    }
    #[automatically_derived]
    impl<'tree> Identifier_NestedIdentifier_String<'tree> {
        #[doc = "Returns the node if it is of kind `identifier` ([Identifier]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn identifier(self) -> Option<Identifier<'tree>> {
            match self {
                Self::Identifier(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `nested_identifier` ([NestedIdentifier]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn nested_identifier(self) -> Option<NestedIdentifier<'tree>> {
            match self {
                Self::NestedIdentifier(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `string` ([String]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn string(self) -> Option<String<'tree>> {
            match self {
                Self::String(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Identifier_NestedIdentifier_String<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "identifier" => Ok(unsafe {
                    Self :: Identifier (< Identifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "nested_identifier" => Ok(unsafe {
                    Self :: NestedIdentifier (< NestedIdentifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "string" => {
                    Ok(unsafe {
                        Self :: String (< String < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Identifier_NestedIdentifier_String<'tree> {
        const KIND: &'static str = "{identifier | nested_identifier | string}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => x.node(),
                Self::NestedIdentifier(x) => x.node(),
                Self::String(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => x.node_mut(),
                Self::NestedIdentifier(x) => x.node_mut(),
                Self::String(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => x.into_node(),
                Self::NestedIdentifier(x) => x.into_node(),
                Self::String(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{jsx_element | jsx_expression | jsx_fragment | jsx_namespace_name | jsx_self_closing_element | property_identifier | string}`:\n- [JsxElement]\n- [JsxExpression]\n- [JsxFragment]\n- [JsxNamespaceName]\n- [JsxSelfClosingElement]\n- [PropertyIdentifier]\n- [String]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum JsxElement_JsxExpression_JsxFragment_JsxNamespaceName_JsxSelfClosingElement_PropertyIdentifier_String<
        'tree,
    > {
        JsxElement(JsxElement<'tree>),
        JsxExpression(JsxExpression<'tree>),
        JsxFragment(JsxFragment<'tree>),
        JsxNamespaceName(JsxNamespaceName<'tree>),
        JsxSelfClosingElement(JsxSelfClosingElement<'tree>),
        PropertyIdentifier(PropertyIdentifier<'tree>),
        String(String<'tree>),
    }
    #[automatically_derived]
    impl < 'tree > JsxElement_JsxExpression_JsxFragment_JsxNamespaceName_JsxSelfClosingElement_PropertyIdentifier_String < 'tree > { # [doc = "Returns the node if it is of kind `jsx_element` ([JsxElement]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn jsx_element (self) -> Option < JsxElement < 'tree > > { match self { Self :: JsxElement (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `jsx_expression` ([JsxExpression]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn jsx_expression (self) -> Option < JsxExpression < 'tree > > { match self { Self :: JsxExpression (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `jsx_fragment` ([JsxFragment]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn jsx_fragment (self) -> Option < JsxFragment < 'tree > > { match self { Self :: JsxFragment (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `jsx_namespace_name` ([JsxNamespaceName]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn jsx_namespace_name (self) -> Option < JsxNamespaceName < 'tree > > { match self { Self :: JsxNamespaceName (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `jsx_self_closing_element` ([JsxSelfClosingElement]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn jsx_self_closing_element (self) -> Option < JsxSelfClosingElement < 'tree > > { match self { Self :: JsxSelfClosingElement (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `property_identifier` ([PropertyIdentifier]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn property_identifier (self) -> Option < PropertyIdentifier < 'tree > > { match self { Self :: PropertyIdentifier (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `string` ([String]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn string (self) -> Option < String < 'tree > > { match self { Self :: String (x) => Some (x) , _ => None , } } }
    #[automatically_derived]
    impl < 'tree > TryFrom < yak_sitter :: Node < 'tree >> for JsxElement_JsxExpression_JsxFragment_JsxNamespaceName_JsxSelfClosingElement_PropertyIdentifier_String < 'tree > { type Error = type_sitter_lib :: IncorrectKind < 'tree > ; # [inline] fn try_from (node : yak_sitter :: Node < 'tree >) -> Result < Self , Self :: Error > { match node . kind () { "jsx_element" => Ok (unsafe { Self :: JsxElement (< JsxElement < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "jsx_expression" => Ok (unsafe { Self :: JsxExpression (< JsxExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "jsx_fragment" => Ok (unsafe { Self :: JsxFragment (< JsxFragment < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "jsx_namespace_name" => Ok (unsafe { Self :: JsxNamespaceName (< JsxNamespaceName < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "jsx_self_closing_element" => Ok (unsafe { Self :: JsxSelfClosingElement (< JsxSelfClosingElement < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "property_identifier" => Ok (unsafe { Self :: PropertyIdentifier (< PropertyIdentifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "string" => Ok (unsafe { Self :: String (< String < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , _ => Err (type_sitter_lib :: IncorrectKind { node , kind : < Self as type_sitter_lib :: TypedNode < 'tree >> :: KIND , }) } } }
    #[automatically_derived]
    impl < 'tree > type_sitter_lib :: TypedNode < 'tree > for JsxElement_JsxExpression_JsxFragment_JsxNamespaceName_JsxSelfClosingElement_PropertyIdentifier_String < 'tree > { const KIND : & 'static str = "{jsx_element | jsx_expression | jsx_fragment | jsx_namespace_name | jsx_self_closing_element | property_identifier | string}" ; # [inline] fn node (& self) -> & yak_sitter :: Node < 'tree > { match self { Self :: JsxElement (x) => x . node () , Self :: JsxExpression (x) => x . node () , Self :: JsxFragment (x) => x . node () , Self :: JsxNamespaceName (x) => x . node () , Self :: JsxSelfClosingElement (x) => x . node () , Self :: PropertyIdentifier (x) => x . node () , Self :: String (x) => x . node () , } } # [inline] fn node_mut (& mut self) -> & mut yak_sitter :: Node < 'tree > { match self { Self :: JsxElement (x) => x . node_mut () , Self :: JsxExpression (x) => x . node_mut () , Self :: JsxFragment (x) => x . node_mut () , Self :: JsxNamespaceName (x) => x . node_mut () , Self :: JsxSelfClosingElement (x) => x . node_mut () , Self :: PropertyIdentifier (x) => x . node_mut () , Self :: String (x) => x . node_mut () , } } # [inline] fn into_node (self) -> yak_sitter :: Node < 'tree > { match self { Self :: JsxElement (x) => x . into_node () , Self :: JsxExpression (x) => x . into_node () , Self :: JsxFragment (x) => x . into_node () , Self :: JsxNamespaceName (x) => x . into_node () , Self :: JsxSelfClosingElement (x) => x . into_node () , Self :: PropertyIdentifier (x) => x . into_node () , Self :: String (x) => x . into_node () , } } }
    #[doc = "one of `{identifier | jsx_namespace_name | nested_identifier}`:\n- [Identifier]\n- [JsxNamespaceName]\n- [NestedIdentifier]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Identifier_JsxNamespaceName_NestedIdentifier<'tree> {
        Identifier(Identifier<'tree>),
        JsxNamespaceName(JsxNamespaceName<'tree>),
        NestedIdentifier(NestedIdentifier<'tree>),
    }
    #[automatically_derived]
    impl<'tree> Identifier_JsxNamespaceName_NestedIdentifier<'tree> {
        #[doc = "Returns the node if it is of kind `identifier` ([Identifier]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn identifier(self) -> Option<Identifier<'tree>> {
            match self {
                Self::Identifier(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `jsx_namespace_name` ([JsxNamespaceName]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn jsx_namespace_name(self) -> Option<JsxNamespaceName<'tree>> {
            match self {
                Self::JsxNamespaceName(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `nested_identifier` ([NestedIdentifier]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn nested_identifier(self) -> Option<NestedIdentifier<'tree>> {
            match self {
                Self::NestedIdentifier(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>>
        for Identifier_JsxNamespaceName_NestedIdentifier<'tree>
    {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "identifier" => Ok(unsafe {
                    Self :: Identifier (< Identifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "jsx_namespace_name" => Ok(unsafe {
                    Self :: JsxNamespaceName (< JsxNamespaceName < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "nested_identifier" => Ok(unsafe {
                    Self :: NestedIdentifier (< NestedIdentifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree>
        for Identifier_JsxNamespaceName_NestedIdentifier<'tree>
    {
        const KIND: &'static str = "{identifier | jsx_namespace_name | nested_identifier}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => x.node(),
                Self::JsxNamespaceName(x) => x.node(),
                Self::NestedIdentifier(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => x.node_mut(),
                Self::JsxNamespaceName(x) => x.node_mut(),
                Self::NestedIdentifier(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => x.into_node(),
                Self::JsxNamespaceName(x) => x.into_node(),
                Self::NestedIdentifier(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{jsx_element | jsx_expression | jsx_fragment | jsx_self_closing_element | jsx_text | jsx_closing_element | jsx_opening_element}`:\n- [JsxElement]\n- [JsxExpression]\n- [JsxFragment]\n- [JsxSelfClosingElement]\n- [JsxText]\n- [JsxClosingElement]\n- [JsxOpeningElement]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum JsxElement_JsxExpression_JsxFragment_JsxSelfClosingElement_JsxText_JsxClosingElement_JsxOpeningElement<
        'tree,
    > {
        JsxElement(JsxElement<'tree>),
        JsxExpression(JsxExpression<'tree>),
        JsxFragment(JsxFragment<'tree>),
        JsxSelfClosingElement(JsxSelfClosingElement<'tree>),
        JsxText(JsxText<'tree>),
        JsxClosingElement(JsxClosingElement<'tree>),
        JsxOpeningElement(JsxOpeningElement<'tree>),
    }
    #[automatically_derived]
    impl < 'tree > JsxElement_JsxExpression_JsxFragment_JsxSelfClosingElement_JsxText_JsxClosingElement_JsxOpeningElement < 'tree > { # [doc = "Returns the node if it is of kind `jsx_element` ([JsxElement]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn jsx_element (self) -> Option < JsxElement < 'tree > > { match self { Self :: JsxElement (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `jsx_expression` ([JsxExpression]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn jsx_expression (self) -> Option < JsxExpression < 'tree > > { match self { Self :: JsxExpression (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `jsx_fragment` ([JsxFragment]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn jsx_fragment (self) -> Option < JsxFragment < 'tree > > { match self { Self :: JsxFragment (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `jsx_self_closing_element` ([JsxSelfClosingElement]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn jsx_self_closing_element (self) -> Option < JsxSelfClosingElement < 'tree > > { match self { Self :: JsxSelfClosingElement (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `jsx_text` ([JsxText]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn jsx_text (self) -> Option < JsxText < 'tree > > { match self { Self :: JsxText (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `jsx_closing_element` ([JsxClosingElement]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn jsx_closing_element (self) -> Option < JsxClosingElement < 'tree > > { match self { Self :: JsxClosingElement (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `jsx_opening_element` ([JsxOpeningElement]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn jsx_opening_element (self) -> Option < JsxOpeningElement < 'tree > > { match self { Self :: JsxOpeningElement (x) => Some (x) , _ => None , } } }
    #[automatically_derived]
    impl < 'tree > TryFrom < yak_sitter :: Node < 'tree >> for JsxElement_JsxExpression_JsxFragment_JsxSelfClosingElement_JsxText_JsxClosingElement_JsxOpeningElement < 'tree > { type Error = type_sitter_lib :: IncorrectKind < 'tree > ; # [inline] fn try_from (node : yak_sitter :: Node < 'tree >) -> Result < Self , Self :: Error > { match node . kind () { "jsx_element" => Ok (unsafe { Self :: JsxElement (< JsxElement < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "jsx_expression" => Ok (unsafe { Self :: JsxExpression (< JsxExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "jsx_fragment" => Ok (unsafe { Self :: JsxFragment (< JsxFragment < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "jsx_self_closing_element" => Ok (unsafe { Self :: JsxSelfClosingElement (< JsxSelfClosingElement < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "jsx_text" => Ok (unsafe { Self :: JsxText (< JsxText < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "jsx_closing_element" => Ok (unsafe { Self :: JsxClosingElement (< JsxClosingElement < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "jsx_opening_element" => Ok (unsafe { Self :: JsxOpeningElement (< JsxOpeningElement < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , _ => Err (type_sitter_lib :: IncorrectKind { node , kind : < Self as type_sitter_lib :: TypedNode < 'tree >> :: KIND , }) } } }
    #[automatically_derived]
    impl < 'tree > type_sitter_lib :: TypedNode < 'tree > for JsxElement_JsxExpression_JsxFragment_JsxSelfClosingElement_JsxText_JsxClosingElement_JsxOpeningElement < 'tree > { const KIND : & 'static str = "{jsx_element | jsx_expression | jsx_fragment | jsx_self_closing_element | jsx_text | jsx_closing_element | jsx_opening_element}" ; # [inline] fn node (& self) -> & yak_sitter :: Node < 'tree > { match self { Self :: JsxElement (x) => x . node () , Self :: JsxExpression (x) => x . node () , Self :: JsxFragment (x) => x . node () , Self :: JsxSelfClosingElement (x) => x . node () , Self :: JsxText (x) => x . node () , Self :: JsxClosingElement (x) => x . node () , Self :: JsxOpeningElement (x) => x . node () , } } # [inline] fn node_mut (& mut self) -> & mut yak_sitter :: Node < 'tree > { match self { Self :: JsxElement (x) => x . node_mut () , Self :: JsxExpression (x) => x . node_mut () , Self :: JsxFragment (x) => x . node_mut () , Self :: JsxSelfClosingElement (x) => x . node_mut () , Self :: JsxText (x) => x . node_mut () , Self :: JsxClosingElement (x) => x . node_mut () , Self :: JsxOpeningElement (x) => x . node_mut () , } } # [inline] fn into_node (self) -> yak_sitter :: Node < 'tree > { match self { Self :: JsxElement (x) => x . into_node () , Self :: JsxExpression (x) => x . into_node () , Self :: JsxFragment (x) => x . into_node () , Self :: JsxSelfClosingElement (x) => x . into_node () , Self :: JsxText (x) => x . into_node () , Self :: JsxClosingElement (x) => x . into_node () , Self :: JsxOpeningElement (x) => x . into_node () , } } }
    #[doc = "one of `{expression | sequence_expression | spread_element}`:\n- [Expression]\n- [SequenceExpression]\n- [SpreadElement]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Expression_SequenceExpression_SpreadElement<'tree> {
        Expression(Expression<'tree>),
        SequenceExpression(SequenceExpression<'tree>),
        SpreadElement(SpreadElement<'tree>),
    }
    #[automatically_derived]
    impl<'tree> Expression_SequenceExpression_SpreadElement<'tree> {
        #[doc = "Returns the node if it is of kind `expression` ([Expression]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn expression(self) -> Option<Expression<'tree>> {
            match self {
                Self::Expression(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `sequence_expression` ([SequenceExpression]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn sequence_expression(self) -> Option<SequenceExpression<'tree>> {
            match self {
                Self::SequenceExpression(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `spread_element` ([SpreadElement]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn spread_element(self) -> Option<SpreadElement<'tree>> {
            match self {
                Self::SpreadElement(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>>
        for Expression_SequenceExpression_SpreadElement<'tree>
    {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "expression" => Ok(unsafe {
                    Self :: Expression (< Expression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "sequence_expression" => Ok(unsafe {
                    Self :: SequenceExpression (< SequenceExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "spread_element" => Ok(unsafe {
                    Self::SpreadElement(<SpreadElement<'tree> as type_sitter_lib::TypedNode<
                        'tree,
                    >>::from_node_unchecked(node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree>
        for Expression_SequenceExpression_SpreadElement<'tree>
    {
        const KIND: &'static str = "{expression | sequence_expression | spread_element}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => x.node(),
                Self::SequenceExpression(x) => x.node(),
                Self::SpreadElement(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => x.node_mut(),
                Self::SequenceExpression(x) => x.node_mut(),
                Self::SpreadElement(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => x.into_node(),
                Self::SequenceExpression(x) => x.into_node(),
                Self::SpreadElement(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{jsx_element | jsx_expression | jsx_fragment | jsx_self_closing_element | jsx_text}`:\n- [JsxElement]\n- [JsxExpression]\n- [JsxFragment]\n- [JsxSelfClosingElement]\n- [JsxText]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum JsxElement_JsxExpression_JsxFragment_JsxSelfClosingElement_JsxText<'tree> {
        JsxElement(JsxElement<'tree>),
        JsxExpression(JsxExpression<'tree>),
        JsxFragment(JsxFragment<'tree>),
        JsxSelfClosingElement(JsxSelfClosingElement<'tree>),
        JsxText(JsxText<'tree>),
    }
    #[automatically_derived]
    impl<'tree> JsxElement_JsxExpression_JsxFragment_JsxSelfClosingElement_JsxText<'tree> {
        #[doc = "Returns the node if it is of kind `jsx_element` ([JsxElement]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn jsx_element(self) -> Option<JsxElement<'tree>> {
            match self {
                Self::JsxElement(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `jsx_expression` ([JsxExpression]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn jsx_expression(self) -> Option<JsxExpression<'tree>> {
            match self {
                Self::JsxExpression(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `jsx_fragment` ([JsxFragment]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn jsx_fragment(self) -> Option<JsxFragment<'tree>> {
            match self {
                Self::JsxFragment(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `jsx_self_closing_element` ([JsxSelfClosingElement]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn jsx_self_closing_element(self) -> Option<JsxSelfClosingElement<'tree>> {
            match self {
                Self::JsxSelfClosingElement(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `jsx_text` ([JsxText]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn jsx_text(self) -> Option<JsxText<'tree>> {
            match self {
                Self::JsxText(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>>
        for JsxElement_JsxExpression_JsxFragment_JsxSelfClosingElement_JsxText<'tree>
    {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "jsx_element" => Ok(unsafe {
                    Self :: JsxElement (< JsxElement < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "jsx_expression" => Ok(unsafe {
                    Self::JsxExpression(<JsxExpression<'tree> as type_sitter_lib::TypedNode<
                        'tree,
                    >>::from_node_unchecked(node))
                }),
                "jsx_fragment" => Ok(unsafe {
                    Self :: JsxFragment (< JsxFragment < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "jsx_self_closing_element" => Ok(unsafe {
                    Self :: JsxSelfClosingElement (< JsxSelfClosingElement < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "jsx_text" => {
                    Ok(unsafe {
                        Self :: JsxText (< JsxText < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree>
        for JsxElement_JsxExpression_JsxFragment_JsxSelfClosingElement_JsxText<'tree>
    {
        const KIND: &'static str =
            "{jsx_element | jsx_expression | jsx_fragment | jsx_self_closing_element | jsx_text}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::JsxElement(x) => x.node(),
                Self::JsxExpression(x) => x.node(),
                Self::JsxFragment(x) => x.node(),
                Self::JsxSelfClosingElement(x) => x.node(),
                Self::JsxText(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::JsxElement(x) => x.node_mut(),
                Self::JsxExpression(x) => x.node_mut(),
                Self::JsxFragment(x) => x.node_mut(),
                Self::JsxSelfClosingElement(x) => x.node_mut(),
                Self::JsxText(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::JsxElement(x) => x.into_node(),
                Self::JsxExpression(x) => x.into_node(),
                Self::JsxFragment(x) => x.into_node(),
                Self::JsxSelfClosingElement(x) => x.into_node(),
                Self::JsxText(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{jsx_attribute | jsx_expression}`:\n- [JsxAttribute]\n- [JsxExpression]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum JsxAttribute_JsxExpression<'tree> {
        JsxAttribute(JsxAttribute<'tree>),
        JsxExpression(JsxExpression<'tree>),
    }
    #[automatically_derived]
    impl<'tree> JsxAttribute_JsxExpression<'tree> {
        #[doc = "Returns the node if it is of kind `jsx_attribute` ([JsxAttribute]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn jsx_attribute(self) -> Option<JsxAttribute<'tree>> {
            match self {
                Self::JsxAttribute(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `jsx_expression` ([JsxExpression]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn jsx_expression(self) -> Option<JsxExpression<'tree>> {
            match self {
                Self::JsxExpression(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for JsxAttribute_JsxExpression<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "jsx_attribute" => Ok(unsafe {
                    Self :: JsxAttribute (< JsxAttribute < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "jsx_expression" => Ok(unsafe {
                    Self::JsxExpression(<JsxExpression<'tree> as type_sitter_lib::TypedNode<
                        'tree,
                    >>::from_node_unchecked(node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for JsxAttribute_JsxExpression<'tree> {
        const KIND: &'static str = "{jsx_attribute | jsx_expression}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::JsxAttribute(x) => x.node(),
                Self::JsxExpression(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::JsxAttribute(x) => x.node_mut(),
                Self::JsxExpression(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::JsxAttribute(x) => x.into_node(),
                Self::JsxExpression(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{variable_declarator | const | let}`:\n- [VariableDeclarator]\n- [unnamed::Const]\n- [unnamed::Let]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum VariableDeclarator_Const_Let<'tree> {
        VariableDeclarator(VariableDeclarator<'tree>),
        Const(unnamed::Const<'tree>),
        Let(unnamed::Let<'tree>),
    }
    #[automatically_derived]
    impl<'tree> VariableDeclarator_Const_Let<'tree> {
        #[doc = "Returns the node if it is of kind `variable_declarator` ([VariableDeclarator]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn variable_declarator(self) -> Option<VariableDeclarator<'tree>> {
            match self {
                Self::VariableDeclarator(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `const` ([unnamed::Const]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn r#const(self) -> Option<unnamed::Const<'tree>> {
            match self {
                Self::Const(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `let` ([unnamed::Let]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn r#let(self) -> Option<unnamed::Let<'tree>> {
            match self {
                Self::Let(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for VariableDeclarator_Const_Let<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "variable_declarator" => Ok(unsafe {
                    Self :: VariableDeclarator (< VariableDeclarator < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "const" => Ok(unsafe {
                    Self::Const(<unnamed::Const<'tree> as type_sitter_lib::TypedNode<
                        'tree,
                    >>::from_node_unchecked(node))
                }),
                "let" => Ok(unsafe {
                    Self :: Let (< unnamed :: Let < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for VariableDeclarator_Const_Let<'tree> {
        const KIND: &'static str = "{variable_declarator | const | let}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::VariableDeclarator(x) => x.node(),
                Self::Const(x) => x.node(),
                Self::Let(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::VariableDeclarator(x) => x.node_mut(),
                Self::Const(x) => x.node_mut(),
                Self::Let(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::VariableDeclarator(x) => x.into_node(),
                Self::Const(x) => x.into_node(),
                Self::Let(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{const | let}`:\n- [unnamed::Const]\n- [unnamed::Let]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Const_Let<'tree> {
        Const(unnamed::Const<'tree>),
        Let(unnamed::Let<'tree>),
    }
    #[automatically_derived]
    impl<'tree> Const_Let<'tree> {
        #[doc = "Returns the node if it is of kind `const` ([unnamed::Const]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn r#const(self) -> Option<unnamed::Const<'tree>> {
            match self {
                Self::Const(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `let` ([unnamed::Let]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn r#let(self) -> Option<unnamed::Let<'tree>> {
            match self {
                Self::Let(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Const_Let<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "const" => Ok(unsafe {
                    Self::Const(<unnamed::Const<'tree> as type_sitter_lib::TypedNode<
                        'tree,
                    >>::from_node_unchecked(node))
                }),
                "let" => Ok(unsafe {
                    Self :: Let (< unnamed :: Let < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Const_Let<'tree> {
        const KIND: &'static str = "{const | let}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::Const(x) => x.node(),
                Self::Let(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::Const(x) => x.node_mut(),
                Self::Let(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::Const(x) => x.into_node(),
                Self::Let(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{false | null | number | string | true | unary_expression | undefined}`:\n- [False]\n- [Null]\n- [Number]\n- [String]\n- [True]\n- [UnaryExpression]\n- [Undefined]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum False_Null_Number_String_True_UnaryExpression_Undefined<'tree> {
        False(False<'tree>),
        Null(Null<'tree>),
        Number(Number<'tree>),
        String(String<'tree>),
        True(True<'tree>),
        UnaryExpression(UnaryExpression<'tree>),
        Undefined(Undefined<'tree>),
    }
    #[automatically_derived]
    impl<'tree> False_Null_Number_String_True_UnaryExpression_Undefined<'tree> {
        #[doc = "Returns the node if it is of kind `false` ([False]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn r#false(self) -> Option<False<'tree>> {
            match self {
                Self::False(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `null` ([Null]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn null(self) -> Option<Null<'tree>> {
            match self {
                Self::Null(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `number` ([Number]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn number(self) -> Option<Number<'tree>> {
            match self {
                Self::Number(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `string` ([String]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn string(self) -> Option<String<'tree>> {
            match self {
                Self::String(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `true` ([True]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn r#true(self) -> Option<True<'tree>> {
            match self {
                Self::True(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `unary_expression` ([UnaryExpression]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn unary_expression(self) -> Option<UnaryExpression<'tree>> {
            match self {
                Self::UnaryExpression(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `undefined` ([Undefined]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn undefined(self) -> Option<Undefined<'tree>> {
            match self {
                Self::Undefined(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>>
        for False_Null_Number_String_True_UnaryExpression_Undefined<'tree>
    {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "false" => {
                    Ok(unsafe {
                        Self :: False (< False < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                "null" => Ok(unsafe {
                    Self::Null(
                        <Null<'tree> as type_sitter_lib::TypedNode<'tree>>::from_node_unchecked(
                            node,
                        ),
                    )
                }),
                "number" => {
                    Ok(unsafe {
                        Self :: Number (< Number < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                "string" => {
                    Ok(unsafe {
                        Self :: String (< String < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                "true" => Ok(unsafe {
                    Self::True(
                        <True<'tree> as type_sitter_lib::TypedNode<'tree>>::from_node_unchecked(
                            node,
                        ),
                    )
                }),
                "unary_expression" => {
                    Ok(unsafe {
                        Self :: UnaryExpression (< UnaryExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                "undefined" => Ok(unsafe {
                    Self :: Undefined (< Undefined < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree>
        for False_Null_Number_String_True_UnaryExpression_Undefined<'tree>
    {
        const KIND: &'static str =
            "{false | null | number | string | true | unary_expression | undefined}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::False(x) => x.node(),
                Self::Null(x) => x.node(),
                Self::Number(x) => x.node(),
                Self::String(x) => x.node(),
                Self::True(x) => x.node(),
                Self::UnaryExpression(x) => x.node(),
                Self::Undefined(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::False(x) => x.node_mut(),
                Self::Null(x) => x.node_mut(),
                Self::Number(x) => x.node_mut(),
                Self::String(x) => x.node_mut(),
                Self::True(x) => x.node_mut(),
                Self::UnaryExpression(x) => x.node_mut(),
                Self::Undefined(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::False(x) => x.into_node(),
                Self::Null(x) => x.into_node(),
                Self::Number(x) => x.into_node(),
                Self::String(x) => x.into_node(),
                Self::True(x) => x.into_node(),
                Self::UnaryExpression(x) => x.into_node(),
                Self::Undefined(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{private_property_identifier | property_identifier}`:\n- [PrivatePropertyIdentifier]\n- [PropertyIdentifier]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum PrivatePropertyIdentifier_PropertyIdentifier<'tree> {
        PrivatePropertyIdentifier(PrivatePropertyIdentifier<'tree>),
        PropertyIdentifier(PropertyIdentifier<'tree>),
    }
    #[automatically_derived]
    impl<'tree> PrivatePropertyIdentifier_PropertyIdentifier<'tree> {
        #[doc = "Returns the node if it is of kind `private_property_identifier` ([PrivatePropertyIdentifier]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn private_property_identifier(self) -> Option<PrivatePropertyIdentifier<'tree>> {
            match self {
                Self::PrivatePropertyIdentifier(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `property_identifier` ([PropertyIdentifier]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn property_identifier(self) -> Option<PropertyIdentifier<'tree>> {
            match self {
                Self::PropertyIdentifier(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>>
        for PrivatePropertyIdentifier_PropertyIdentifier<'tree>
    {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "private_property_identifier" => Ok(unsafe {
                    Self :: PrivatePropertyIdentifier (< PrivatePropertyIdentifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "property_identifier" => Ok(unsafe {
                    Self :: PropertyIdentifier (< PropertyIdentifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree>
        for PrivatePropertyIdentifier_PropertyIdentifier<'tree>
    {
        const KIND: &'static str = "{private_property_identifier | property_identifier}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::PrivatePropertyIdentifier(x) => x.node(),
                Self::PropertyIdentifier(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::PrivatePropertyIdentifier(x) => x.node_mut(),
                Self::PropertyIdentifier(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::PrivatePropertyIdentifier(x) => x.into_node(),
                Self::PropertyIdentifier(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{accessibility_modifier | override_modifier | statement_block | computed_property_name | number | private_property_identifier | property_identifier | string | nominal_type_annotation | formal_parameters | asserts | type_annotation | type_predicate_annotation | type_parameters}`:\n- [AccessibilityModifier]\n- [OverrideModifier]\n- [StatementBlock]\n- [ComputedPropertyName]\n- [Number]\n- [PrivatePropertyIdentifier]\n- [PropertyIdentifier]\n- [String]\n- [NominalTypeAnnotation]\n- [FormalParameters]\n- [Asserts]\n- [TypeAnnotation]\n- [TypePredicateAnnotation]\n- [TypeParameters]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AccessibilityModifier_OverrideModifier_StatementBlock_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_FormalParameters_Asserts_TypeAnnotation_TypePredicateAnnotation_TypeParameters<
        'tree,
    > {
        AccessibilityModifier(AccessibilityModifier<'tree>),
        OverrideModifier(OverrideModifier<'tree>),
        StatementBlock(StatementBlock<'tree>),
        ComputedPropertyName(ComputedPropertyName<'tree>),
        Number(Number<'tree>),
        PrivatePropertyIdentifier(PrivatePropertyIdentifier<'tree>),
        PropertyIdentifier(PropertyIdentifier<'tree>),
        String(String<'tree>),
        NominalTypeAnnotation(NominalTypeAnnotation<'tree>),
        FormalParameters(FormalParameters<'tree>),
        Asserts(Asserts<'tree>),
        TypeAnnotation(TypeAnnotation<'tree>),
        TypePredicateAnnotation(TypePredicateAnnotation<'tree>),
        TypeParameters(TypeParameters<'tree>),
    }
    #[automatically_derived]
    impl < 'tree > AccessibilityModifier_OverrideModifier_StatementBlock_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_FormalParameters_Asserts_TypeAnnotation_TypePredicateAnnotation_TypeParameters < 'tree > { # [doc = "Returns the node if it is of kind `accessibility_modifier` ([AccessibilityModifier]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn accessibility_modifier (self) -> Option < AccessibilityModifier < 'tree > > { match self { Self :: AccessibilityModifier (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `override_modifier` ([OverrideModifier]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn override_modifier (self) -> Option < OverrideModifier < 'tree > > { match self { Self :: OverrideModifier (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `statement_block` ([StatementBlock]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn statement_block (self) -> Option < StatementBlock < 'tree > > { match self { Self :: StatementBlock (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `computed_property_name` ([ComputedPropertyName]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn computed_property_name (self) -> Option < ComputedPropertyName < 'tree > > { match self { Self :: ComputedPropertyName (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `number` ([Number]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn number (self) -> Option < Number < 'tree > > { match self { Self :: Number (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `private_property_identifier` ([PrivatePropertyIdentifier]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn private_property_identifier (self) -> Option < PrivatePropertyIdentifier < 'tree > > { match self { Self :: PrivatePropertyIdentifier (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `property_identifier` ([PropertyIdentifier]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn property_identifier (self) -> Option < PropertyIdentifier < 'tree > > { match self { Self :: PropertyIdentifier (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `string` ([String]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn string (self) -> Option < String < 'tree > > { match self { Self :: String (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `nominal_type_annotation` ([NominalTypeAnnotation]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn nominal_type_annotation (self) -> Option < NominalTypeAnnotation < 'tree > > { match self { Self :: NominalTypeAnnotation (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `formal_parameters` ([FormalParameters]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn formal_parameters (self) -> Option < FormalParameters < 'tree > > { match self { Self :: FormalParameters (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `asserts` ([Asserts]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn asserts (self) -> Option < Asserts < 'tree > > { match self { Self :: Asserts (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `type_annotation` ([TypeAnnotation]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn type_annotation (self) -> Option < TypeAnnotation < 'tree > > { match self { Self :: TypeAnnotation (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `type_predicate_annotation` ([TypePredicateAnnotation]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn type_predicate_annotation (self) -> Option < TypePredicateAnnotation < 'tree > > { match self { Self :: TypePredicateAnnotation (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `type_parameters` ([TypeParameters]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn type_parameters (self) -> Option < TypeParameters < 'tree > > { match self { Self :: TypeParameters (x) => Some (x) , _ => None , } } }
    #[automatically_derived]
    impl < 'tree > TryFrom < yak_sitter :: Node < 'tree >> for AccessibilityModifier_OverrideModifier_StatementBlock_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_FormalParameters_Asserts_TypeAnnotation_TypePredicateAnnotation_TypeParameters < 'tree > { type Error = type_sitter_lib :: IncorrectKind < 'tree > ; # [inline] fn try_from (node : yak_sitter :: Node < 'tree >) -> Result < Self , Self :: Error > { match node . kind () { "accessibility_modifier" => Ok (unsafe { Self :: AccessibilityModifier (< AccessibilityModifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "override_modifier" => Ok (unsafe { Self :: OverrideModifier (< OverrideModifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "statement_block" => Ok (unsafe { Self :: StatementBlock (< StatementBlock < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "computed_property_name" => Ok (unsafe { Self :: ComputedPropertyName (< ComputedPropertyName < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "number" => Ok (unsafe { Self :: Number (< Number < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "private_property_identifier" => Ok (unsafe { Self :: PrivatePropertyIdentifier (< PrivatePropertyIdentifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "property_identifier" => Ok (unsafe { Self :: PropertyIdentifier (< PropertyIdentifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "string" => Ok (unsafe { Self :: String (< String < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "nominal_type_annotation" => Ok (unsafe { Self :: NominalTypeAnnotation (< NominalTypeAnnotation < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "formal_parameters" => Ok (unsafe { Self :: FormalParameters (< FormalParameters < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "asserts" => Ok (unsafe { Self :: Asserts (< Asserts < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "type_annotation" => Ok (unsafe { Self :: TypeAnnotation (< TypeAnnotation < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "type_predicate_annotation" => Ok (unsafe { Self :: TypePredicateAnnotation (< TypePredicateAnnotation < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "type_parameters" => Ok (unsafe { Self :: TypeParameters (< TypeParameters < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , _ => Err (type_sitter_lib :: IncorrectKind { node , kind : < Self as type_sitter_lib :: TypedNode < 'tree >> :: KIND , }) } } }
    #[automatically_derived]
    impl < 'tree > type_sitter_lib :: TypedNode < 'tree > for AccessibilityModifier_OverrideModifier_StatementBlock_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_FormalParameters_Asserts_TypeAnnotation_TypePredicateAnnotation_TypeParameters < 'tree > { const KIND : & 'static str = "{accessibility_modifier | override_modifier | statement_block | computed_property_name | number | private_property_identifier | property_identifier | string | nominal_type_annotation | formal_parameters | asserts | type_annotation | type_predicate_annotation | type_parameters}" ; # [inline] fn node (& self) -> & yak_sitter :: Node < 'tree > { match self { Self :: AccessibilityModifier (x) => x . node () , Self :: OverrideModifier (x) => x . node () , Self :: StatementBlock (x) => x . node () , Self :: ComputedPropertyName (x) => x . node () , Self :: Number (x) => x . node () , Self :: PrivatePropertyIdentifier (x) => x . node () , Self :: PropertyIdentifier (x) => x . node () , Self :: String (x) => x . node () , Self :: NominalTypeAnnotation (x) => x . node () , Self :: FormalParameters (x) => x . node () , Self :: Asserts (x) => x . node () , Self :: TypeAnnotation (x) => x . node () , Self :: TypePredicateAnnotation (x) => x . node () , Self :: TypeParameters (x) => x . node () , } } # [inline] fn node_mut (& mut self) -> & mut yak_sitter :: Node < 'tree > { match self { Self :: AccessibilityModifier (x) => x . node_mut () , Self :: OverrideModifier (x) => x . node_mut () , Self :: StatementBlock (x) => x . node_mut () , Self :: ComputedPropertyName (x) => x . node_mut () , Self :: Number (x) => x . node_mut () , Self :: PrivatePropertyIdentifier (x) => x . node_mut () , Self :: PropertyIdentifier (x) => x . node_mut () , Self :: String (x) => x . node_mut () , Self :: NominalTypeAnnotation (x) => x . node_mut () , Self :: FormalParameters (x) => x . node_mut () , Self :: Asserts (x) => x . node_mut () , Self :: TypeAnnotation (x) => x . node_mut () , Self :: TypePredicateAnnotation (x) => x . node_mut () , Self :: TypeParameters (x) => x . node_mut () , } } # [inline] fn into_node (self) -> yak_sitter :: Node < 'tree > { match self { Self :: AccessibilityModifier (x) => x . into_node () , Self :: OverrideModifier (x) => x . into_node () , Self :: StatementBlock (x) => x . into_node () , Self :: ComputedPropertyName (x) => x . into_node () , Self :: Number (x) => x . into_node () , Self :: PrivatePropertyIdentifier (x) => x . into_node () , Self :: PropertyIdentifier (x) => x . into_node () , Self :: String (x) => x . into_node () , Self :: NominalTypeAnnotation (x) => x . into_node () , Self :: FormalParameters (x) => x . into_node () , Self :: Asserts (x) => x . into_node () , Self :: TypeAnnotation (x) => x . into_node () , Self :: TypePredicateAnnotation (x) => x . into_node () , Self :: TypeParameters (x) => x . into_node () , } } }
    #[doc = "one of `{accessibility_modifier | override_modifier | computed_property_name | number | private_property_identifier | property_identifier | string | nominal_type_annotation | formal_parameters | asserts | type_annotation | type_predicate_annotation | type_parameters}`:\n- [AccessibilityModifier]\n- [OverrideModifier]\n- [ComputedPropertyName]\n- [Number]\n- [PrivatePropertyIdentifier]\n- [PropertyIdentifier]\n- [String]\n- [NominalTypeAnnotation]\n- [FormalParameters]\n- [Asserts]\n- [TypeAnnotation]\n- [TypePredicateAnnotation]\n- [TypeParameters]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AccessibilityModifier_OverrideModifier_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_FormalParameters_Asserts_TypeAnnotation_TypePredicateAnnotation_TypeParameters<
        'tree,
    > {
        AccessibilityModifier(AccessibilityModifier<'tree>),
        OverrideModifier(OverrideModifier<'tree>),
        ComputedPropertyName(ComputedPropertyName<'tree>),
        Number(Number<'tree>),
        PrivatePropertyIdentifier(PrivatePropertyIdentifier<'tree>),
        PropertyIdentifier(PropertyIdentifier<'tree>),
        String(String<'tree>),
        NominalTypeAnnotation(NominalTypeAnnotation<'tree>),
        FormalParameters(FormalParameters<'tree>),
        Asserts(Asserts<'tree>),
        TypeAnnotation(TypeAnnotation<'tree>),
        TypePredicateAnnotation(TypePredicateAnnotation<'tree>),
        TypeParameters(TypeParameters<'tree>),
    }
    #[automatically_derived]
    impl < 'tree > AccessibilityModifier_OverrideModifier_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_FormalParameters_Asserts_TypeAnnotation_TypePredicateAnnotation_TypeParameters < 'tree > { # [doc = "Returns the node if it is of kind `accessibility_modifier` ([AccessibilityModifier]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn accessibility_modifier (self) -> Option < AccessibilityModifier < 'tree > > { match self { Self :: AccessibilityModifier (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `override_modifier` ([OverrideModifier]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn override_modifier (self) -> Option < OverrideModifier < 'tree > > { match self { Self :: OverrideModifier (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `computed_property_name` ([ComputedPropertyName]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn computed_property_name (self) -> Option < ComputedPropertyName < 'tree > > { match self { Self :: ComputedPropertyName (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `number` ([Number]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn number (self) -> Option < Number < 'tree > > { match self { Self :: Number (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `private_property_identifier` ([PrivatePropertyIdentifier]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn private_property_identifier (self) -> Option < PrivatePropertyIdentifier < 'tree > > { match self { Self :: PrivatePropertyIdentifier (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `property_identifier` ([PropertyIdentifier]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn property_identifier (self) -> Option < PropertyIdentifier < 'tree > > { match self { Self :: PropertyIdentifier (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `string` ([String]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn string (self) -> Option < String < 'tree > > { match self { Self :: String (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `nominal_type_annotation` ([NominalTypeAnnotation]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn nominal_type_annotation (self) -> Option < NominalTypeAnnotation < 'tree > > { match self { Self :: NominalTypeAnnotation (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `formal_parameters` ([FormalParameters]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn formal_parameters (self) -> Option < FormalParameters < 'tree > > { match self { Self :: FormalParameters (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `asserts` ([Asserts]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn asserts (self) -> Option < Asserts < 'tree > > { match self { Self :: Asserts (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `type_annotation` ([TypeAnnotation]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn type_annotation (self) -> Option < TypeAnnotation < 'tree > > { match self { Self :: TypeAnnotation (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `type_predicate_annotation` ([TypePredicateAnnotation]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn type_predicate_annotation (self) -> Option < TypePredicateAnnotation < 'tree > > { match self { Self :: TypePredicateAnnotation (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `type_parameters` ([TypeParameters]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn type_parameters (self) -> Option < TypeParameters < 'tree > > { match self { Self :: TypeParameters (x) => Some (x) , _ => None , } } }
    #[automatically_derived]
    impl < 'tree > TryFrom < yak_sitter :: Node < 'tree >> for AccessibilityModifier_OverrideModifier_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_FormalParameters_Asserts_TypeAnnotation_TypePredicateAnnotation_TypeParameters < 'tree > { type Error = type_sitter_lib :: IncorrectKind < 'tree > ; # [inline] fn try_from (node : yak_sitter :: Node < 'tree >) -> Result < Self , Self :: Error > { match node . kind () { "accessibility_modifier" => Ok (unsafe { Self :: AccessibilityModifier (< AccessibilityModifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "override_modifier" => Ok (unsafe { Self :: OverrideModifier (< OverrideModifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "computed_property_name" => Ok (unsafe { Self :: ComputedPropertyName (< ComputedPropertyName < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "number" => Ok (unsafe { Self :: Number (< Number < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "private_property_identifier" => Ok (unsafe { Self :: PrivatePropertyIdentifier (< PrivatePropertyIdentifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "property_identifier" => Ok (unsafe { Self :: PropertyIdentifier (< PropertyIdentifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "string" => Ok (unsafe { Self :: String (< String < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "nominal_type_annotation" => Ok (unsafe { Self :: NominalTypeAnnotation (< NominalTypeAnnotation < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "formal_parameters" => Ok (unsafe { Self :: FormalParameters (< FormalParameters < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "asserts" => Ok (unsafe { Self :: Asserts (< Asserts < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "type_annotation" => Ok (unsafe { Self :: TypeAnnotation (< TypeAnnotation < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "type_predicate_annotation" => Ok (unsafe { Self :: TypePredicateAnnotation (< TypePredicateAnnotation < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "type_parameters" => Ok (unsafe { Self :: TypeParameters (< TypeParameters < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , _ => Err (type_sitter_lib :: IncorrectKind { node , kind : < Self as type_sitter_lib :: TypedNode < 'tree >> :: KIND , }) } } }
    #[automatically_derived]
    impl < 'tree > type_sitter_lib :: TypedNode < 'tree > for AccessibilityModifier_OverrideModifier_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_FormalParameters_Asserts_TypeAnnotation_TypePredicateAnnotation_TypeParameters < 'tree > { const KIND : & 'static str = "{accessibility_modifier | override_modifier | computed_property_name | number | private_property_identifier | property_identifier | string | nominal_type_annotation | formal_parameters | asserts | type_annotation | type_predicate_annotation | type_parameters}" ; # [inline] fn node (& self) -> & yak_sitter :: Node < 'tree > { match self { Self :: AccessibilityModifier (x) => x . node () , Self :: OverrideModifier (x) => x . node () , Self :: ComputedPropertyName (x) => x . node () , Self :: Number (x) => x . node () , Self :: PrivatePropertyIdentifier (x) => x . node () , Self :: PropertyIdentifier (x) => x . node () , Self :: String (x) => x . node () , Self :: NominalTypeAnnotation (x) => x . node () , Self :: FormalParameters (x) => x . node () , Self :: Asserts (x) => x . node () , Self :: TypeAnnotation (x) => x . node () , Self :: TypePredicateAnnotation (x) => x . node () , Self :: TypeParameters (x) => x . node () , } } # [inline] fn node_mut (& mut self) -> & mut yak_sitter :: Node < 'tree > { match self { Self :: AccessibilityModifier (x) => x . node_mut () , Self :: OverrideModifier (x) => x . node_mut () , Self :: ComputedPropertyName (x) => x . node_mut () , Self :: Number (x) => x . node_mut () , Self :: PrivatePropertyIdentifier (x) => x . node_mut () , Self :: PropertyIdentifier (x) => x . node_mut () , Self :: String (x) => x . node_mut () , Self :: NominalTypeAnnotation (x) => x . node_mut () , Self :: FormalParameters (x) => x . node_mut () , Self :: Asserts (x) => x . node_mut () , Self :: TypeAnnotation (x) => x . node_mut () , Self :: TypePredicateAnnotation (x) => x . node_mut () , Self :: TypeParameters (x) => x . node_mut () , } } # [inline] fn into_node (self) -> yak_sitter :: Node < 'tree > { match self { Self :: AccessibilityModifier (x) => x . into_node () , Self :: OverrideModifier (x) => x . into_node () , Self :: ComputedPropertyName (x) => x . into_node () , Self :: Number (x) => x . into_node () , Self :: PrivatePropertyIdentifier (x) => x . into_node () , Self :: PropertyIdentifier (x) => x . into_node () , Self :: String (x) => x . into_node () , Self :: NominalTypeAnnotation (x) => x . into_node () , Self :: FormalParameters (x) => x . into_node () , Self :: Asserts (x) => x . into_node () , Self :: TypeAnnotation (x) => x . into_node () , Self :: TypePredicateAnnotation (x) => x . into_node () , Self :: TypeParameters (x) => x . into_node () , } } }
    #[doc = "one of `{_primary_nominal_type | function_nominal_type | nullable_nominal_type | optional_nominal_type}`:\n- [PrimaryNominalType]\n- [FunctionNominalType]\n- [NullableNominalType]\n- [OptionalNominalType]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum PrimaryNominalType_FunctionNominalType_NullableNominalType_OptionalNominalType<'tree> {
        PrimaryNominalType(PrimaryNominalType<'tree>),
        FunctionNominalType(FunctionNominalType<'tree>),
        NullableNominalType(NullableNominalType<'tree>),
        OptionalNominalType(OptionalNominalType<'tree>),
    }
    #[automatically_derived]
    impl<'tree> PrimaryNominalType_FunctionNominalType_NullableNominalType_OptionalNominalType<'tree> {
        #[doc = "Returns the node if it is of kind `_primary_nominal_type` ([PrimaryNominalType]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn primary_nominal_type(self) -> Option<PrimaryNominalType<'tree>> {
            match self {
                Self::PrimaryNominalType(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `function_nominal_type` ([FunctionNominalType]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn function_nominal_type(self) -> Option<FunctionNominalType<'tree>> {
            match self {
                Self::FunctionNominalType(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `nullable_nominal_type` ([NullableNominalType]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn nullable_nominal_type(self) -> Option<NullableNominalType<'tree>> {
            match self {
                Self::NullableNominalType(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `optional_nominal_type` ([OptionalNominalType]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn optional_nominal_type(self) -> Option<OptionalNominalType<'tree>> {
            match self {
                Self::OptionalNominalType(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>>
        for PrimaryNominalType_FunctionNominalType_NullableNominalType_OptionalNominalType<'tree>
    {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if let Ok(this) = <PrimaryNominalType<'tree> as TryFrom<_>>::try_from(node) {
                return Ok(Self::PrimaryNominalType(this));
            }
            if let Ok(this) = <FunctionNominalType<'tree> as TryFrom<_>>::try_from(node) {
                return Ok(Self::FunctionNominalType(this));
            }
            if let Ok(this) = <NullableNominalType<'tree> as TryFrom<_>>::try_from(node) {
                return Ok(Self::NullableNominalType(this));
            }
            if let Ok(this) = <OptionalNominalType<'tree> as TryFrom<_>>::try_from(node) {
                return Ok(Self::OptionalNominalType(this));
            }
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree>
        for PrimaryNominalType_FunctionNominalType_NullableNominalType_OptionalNominalType<'tree>
    {
        const KIND : & 'static str = "{_primary_nominal_type | function_nominal_type | nullable_nominal_type | optional_nominal_type}" ;
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::PrimaryNominalType(x) => x.node(),
                Self::FunctionNominalType(x) => x.node(),
                Self::NullableNominalType(x) => x.node(),
                Self::OptionalNominalType(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::PrimaryNominalType(x) => x.node_mut(),
                Self::FunctionNominalType(x) => x.node_mut(),
                Self::NullableNominalType(x) => x.node_mut(),
                Self::OptionalNominalType(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::PrimaryNominalType(x) => x.into_node(),
                Self::FunctionNominalType(x) => x.into_node(),
                Self::NullableNominalType(x) => x.into_node(),
                Self::OptionalNominalType(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{identifier | undefined}`:\n- [Identifier]\n- [Undefined]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Identifier_Undefined<'tree> {
        Identifier(Identifier<'tree>),
        Undefined(Undefined<'tree>),
    }
    #[automatically_derived]
    impl<'tree> Identifier_Undefined<'tree> {
        #[doc = "Returns the node if it is of kind `identifier` ([Identifier]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn identifier(self) -> Option<Identifier<'tree>> {
            match self {
                Self::Identifier(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `undefined` ([Undefined]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn undefined(self) -> Option<Undefined<'tree>> {
            match self {
                Self::Undefined(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Identifier_Undefined<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "identifier" => Ok(unsafe {
                    Self :: Identifier (< Identifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "undefined" => Ok(unsafe {
                    Self :: Undefined (< Undefined < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Identifier_Undefined<'tree> {
        const KIND: &'static str = "{identifier | undefined}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => x.node(),
                Self::Undefined(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => x.node_mut(),
                Self::Undefined(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => x.into_node(),
                Self::Undefined(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{nominal_supertypes | nominal_type_identifier | biv | con | cov | inv}`:\n- [NominalSupertypes]\n- [NominalTypeIdentifier]\n- [unnamed::Biv]\n- [unnamed::Con]\n- [unnamed::Cov]\n- [unnamed::Inv]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum NominalSupertypes_NominalTypeIdentifier_Biv_Con_Cov_Inv<'tree> {
        NominalSupertypes(NominalSupertypes<'tree>),
        NominalTypeIdentifier(NominalTypeIdentifier<'tree>),
        Biv(unnamed::Biv<'tree>),
        Con(unnamed::Con<'tree>),
        Cov(unnamed::Cov<'tree>),
        Inv(unnamed::Inv<'tree>),
    }
    #[automatically_derived]
    impl<'tree> NominalSupertypes_NominalTypeIdentifier_Biv_Con_Cov_Inv<'tree> {
        #[doc = "Returns the node if it is of kind `nominal_supertypes` ([NominalSupertypes]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn nominal_supertypes(self) -> Option<NominalSupertypes<'tree>> {
            match self {
                Self::NominalSupertypes(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `nominal_type_identifier` ([NominalTypeIdentifier]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn nominal_type_identifier(self) -> Option<NominalTypeIdentifier<'tree>> {
            match self {
                Self::NominalTypeIdentifier(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `biv` ([unnamed::Biv]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn biv(self) -> Option<unnamed::Biv<'tree>> {
            match self {
                Self::Biv(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `con` ([unnamed::Con]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn con(self) -> Option<unnamed::Con<'tree>> {
            match self {
                Self::Con(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `cov` ([unnamed::Cov]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn cov(self) -> Option<unnamed::Cov<'tree>> {
            match self {
                Self::Cov(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `inv` ([unnamed::Inv]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn inv(self) -> Option<unnamed::Inv<'tree>> {
            match self {
                Self::Inv(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>>
        for NominalSupertypes_NominalTypeIdentifier_Biv_Con_Cov_Inv<'tree>
    {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "nominal_supertypes" => Ok(unsafe {
                    Self :: NominalSupertypes (< NominalSupertypes < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "nominal_type_identifier" => Ok(unsafe {
                    Self :: NominalTypeIdentifier (< NominalTypeIdentifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "biv" => Ok(unsafe {
                    Self :: Biv (< unnamed :: Biv < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "con" => Ok(unsafe {
                    Self :: Con (< unnamed :: Con < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "cov" => Ok(unsafe {
                    Self :: Cov (< unnamed :: Cov < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "inv" => Ok(unsafe {
                    Self :: Inv (< unnamed :: Inv < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree>
        for NominalSupertypes_NominalTypeIdentifier_Biv_Con_Cov_Inv<'tree>
    {
        const KIND: &'static str =
            "{nominal_supertypes | nominal_type_identifier | biv | con | cov | inv}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::NominalSupertypes(x) => x.node(),
                Self::NominalTypeIdentifier(x) => x.node(),
                Self::Biv(x) => x.node(),
                Self::Con(x) => x.node(),
                Self::Cov(x) => x.node(),
                Self::Inv(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::NominalSupertypes(x) => x.node_mut(),
                Self::NominalTypeIdentifier(x) => x.node_mut(),
                Self::Biv(x) => x.node_mut(),
                Self::Con(x) => x.node_mut(),
                Self::Cov(x) => x.node_mut(),
                Self::Inv(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::NominalSupertypes(x) => x.into_node(),
                Self::NominalTypeIdentifier(x) => x.into_node(),
                Self::Biv(x) => x.into_node(),
                Self::Con(x) => x.into_node(),
                Self::Cov(x) => x.into_node(),
                Self::Inv(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{biv | con | cov | inv}`:\n- [unnamed::Biv]\n- [unnamed::Con]\n- [unnamed::Cov]\n- [unnamed::Inv]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Biv_Con_Cov_Inv<'tree> {
        Biv(unnamed::Biv<'tree>),
        Con(unnamed::Con<'tree>),
        Cov(unnamed::Cov<'tree>),
        Inv(unnamed::Inv<'tree>),
    }
    #[automatically_derived]
    impl<'tree> Biv_Con_Cov_Inv<'tree> {
        #[doc = "Returns the node if it is of kind `biv` ([unnamed::Biv]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn biv(self) -> Option<unnamed::Biv<'tree>> {
            match self {
                Self::Biv(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `con` ([unnamed::Con]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn con(self) -> Option<unnamed::Con<'tree>> {
            match self {
                Self::Con(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `cov` ([unnamed::Cov]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn cov(self) -> Option<unnamed::Cov<'tree>> {
            match self {
                Self::Cov(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `inv` ([unnamed::Inv]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn inv(self) -> Option<unnamed::Inv<'tree>> {
            match self {
                Self::Inv(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Biv_Con_Cov_Inv<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "biv" => Ok(unsafe {
                    Self :: Biv (< unnamed :: Biv < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "con" => Ok(unsafe {
                    Self :: Con (< unnamed :: Con < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "cov" => Ok(unsafe {
                    Self :: Cov (< unnamed :: Cov < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "inv" => Ok(unsafe {
                    Self :: Inv (< unnamed :: Inv < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Biv_Con_Cov_Inv<'tree> {
        const KIND: &'static str = "{biv | con | cov | inv}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::Biv(x) => x.node(),
                Self::Con(x) => x.node(),
                Self::Cov(x) => x.node(),
                Self::Inv(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::Biv(x) => x.node_mut(),
                Self::Con(x) => x.node_mut(),
                Self::Cov(x) => x.node_mut(),
                Self::Inv(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::Biv(x) => x.into_node(),
                Self::Con(x) => x.into_node(),
                Self::Cov(x) => x.into_node(),
                Self::Inv(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{_primary_nominal_type | function_nominal_type | nullable_nominal_type | primary_expression}`:\n- [PrimaryNominalType]\n- [FunctionNominalType]\n- [NullableNominalType]\n- [PrimaryExpression]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum PrimaryNominalType_FunctionNominalType_NullableNominalType_PrimaryExpression<'tree> {
        PrimaryNominalType(PrimaryNominalType<'tree>),
        FunctionNominalType(FunctionNominalType<'tree>),
        NullableNominalType(NullableNominalType<'tree>),
        PrimaryExpression(PrimaryExpression<'tree>),
    }
    #[automatically_derived]
    impl<'tree> PrimaryNominalType_FunctionNominalType_NullableNominalType_PrimaryExpression<'tree> {
        #[doc = "Returns the node if it is of kind `_primary_nominal_type` ([PrimaryNominalType]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn primary_nominal_type(self) -> Option<PrimaryNominalType<'tree>> {
            match self {
                Self::PrimaryNominalType(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `function_nominal_type` ([FunctionNominalType]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn function_nominal_type(self) -> Option<FunctionNominalType<'tree>> {
            match self {
                Self::FunctionNominalType(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `nullable_nominal_type` ([NullableNominalType]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn nullable_nominal_type(self) -> Option<NullableNominalType<'tree>> {
            match self {
                Self::NullableNominalType(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `primary_expression` ([PrimaryExpression]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn primary_expression(self) -> Option<PrimaryExpression<'tree>> {
            match self {
                Self::PrimaryExpression(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>>
        for PrimaryNominalType_FunctionNominalType_NullableNominalType_PrimaryExpression<'tree>
    {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if let Ok(this) = <PrimaryNominalType<'tree> as TryFrom<_>>::try_from(node) {
                return Ok(Self::PrimaryNominalType(this));
            }
            if let Ok(this) = <FunctionNominalType<'tree> as TryFrom<_>>::try_from(node) {
                return Ok(Self::FunctionNominalType(this));
            }
            if let Ok(this) = <NullableNominalType<'tree> as TryFrom<_>>::try_from(node) {
                return Ok(Self::NullableNominalType(this));
            }
            if let Ok(this) = <PrimaryExpression<'tree> as TryFrom<_>>::try_from(node) {
                return Ok(Self::PrimaryExpression(this));
            }
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree>
        for PrimaryNominalType_FunctionNominalType_NullableNominalType_PrimaryExpression<'tree>
    {
        const KIND : & 'static str = "{_primary_nominal_type | function_nominal_type | nullable_nominal_type | primary_expression}" ;
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::PrimaryNominalType(x) => x.node(),
                Self::FunctionNominalType(x) => x.node(),
                Self::NullableNominalType(x) => x.node(),
                Self::PrimaryExpression(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::PrimaryNominalType(x) => x.node_mut(),
                Self::FunctionNominalType(x) => x.node_mut(),
                Self::NullableNominalType(x) => x.node_mut(),
                Self::PrimaryExpression(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::PrimaryNominalType(x) => x.into_node(),
                Self::FunctionNominalType(x) => x.into_node(),
                Self::NullableNominalType(x) => x.into_node(),
                Self::PrimaryExpression(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{method_definition | pair | shorthand_property_identifier | spread_element}`:\n- [MethodDefinition]\n- [Pair]\n- [ShorthandPropertyIdentifier]\n- [SpreadElement]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum MethodDefinition_Pair_ShorthandPropertyIdentifier_SpreadElement<'tree> {
        MethodDefinition(MethodDefinition<'tree>),
        Pair(Pair<'tree>),
        ShorthandPropertyIdentifier(ShorthandPropertyIdentifier<'tree>),
        SpreadElement(SpreadElement<'tree>),
    }
    #[automatically_derived]
    impl<'tree> MethodDefinition_Pair_ShorthandPropertyIdentifier_SpreadElement<'tree> {
        #[doc = "Returns the node if it is of kind `method_definition` ([MethodDefinition]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn method_definition(self) -> Option<MethodDefinition<'tree>> {
            match self {
                Self::MethodDefinition(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `pair` ([Pair]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn pair(self) -> Option<Pair<'tree>> {
            match self {
                Self::Pair(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `shorthand_property_identifier` ([ShorthandPropertyIdentifier]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn shorthand_property_identifier(self) -> Option<ShorthandPropertyIdentifier<'tree>> {
            match self {
                Self::ShorthandPropertyIdentifier(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `spread_element` ([SpreadElement]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn spread_element(self) -> Option<SpreadElement<'tree>> {
            match self {
                Self::SpreadElement(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>>
        for MethodDefinition_Pair_ShorthandPropertyIdentifier_SpreadElement<'tree>
    {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "method_definition" => Ok(unsafe {
                    Self :: MethodDefinition (< MethodDefinition < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "pair" => Ok(unsafe {
                    Self::Pair(
                        <Pair<'tree> as type_sitter_lib::TypedNode<'tree>>::from_node_unchecked(
                            node,
                        ),
                    )
                }),
                "shorthand_property_identifier" => Ok(unsafe {
                    Self :: ShorthandPropertyIdentifier (< ShorthandPropertyIdentifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "spread_element" => Ok(unsafe {
                    Self::SpreadElement(<SpreadElement<'tree> as type_sitter_lib::TypedNode<
                        'tree,
                    >>::from_node_unchecked(node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree>
        for MethodDefinition_Pair_ShorthandPropertyIdentifier_SpreadElement<'tree>
    {
        const KIND: &'static str =
            "{method_definition | pair | shorthand_property_identifier | spread_element}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::MethodDefinition(x) => x.node(),
                Self::Pair(x) => x.node(),
                Self::ShorthandPropertyIdentifier(x) => x.node(),
                Self::SpreadElement(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::MethodDefinition(x) => x.node_mut(),
                Self::Pair(x) => x.node_mut(),
                Self::ShorthandPropertyIdentifier(x) => x.node_mut(),
                Self::SpreadElement(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::MethodDefinition(x) => x.into_node(),
                Self::Pair(x) => x.into_node(),
                Self::ShorthandPropertyIdentifier(x) => x.into_node(),
                Self::SpreadElement(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{array_pattern | object_pattern | shorthand_property_identifier_pattern}`:\n- [ArrayPattern]\n- [ObjectPattern]\n- [ShorthandPropertyIdentifierPattern]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum ArrayPattern_ObjectPattern_ShorthandPropertyIdentifierPattern<'tree> {
        ArrayPattern(ArrayPattern<'tree>),
        ObjectPattern(ObjectPattern<'tree>),
        ShorthandPropertyIdentifierPattern(ShorthandPropertyIdentifierPattern<'tree>),
    }
    #[automatically_derived]
    impl<'tree> ArrayPattern_ObjectPattern_ShorthandPropertyIdentifierPattern<'tree> {
        #[doc = "Returns the node if it is of kind `array_pattern` ([ArrayPattern]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn array_pattern(self) -> Option<ArrayPattern<'tree>> {
            match self {
                Self::ArrayPattern(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `object_pattern` ([ObjectPattern]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn object_pattern(self) -> Option<ObjectPattern<'tree>> {
            match self {
                Self::ObjectPattern(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `shorthand_property_identifier_pattern` ([ShorthandPropertyIdentifierPattern]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn shorthand_property_identifier_pattern(
            self,
        ) -> Option<ShorthandPropertyIdentifierPattern<'tree>> {
            match self {
                Self::ShorthandPropertyIdentifierPattern(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>>
        for ArrayPattern_ObjectPattern_ShorthandPropertyIdentifierPattern<'tree>
    {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "array_pattern" => Ok(unsafe {
                    Self :: ArrayPattern (< ArrayPattern < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "object_pattern" => Ok(unsafe {
                    Self::ObjectPattern(<ObjectPattern<'tree> as type_sitter_lib::TypedNode<
                        'tree,
                    >>::from_node_unchecked(node))
                }),
                "shorthand_property_identifier_pattern" => {
                    Ok(unsafe {
                        Self :: ShorthandPropertyIdentifierPattern (< ShorthandPropertyIdentifierPattern < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree>
        for ArrayPattern_ObjectPattern_ShorthandPropertyIdentifierPattern<'tree>
    {
        const KIND: &'static str =
            "{array_pattern | object_pattern | shorthand_property_identifier_pattern}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::ArrayPattern(x) => x.node(),
                Self::ObjectPattern(x) => x.node(),
                Self::ShorthandPropertyIdentifierPattern(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::ArrayPattern(x) => x.node_mut(),
                Self::ObjectPattern(x) => x.node_mut(),
                Self::ShorthandPropertyIdentifierPattern(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::ArrayPattern(x) => x.into_node(),
                Self::ObjectPattern(x) => x.into_node(),
                Self::ShorthandPropertyIdentifierPattern(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{nominal_method_signature | nominal_property_signature}`:\n- [NominalMethodSignature]\n- [NominalPropertySignature]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum NominalMethodSignature_NominalPropertySignature<'tree> {
        NominalMethodSignature(NominalMethodSignature<'tree>),
        NominalPropertySignature(NominalPropertySignature<'tree>),
    }
    #[automatically_derived]
    impl<'tree> NominalMethodSignature_NominalPropertySignature<'tree> {
        #[doc = "Returns the node if it is of kind `nominal_method_signature` ([NominalMethodSignature]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn nominal_method_signature(self) -> Option<NominalMethodSignature<'tree>> {
            match self {
                Self::NominalMethodSignature(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `nominal_property_signature` ([NominalPropertySignature]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn nominal_property_signature(self) -> Option<NominalPropertySignature<'tree>> {
            match self {
                Self::NominalPropertySignature(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>>
        for NominalMethodSignature_NominalPropertySignature<'tree>
    {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "nominal_method_signature" => Ok(unsafe {
                    Self :: NominalMethodSignature (< NominalMethodSignature < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "nominal_property_signature" => Ok(unsafe {
                    Self :: NominalPropertySignature (< NominalPropertySignature < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree>
        for NominalMethodSignature_NominalPropertySignature<'tree>
    {
        const KIND: &'static str = "{nominal_method_signature | nominal_property_signature}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::NominalMethodSignature(x) => x.node(),
                Self::NominalPropertySignature(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::NominalMethodSignature(x) => x.node_mut(),
                Self::NominalPropertySignature(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::NominalMethodSignature(x) => x.into_node(),
                Self::NominalPropertySignature(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{object_assignment_pattern | pair_pattern | rest_pattern | shorthand_property_identifier_pattern}`:\n- [ObjectAssignmentPattern]\n- [PairPattern]\n- [RestPattern]\n- [ShorthandPropertyIdentifierPattern]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum ObjectAssignmentPattern_PairPattern_RestPattern_ShorthandPropertyIdentifierPattern<
        'tree,
    > {
        ObjectAssignmentPattern(ObjectAssignmentPattern<'tree>),
        PairPattern(PairPattern<'tree>),
        RestPattern(RestPattern<'tree>),
        ShorthandPropertyIdentifierPattern(ShorthandPropertyIdentifierPattern<'tree>),
    }
    #[automatically_derived]
    impl<'tree>
        ObjectAssignmentPattern_PairPattern_RestPattern_ShorthandPropertyIdentifierPattern<'tree>
    {
        #[doc = "Returns the node if it is of kind `object_assignment_pattern` ([ObjectAssignmentPattern]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn object_assignment_pattern(self) -> Option<ObjectAssignmentPattern<'tree>> {
            match self {
                Self::ObjectAssignmentPattern(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `pair_pattern` ([PairPattern]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn pair_pattern(self) -> Option<PairPattern<'tree>> {
            match self {
                Self::PairPattern(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `rest_pattern` ([RestPattern]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn rest_pattern(self) -> Option<RestPattern<'tree>> {
            match self {
                Self::RestPattern(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `shorthand_property_identifier_pattern` ([ShorthandPropertyIdentifierPattern]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn shorthand_property_identifier_pattern(
            self,
        ) -> Option<ShorthandPropertyIdentifierPattern<'tree>> {
            match self {
                Self::ShorthandPropertyIdentifierPattern(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>>
        for ObjectAssignmentPattern_PairPattern_RestPattern_ShorthandPropertyIdentifierPattern<
            'tree,
        >
    {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "object_assignment_pattern" => Ok(unsafe {
                    Self :: ObjectAssignmentPattern (< ObjectAssignmentPattern < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "pair_pattern" => Ok(unsafe {
                    Self :: PairPattern (< PairPattern < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "rest_pattern" => Ok(unsafe {
                    Self :: RestPattern (< RestPattern < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "shorthand_property_identifier_pattern" => {
                    Ok(unsafe {
                        Self :: ShorthandPropertyIdentifierPattern (< ShorthandPropertyIdentifierPattern < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree>
        for ObjectAssignmentPattern_PairPattern_RestPattern_ShorthandPropertyIdentifierPattern<
            'tree,
        >
    {
        const KIND : & 'static str = "{object_assignment_pattern | pair_pattern | rest_pattern | shorthand_property_identifier_pattern}" ;
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::ObjectAssignmentPattern(x) => x.node(),
                Self::PairPattern(x) => x.node(),
                Self::RestPattern(x) => x.node(),
                Self::ShorthandPropertyIdentifierPattern(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::ObjectAssignmentPattern(x) => x.node_mut(),
                Self::PairPattern(x) => x.node_mut(),
                Self::RestPattern(x) => x.node_mut(),
                Self::ShorthandPropertyIdentifierPattern(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::ObjectAssignmentPattern(x) => x.into_node(),
                Self::PairPattern(x) => x.into_node(),
                Self::RestPattern(x) => x.into_node(),
                Self::ShorthandPropertyIdentifierPattern(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{call_signature | construct_signature | export_statement | index_signature | method_signature | property_signature}`:\n- [CallSignature]\n- [ConstructSignature]\n- [ExportStatement]\n- [IndexSignature]\n- [MethodSignature]\n- [PropertySignature]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum CallSignature_ConstructSignature_ExportStatement_IndexSignature_MethodSignature_PropertySignature<
        'tree,
    > {
        CallSignature(CallSignature<'tree>),
        ConstructSignature(ConstructSignature<'tree>),
        ExportStatement(ExportStatement<'tree>),
        IndexSignature(IndexSignature<'tree>),
        MethodSignature(MethodSignature<'tree>),
        PropertySignature(PropertySignature<'tree>),
    }
    #[automatically_derived]
    impl < 'tree > CallSignature_ConstructSignature_ExportStatement_IndexSignature_MethodSignature_PropertySignature < 'tree > { # [doc = "Returns the node if it is of kind `call_signature` ([CallSignature]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn call_signature (self) -> Option < CallSignature < 'tree > > { match self { Self :: CallSignature (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `construct_signature` ([ConstructSignature]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn construct_signature (self) -> Option < ConstructSignature < 'tree > > { match self { Self :: ConstructSignature (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `export_statement` ([ExportStatement]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn export_statement (self) -> Option < ExportStatement < 'tree > > { match self { Self :: ExportStatement (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `index_signature` ([IndexSignature]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn index_signature (self) -> Option < IndexSignature < 'tree > > { match self { Self :: IndexSignature (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `method_signature` ([MethodSignature]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn method_signature (self) -> Option < MethodSignature < 'tree > > { match self { Self :: MethodSignature (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `property_signature` ([PropertySignature]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn property_signature (self) -> Option < PropertySignature < 'tree > > { match self { Self :: PropertySignature (x) => Some (x) , _ => None , } } }
    #[automatically_derived]
    impl < 'tree > TryFrom < yak_sitter :: Node < 'tree >> for CallSignature_ConstructSignature_ExportStatement_IndexSignature_MethodSignature_PropertySignature < 'tree > { type Error = type_sitter_lib :: IncorrectKind < 'tree > ; # [inline] fn try_from (node : yak_sitter :: Node < 'tree >) -> Result < Self , Self :: Error > { match node . kind () { "call_signature" => Ok (unsafe { Self :: CallSignature (< CallSignature < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "construct_signature" => Ok (unsafe { Self :: ConstructSignature (< ConstructSignature < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "export_statement" => Ok (unsafe { Self :: ExportStatement (< ExportStatement < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "index_signature" => Ok (unsafe { Self :: IndexSignature (< IndexSignature < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "method_signature" => Ok (unsafe { Self :: MethodSignature (< MethodSignature < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "property_signature" => Ok (unsafe { Self :: PropertySignature (< PropertySignature < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , _ => Err (type_sitter_lib :: IncorrectKind { node , kind : < Self as type_sitter_lib :: TypedNode < 'tree >> :: KIND , }) } } }
    #[automatically_derived]
    impl < 'tree > type_sitter_lib :: TypedNode < 'tree > for CallSignature_ConstructSignature_ExportStatement_IndexSignature_MethodSignature_PropertySignature < 'tree > { const KIND : & 'static str = "{call_signature | construct_signature | export_statement | index_signature | method_signature | property_signature}" ; # [inline] fn node (& self) -> & yak_sitter :: Node < 'tree > { match self { Self :: CallSignature (x) => x . node () , Self :: ConstructSignature (x) => x . node () , Self :: ExportStatement (x) => x . node () , Self :: IndexSignature (x) => x . node () , Self :: MethodSignature (x) => x . node () , Self :: PropertySignature (x) => x . node () , } } # [inline] fn node_mut (& mut self) -> & mut yak_sitter :: Node < 'tree > { match self { Self :: CallSignature (x) => x . node_mut () , Self :: ConstructSignature (x) => x . node_mut () , Self :: ExportStatement (x) => x . node_mut () , Self :: IndexSignature (x) => x . node_mut () , Self :: MethodSignature (x) => x . node_mut () , Self :: PropertySignature (x) => x . node_mut () , } } # [inline] fn into_node (self) -> yak_sitter :: Node < 'tree > { match self { Self :: CallSignature (x) => x . into_node () , Self :: ConstructSignature (x) => x . into_node () , Self :: ExportStatement (x) => x . into_node () , Self :: IndexSignature (x) => x . into_node () , Self :: MethodSignature (x) => x . into_node () , Self :: PropertySignature (x) => x . into_node () , } } }
    #[doc = "one of `{accessibility_modifier | override_modifier | decorator | identifier | nominal_type_annotation | pattern | this | type_annotation | expression}`:\n- [AccessibilityModifier]\n- [OverrideModifier]\n- [Decorator]\n- [Identifier]\n- [NominalTypeAnnotation]\n- [Pattern]\n- [This]\n- [TypeAnnotation]\n- [Expression]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AccessibilityModifier_OverrideModifier_Decorator_Identifier_NominalTypeAnnotation_Pattern_This_TypeAnnotation_Expression<
        'tree,
    > {
        AccessibilityModifier(AccessibilityModifier<'tree>),
        OverrideModifier(OverrideModifier<'tree>),
        Decorator(Decorator<'tree>),
        Identifier(Identifier<'tree>),
        NominalTypeAnnotation(NominalTypeAnnotation<'tree>),
        Pattern(Pattern<'tree>),
        This(This<'tree>),
        TypeAnnotation(TypeAnnotation<'tree>),
        Expression(Expression<'tree>),
    }
    #[automatically_derived]
    impl < 'tree > AccessibilityModifier_OverrideModifier_Decorator_Identifier_NominalTypeAnnotation_Pattern_This_TypeAnnotation_Expression < 'tree > { # [doc = "Returns the node if it is of kind `accessibility_modifier` ([AccessibilityModifier]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn accessibility_modifier (self) -> Option < AccessibilityModifier < 'tree > > { match self { Self :: AccessibilityModifier (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `override_modifier` ([OverrideModifier]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn override_modifier (self) -> Option < OverrideModifier < 'tree > > { match self { Self :: OverrideModifier (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `decorator` ([Decorator]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn decorator (self) -> Option < Decorator < 'tree > > { match self { Self :: Decorator (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `identifier` ([Identifier]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn identifier (self) -> Option < Identifier < 'tree > > { match self { Self :: Identifier (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `nominal_type_annotation` ([NominalTypeAnnotation]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn nominal_type_annotation (self) -> Option < NominalTypeAnnotation < 'tree > > { match self { Self :: NominalTypeAnnotation (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `pattern` ([Pattern]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn pattern (self) -> Option < Pattern < 'tree > > { match self { Self :: Pattern (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `this` ([This]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn this (self) -> Option < This < 'tree > > { match self { Self :: This (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `type_annotation` ([TypeAnnotation]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn type_annotation (self) -> Option < TypeAnnotation < 'tree > > { match self { Self :: TypeAnnotation (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `expression` ([Expression]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn expression (self) -> Option < Expression < 'tree > > { match self { Self :: Expression (x) => Some (x) , _ => None , } } }
    #[automatically_derived]
    impl < 'tree > TryFrom < yak_sitter :: Node < 'tree >> for AccessibilityModifier_OverrideModifier_Decorator_Identifier_NominalTypeAnnotation_Pattern_This_TypeAnnotation_Expression < 'tree > { type Error = type_sitter_lib :: IncorrectKind < 'tree > ; # [inline] fn try_from (node : yak_sitter :: Node < 'tree >) -> Result < Self , Self :: Error > { match node . kind () { "accessibility_modifier" => Ok (unsafe { Self :: AccessibilityModifier (< AccessibilityModifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "override_modifier" => Ok (unsafe { Self :: OverrideModifier (< OverrideModifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "decorator" => Ok (unsafe { Self :: Decorator (< Decorator < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "identifier" => Ok (unsafe { Self :: Identifier (< Identifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "nominal_type_annotation" => Ok (unsafe { Self :: NominalTypeAnnotation (< NominalTypeAnnotation < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "pattern" => Ok (unsafe { Self :: Pattern (< Pattern < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "this" => Ok (unsafe { Self :: This (< This < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "type_annotation" => Ok (unsafe { Self :: TypeAnnotation (< TypeAnnotation < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "expression" => Ok (unsafe { Self :: Expression (< Expression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , _ => Err (type_sitter_lib :: IncorrectKind { node , kind : < Self as type_sitter_lib :: TypedNode < 'tree >> :: KIND , }) } } }
    #[automatically_derived]
    impl < 'tree > type_sitter_lib :: TypedNode < 'tree > for AccessibilityModifier_OverrideModifier_Decorator_Identifier_NominalTypeAnnotation_Pattern_This_TypeAnnotation_Expression < 'tree > { const KIND : & 'static str = "{accessibility_modifier | override_modifier | decorator | identifier | nominal_type_annotation | pattern | this | type_annotation | expression}" ; # [inline] fn node (& self) -> & yak_sitter :: Node < 'tree > { match self { Self :: AccessibilityModifier (x) => x . node () , Self :: OverrideModifier (x) => x . node () , Self :: Decorator (x) => x . node () , Self :: Identifier (x) => x . node () , Self :: NominalTypeAnnotation (x) => x . node () , Self :: Pattern (x) => x . node () , Self :: This (x) => x . node () , Self :: TypeAnnotation (x) => x . node () , Self :: Expression (x) => x . node () , } } # [inline] fn node_mut (& mut self) -> & mut yak_sitter :: Node < 'tree > { match self { Self :: AccessibilityModifier (x) => x . node_mut () , Self :: OverrideModifier (x) => x . node_mut () , Self :: Decorator (x) => x . node_mut () , Self :: Identifier (x) => x . node_mut () , Self :: NominalTypeAnnotation (x) => x . node_mut () , Self :: Pattern (x) => x . node_mut () , Self :: This (x) => x . node_mut () , Self :: TypeAnnotation (x) => x . node_mut () , Self :: Expression (x) => x . node_mut () , } } # [inline] fn into_node (self) -> yak_sitter :: Node < 'tree > { match self { Self :: AccessibilityModifier (x) => x . into_node () , Self :: OverrideModifier (x) => x . into_node () , Self :: Decorator (x) => x . into_node () , Self :: Identifier (x) => x . into_node () , Self :: NominalTypeAnnotation (x) => x . into_node () , Self :: Pattern (x) => x . into_node () , Self :: This (x) => x . into_node () , Self :: TypeAnnotation (x) => x . into_node () , Self :: Expression (x) => x . into_node () , } } }
    #[doc = "one of `{pattern | this}`:\n- [Pattern]\n- [This]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Pattern_This<'tree> {
        Pattern(Pattern<'tree>),
        This(This<'tree>),
    }
    #[automatically_derived]
    impl<'tree> Pattern_This<'tree> {
        #[doc = "Returns the node if it is of kind `pattern` ([Pattern]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn pattern(self) -> Option<Pattern<'tree>> {
            match self {
                Self::Pattern(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `this` ([This]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn this(self) -> Option<This<'tree>> {
            match self {
                Self::This(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Pattern_This<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "pattern" => {
                    Ok(unsafe {
                        Self :: Pattern (< Pattern < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                "this" => Ok(unsafe {
                    Self::This(
                        <This<'tree> as type_sitter_lib::TypedNode<'tree>>::from_node_unchecked(
                            node,
                        ),
                    )
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Pattern_This<'tree> {
        const KIND: &'static str = "{pattern | this}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::Pattern(x) => x.node(),
                Self::This(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::Pattern(x) => x.node_mut(),
                Self::This(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::Pattern(x) => x.into_node(),
                Self::This(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{expression | sequence_expression | nominal_type_annotation | type_annotation}`:\n- [Expression]\n- [SequenceExpression]\n- [NominalTypeAnnotation]\n- [TypeAnnotation]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Expression_SequenceExpression_NominalTypeAnnotation_TypeAnnotation<'tree> {
        Expression(Expression<'tree>),
        SequenceExpression(SequenceExpression<'tree>),
        NominalTypeAnnotation(NominalTypeAnnotation<'tree>),
        TypeAnnotation(TypeAnnotation<'tree>),
    }
    #[automatically_derived]
    impl<'tree> Expression_SequenceExpression_NominalTypeAnnotation_TypeAnnotation<'tree> {
        #[doc = "Returns the node if it is of kind `expression` ([Expression]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn expression(self) -> Option<Expression<'tree>> {
            match self {
                Self::Expression(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `sequence_expression` ([SequenceExpression]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn sequence_expression(self) -> Option<SequenceExpression<'tree>> {
            match self {
                Self::SequenceExpression(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `nominal_type_annotation` ([NominalTypeAnnotation]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn nominal_type_annotation(self) -> Option<NominalTypeAnnotation<'tree>> {
            match self {
                Self::NominalTypeAnnotation(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `type_annotation` ([TypeAnnotation]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn type_annotation(self) -> Option<TypeAnnotation<'tree>> {
            match self {
                Self::TypeAnnotation(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>>
        for Expression_SequenceExpression_NominalTypeAnnotation_TypeAnnotation<'tree>
    {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "expression" => Ok(unsafe {
                    Self :: Expression (< Expression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "sequence_expression" => Ok(unsafe {
                    Self :: SequenceExpression (< SequenceExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "nominal_type_annotation" => Ok(unsafe {
                    Self :: NominalTypeAnnotation (< NominalTypeAnnotation < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "type_annotation" => {
                    Ok(unsafe {
                        Self :: TypeAnnotation (< TypeAnnotation < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree>
        for Expression_SequenceExpression_NominalTypeAnnotation_TypeAnnotation<'tree>
    {
        const KIND: &'static str =
            "{expression | sequence_expression | nominal_type_annotation | type_annotation}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => x.node(),
                Self::SequenceExpression(x) => x.node(),
                Self::NominalTypeAnnotation(x) => x.node(),
                Self::TypeAnnotation(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => x.node_mut(),
                Self::SequenceExpression(x) => x.node_mut(),
                Self::NominalTypeAnnotation(x) => x.node_mut(),
                Self::TypeAnnotation(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => x.into_node(),
                Self::SequenceExpression(x) => x.into_node(),
                Self::NominalTypeAnnotation(x) => x.into_node(),
                Self::TypeAnnotation(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{hash_bang_line | statement}`:\n- [HashBangLine]\n- [Statement]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum HashBangLine_Statement<'tree> {
        HashBangLine(HashBangLine<'tree>),
        Statement(Statement<'tree>),
    }
    #[automatically_derived]
    impl<'tree> HashBangLine_Statement<'tree> {
        #[doc = "Returns the node if it is of kind `hash_bang_line` ([HashBangLine]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn hash_bang_line(self) -> Option<HashBangLine<'tree>> {
            match self {
                Self::HashBangLine(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `statement` ([Statement]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn statement(self) -> Option<Statement<'tree>> {
            match self {
                Self::Statement(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for HashBangLine_Statement<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "hash_bang_line" => Ok(unsafe {
                    Self :: HashBangLine (< HashBangLine < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "statement" => Ok(unsafe {
                    Self :: Statement (< Statement < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for HashBangLine_Statement<'tree> {
        const KIND: &'static str = "{hash_bang_line | statement}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::HashBangLine(x) => x.node(),
                Self::Statement(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::HashBangLine(x) => x.node_mut(),
                Self::Statement(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::HashBangLine(x) => x.into_node(),
                Self::Statement(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{accessibility_modifier | override_modifier | ? | computed_property_name | number | private_property_identifier | property_identifier | string | nominal_type_annotation | type_annotation}`:\n- [AccessibilityModifier]\n- [OverrideModifier]\n- [symbols::Question]\n- [ComputedPropertyName]\n- [Number]\n- [PrivatePropertyIdentifier]\n- [PropertyIdentifier]\n- [String]\n- [NominalTypeAnnotation]\n- [TypeAnnotation]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AccessibilityModifier_OverrideModifier_Question_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_TypeAnnotation<
        'tree,
    > {
        AccessibilityModifier(AccessibilityModifier<'tree>),
        OverrideModifier(OverrideModifier<'tree>),
        Question(symbols::Question<'tree>),
        ComputedPropertyName(ComputedPropertyName<'tree>),
        Number(Number<'tree>),
        PrivatePropertyIdentifier(PrivatePropertyIdentifier<'tree>),
        PropertyIdentifier(PropertyIdentifier<'tree>),
        String(String<'tree>),
        NominalTypeAnnotation(NominalTypeAnnotation<'tree>),
        TypeAnnotation(TypeAnnotation<'tree>),
    }
    #[automatically_derived]
    impl < 'tree > AccessibilityModifier_OverrideModifier_Question_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_TypeAnnotation < 'tree > { # [doc = "Returns the node if it is of kind `accessibility_modifier` ([AccessibilityModifier]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn accessibility_modifier (self) -> Option < AccessibilityModifier < 'tree > > { match self { Self :: AccessibilityModifier (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `override_modifier` ([OverrideModifier]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn override_modifier (self) -> Option < OverrideModifier < 'tree > > { match self { Self :: OverrideModifier (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `?` ([symbols::Question]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn question (self) -> Option < symbols :: Question < 'tree > > { match self { Self :: Question (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `computed_property_name` ([ComputedPropertyName]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn computed_property_name (self) -> Option < ComputedPropertyName < 'tree > > { match self { Self :: ComputedPropertyName (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `number` ([Number]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn number (self) -> Option < Number < 'tree > > { match self { Self :: Number (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `private_property_identifier` ([PrivatePropertyIdentifier]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn private_property_identifier (self) -> Option < PrivatePropertyIdentifier < 'tree > > { match self { Self :: PrivatePropertyIdentifier (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `property_identifier` ([PropertyIdentifier]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn property_identifier (self) -> Option < PropertyIdentifier < 'tree > > { match self { Self :: PropertyIdentifier (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `string` ([String]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn string (self) -> Option < String < 'tree > > { match self { Self :: String (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `nominal_type_annotation` ([NominalTypeAnnotation]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn nominal_type_annotation (self) -> Option < NominalTypeAnnotation < 'tree > > { match self { Self :: NominalTypeAnnotation (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `type_annotation` ([TypeAnnotation]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn type_annotation (self) -> Option < TypeAnnotation < 'tree > > { match self { Self :: TypeAnnotation (x) => Some (x) , _ => None , } } }
    #[automatically_derived]
    impl < 'tree > TryFrom < yak_sitter :: Node < 'tree >> for AccessibilityModifier_OverrideModifier_Question_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_TypeAnnotation < 'tree > { type Error = type_sitter_lib :: IncorrectKind < 'tree > ; # [inline] fn try_from (node : yak_sitter :: Node < 'tree >) -> Result < Self , Self :: Error > { match node . kind () { "accessibility_modifier" => Ok (unsafe { Self :: AccessibilityModifier (< AccessibilityModifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "override_modifier" => Ok (unsafe { Self :: OverrideModifier (< OverrideModifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "?" => Ok (unsafe { Self :: Question (< symbols :: Question < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "computed_property_name" => Ok (unsafe { Self :: ComputedPropertyName (< ComputedPropertyName < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "number" => Ok (unsafe { Self :: Number (< Number < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "private_property_identifier" => Ok (unsafe { Self :: PrivatePropertyIdentifier (< PrivatePropertyIdentifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "property_identifier" => Ok (unsafe { Self :: PropertyIdentifier (< PropertyIdentifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "string" => Ok (unsafe { Self :: String (< String < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "nominal_type_annotation" => Ok (unsafe { Self :: NominalTypeAnnotation (< NominalTypeAnnotation < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "type_annotation" => Ok (unsafe { Self :: TypeAnnotation (< TypeAnnotation < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , _ => Err (type_sitter_lib :: IncorrectKind { node , kind : < Self as type_sitter_lib :: TypedNode < 'tree >> :: KIND , }) } } }
    #[automatically_derived]
    impl < 'tree > type_sitter_lib :: TypedNode < 'tree > for AccessibilityModifier_OverrideModifier_Question_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_TypeAnnotation < 'tree > { const KIND : & 'static str = "{accessibility_modifier | override_modifier | ? | computed_property_name | number | private_property_identifier | property_identifier | string | nominal_type_annotation | type_annotation}" ; # [inline] fn node (& self) -> & yak_sitter :: Node < 'tree > { match self { Self :: AccessibilityModifier (x) => x . node () , Self :: OverrideModifier (x) => x . node () , Self :: Question (x) => x . node () , Self :: ComputedPropertyName (x) => x . node () , Self :: Number (x) => x . node () , Self :: PrivatePropertyIdentifier (x) => x . node () , Self :: PropertyIdentifier (x) => x . node () , Self :: String (x) => x . node () , Self :: NominalTypeAnnotation (x) => x . node () , Self :: TypeAnnotation (x) => x . node () , } } # [inline] fn node_mut (& mut self) -> & mut yak_sitter :: Node < 'tree > { match self { Self :: AccessibilityModifier (x) => x . node_mut () , Self :: OverrideModifier (x) => x . node_mut () , Self :: Question (x) => x . node_mut () , Self :: ComputedPropertyName (x) => x . node_mut () , Self :: Number (x) => x . node_mut () , Self :: PrivatePropertyIdentifier (x) => x . node_mut () , Self :: PropertyIdentifier (x) => x . node_mut () , Self :: String (x) => x . node_mut () , Self :: NominalTypeAnnotation (x) => x . node_mut () , Self :: TypeAnnotation (x) => x . node_mut () , } } # [inline] fn into_node (self) -> yak_sitter :: Node < 'tree > { match self { Self :: AccessibilityModifier (x) => x . into_node () , Self :: OverrideModifier (x) => x . into_node () , Self :: Question (x) => x . into_node () , Self :: ComputedPropertyName (x) => x . into_node () , Self :: Number (x) => x . into_node () , Self :: PrivatePropertyIdentifier (x) => x . into_node () , Self :: PropertyIdentifier (x) => x . into_node () , Self :: String (x) => x . into_node () , Self :: NominalTypeAnnotation (x) => x . into_node () , Self :: TypeAnnotation (x) => x . into_node () , } } }
    #[doc = "one of `{accessibility_modifier | override_modifier | computed_property_name | number | private_property_identifier | property_identifier | string | nominal_type_annotation | type_annotation | expression}`:\n- [AccessibilityModifier]\n- [OverrideModifier]\n- [ComputedPropertyName]\n- [Number]\n- [PrivatePropertyIdentifier]\n- [PropertyIdentifier]\n- [String]\n- [NominalTypeAnnotation]\n- [TypeAnnotation]\n- [Expression]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AccessibilityModifier_OverrideModifier_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_TypeAnnotation_Expression<
        'tree,
    > {
        AccessibilityModifier(AccessibilityModifier<'tree>),
        OverrideModifier(OverrideModifier<'tree>),
        ComputedPropertyName(ComputedPropertyName<'tree>),
        Number(Number<'tree>),
        PrivatePropertyIdentifier(PrivatePropertyIdentifier<'tree>),
        PropertyIdentifier(PropertyIdentifier<'tree>),
        String(String<'tree>),
        NominalTypeAnnotation(NominalTypeAnnotation<'tree>),
        TypeAnnotation(TypeAnnotation<'tree>),
        Expression(Expression<'tree>),
    }
    #[automatically_derived]
    impl < 'tree > AccessibilityModifier_OverrideModifier_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_TypeAnnotation_Expression < 'tree > { # [doc = "Returns the node if it is of kind `accessibility_modifier` ([AccessibilityModifier]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn accessibility_modifier (self) -> Option < AccessibilityModifier < 'tree > > { match self { Self :: AccessibilityModifier (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `override_modifier` ([OverrideModifier]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn override_modifier (self) -> Option < OverrideModifier < 'tree > > { match self { Self :: OverrideModifier (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `computed_property_name` ([ComputedPropertyName]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn computed_property_name (self) -> Option < ComputedPropertyName < 'tree > > { match self { Self :: ComputedPropertyName (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `number` ([Number]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn number (self) -> Option < Number < 'tree > > { match self { Self :: Number (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `private_property_identifier` ([PrivatePropertyIdentifier]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn private_property_identifier (self) -> Option < PrivatePropertyIdentifier < 'tree > > { match self { Self :: PrivatePropertyIdentifier (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `property_identifier` ([PropertyIdentifier]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn property_identifier (self) -> Option < PropertyIdentifier < 'tree > > { match self { Self :: PropertyIdentifier (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `string` ([String]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn string (self) -> Option < String < 'tree > > { match self { Self :: String (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `nominal_type_annotation` ([NominalTypeAnnotation]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn nominal_type_annotation (self) -> Option < NominalTypeAnnotation < 'tree > > { match self { Self :: NominalTypeAnnotation (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `type_annotation` ([TypeAnnotation]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn type_annotation (self) -> Option < TypeAnnotation < 'tree > > { match self { Self :: TypeAnnotation (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `expression` ([Expression]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn expression (self) -> Option < Expression < 'tree > > { match self { Self :: Expression (x) => Some (x) , _ => None , } } }
    #[automatically_derived]
    impl < 'tree > TryFrom < yak_sitter :: Node < 'tree >> for AccessibilityModifier_OverrideModifier_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_TypeAnnotation_Expression < 'tree > { type Error = type_sitter_lib :: IncorrectKind < 'tree > ; # [inline] fn try_from (node : yak_sitter :: Node < 'tree >) -> Result < Self , Self :: Error > { match node . kind () { "accessibility_modifier" => Ok (unsafe { Self :: AccessibilityModifier (< AccessibilityModifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "override_modifier" => Ok (unsafe { Self :: OverrideModifier (< OverrideModifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "computed_property_name" => Ok (unsafe { Self :: ComputedPropertyName (< ComputedPropertyName < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "number" => Ok (unsafe { Self :: Number (< Number < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "private_property_identifier" => Ok (unsafe { Self :: PrivatePropertyIdentifier (< PrivatePropertyIdentifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "property_identifier" => Ok (unsafe { Self :: PropertyIdentifier (< PropertyIdentifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "string" => Ok (unsafe { Self :: String (< String < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "nominal_type_annotation" => Ok (unsafe { Self :: NominalTypeAnnotation (< NominalTypeAnnotation < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "type_annotation" => Ok (unsafe { Self :: TypeAnnotation (< TypeAnnotation < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "expression" => Ok (unsafe { Self :: Expression (< Expression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , _ => Err (type_sitter_lib :: IncorrectKind { node , kind : < Self as type_sitter_lib :: TypedNode < 'tree >> :: KIND , }) } } }
    #[automatically_derived]
    impl < 'tree > type_sitter_lib :: TypedNode < 'tree > for AccessibilityModifier_OverrideModifier_ComputedPropertyName_Number_PrivatePropertyIdentifier_PropertyIdentifier_String_NominalTypeAnnotation_TypeAnnotation_Expression < 'tree > { const KIND : & 'static str = "{accessibility_modifier | override_modifier | computed_property_name | number | private_property_identifier | property_identifier | string | nominal_type_annotation | type_annotation | expression}" ; # [inline] fn node (& self) -> & yak_sitter :: Node < 'tree > { match self { Self :: AccessibilityModifier (x) => x . node () , Self :: OverrideModifier (x) => x . node () , Self :: ComputedPropertyName (x) => x . node () , Self :: Number (x) => x . node () , Self :: PrivatePropertyIdentifier (x) => x . node () , Self :: PropertyIdentifier (x) => x . node () , Self :: String (x) => x . node () , Self :: NominalTypeAnnotation (x) => x . node () , Self :: TypeAnnotation (x) => x . node () , Self :: Expression (x) => x . node () , } } # [inline] fn node_mut (& mut self) -> & mut yak_sitter :: Node < 'tree > { match self { Self :: AccessibilityModifier (x) => x . node_mut () , Self :: OverrideModifier (x) => x . node_mut () , Self :: ComputedPropertyName (x) => x . node_mut () , Self :: Number (x) => x . node_mut () , Self :: PrivatePropertyIdentifier (x) => x . node_mut () , Self :: PropertyIdentifier (x) => x . node_mut () , Self :: String (x) => x . node_mut () , Self :: NominalTypeAnnotation (x) => x . node_mut () , Self :: TypeAnnotation (x) => x . node_mut () , Self :: Expression (x) => x . node_mut () , } } # [inline] fn into_node (self) -> yak_sitter :: Node < 'tree > { match self { Self :: AccessibilityModifier (x) => x . into_node () , Self :: OverrideModifier (x) => x . into_node () , Self :: ComputedPropertyName (x) => x . into_node () , Self :: Number (x) => x . into_node () , Self :: PrivatePropertyIdentifier (x) => x . into_node () , Self :: PropertyIdentifier (x) => x . into_node () , Self :: String (x) => x . into_node () , Self :: NominalTypeAnnotation (x) => x . into_node () , Self :: TypeAnnotation (x) => x . into_node () , Self :: Expression (x) => x . into_node () , } } }
    #[doc = "one of `{accessibility_modifier | override_modifier | decorator | identifier | rest_pattern | nominal_type_annotation | pattern | this | type_annotation | expression}`:\n- [AccessibilityModifier]\n- [OverrideModifier]\n- [Decorator]\n- [Identifier]\n- [RestPattern]\n- [NominalTypeAnnotation]\n- [Pattern]\n- [This]\n- [TypeAnnotation]\n- [Expression]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AccessibilityModifier_OverrideModifier_Decorator_Identifier_RestPattern_NominalTypeAnnotation_Pattern_This_TypeAnnotation_Expression<
        'tree,
    > {
        AccessibilityModifier(AccessibilityModifier<'tree>),
        OverrideModifier(OverrideModifier<'tree>),
        Decorator(Decorator<'tree>),
        Identifier(Identifier<'tree>),
        RestPattern(RestPattern<'tree>),
        NominalTypeAnnotation(NominalTypeAnnotation<'tree>),
        Pattern(Pattern<'tree>),
        This(This<'tree>),
        TypeAnnotation(TypeAnnotation<'tree>),
        Expression(Expression<'tree>),
    }
    #[automatically_derived]
    impl < 'tree > AccessibilityModifier_OverrideModifier_Decorator_Identifier_RestPattern_NominalTypeAnnotation_Pattern_This_TypeAnnotation_Expression < 'tree > { # [doc = "Returns the node if it is of kind `accessibility_modifier` ([AccessibilityModifier]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn accessibility_modifier (self) -> Option < AccessibilityModifier < 'tree > > { match self { Self :: AccessibilityModifier (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `override_modifier` ([OverrideModifier]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn override_modifier (self) -> Option < OverrideModifier < 'tree > > { match self { Self :: OverrideModifier (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `decorator` ([Decorator]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn decorator (self) -> Option < Decorator < 'tree > > { match self { Self :: Decorator (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `identifier` ([Identifier]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn identifier (self) -> Option < Identifier < 'tree > > { match self { Self :: Identifier (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `rest_pattern` ([RestPattern]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn rest_pattern (self) -> Option < RestPattern < 'tree > > { match self { Self :: RestPattern (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `nominal_type_annotation` ([NominalTypeAnnotation]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn nominal_type_annotation (self) -> Option < NominalTypeAnnotation < 'tree > > { match self { Self :: NominalTypeAnnotation (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `pattern` ([Pattern]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn pattern (self) -> Option < Pattern < 'tree > > { match self { Self :: Pattern (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `this` ([This]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn this (self) -> Option < This < 'tree > > { match self { Self :: This (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `type_annotation` ([TypeAnnotation]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn type_annotation (self) -> Option < TypeAnnotation < 'tree > > { match self { Self :: TypeAnnotation (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `expression` ([Expression]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn expression (self) -> Option < Expression < 'tree > > { match self { Self :: Expression (x) => Some (x) , _ => None , } } }
    #[automatically_derived]
    impl < 'tree > TryFrom < yak_sitter :: Node < 'tree >> for AccessibilityModifier_OverrideModifier_Decorator_Identifier_RestPattern_NominalTypeAnnotation_Pattern_This_TypeAnnotation_Expression < 'tree > { type Error = type_sitter_lib :: IncorrectKind < 'tree > ; # [inline] fn try_from (node : yak_sitter :: Node < 'tree >) -> Result < Self , Self :: Error > { match node . kind () { "accessibility_modifier" => Ok (unsafe { Self :: AccessibilityModifier (< AccessibilityModifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "override_modifier" => Ok (unsafe { Self :: OverrideModifier (< OverrideModifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "decorator" => Ok (unsafe { Self :: Decorator (< Decorator < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "identifier" => Ok (unsafe { Self :: Identifier (< Identifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "rest_pattern" => Ok (unsafe { Self :: RestPattern (< RestPattern < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "nominal_type_annotation" => Ok (unsafe { Self :: NominalTypeAnnotation (< NominalTypeAnnotation < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "pattern" => Ok (unsafe { Self :: Pattern (< Pattern < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "this" => Ok (unsafe { Self :: This (< This < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "type_annotation" => Ok (unsafe { Self :: TypeAnnotation (< TypeAnnotation < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "expression" => Ok (unsafe { Self :: Expression (< Expression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , _ => Err (type_sitter_lib :: IncorrectKind { node , kind : < Self as type_sitter_lib :: TypedNode < 'tree >> :: KIND , }) } } }
    #[automatically_derived]
    impl < 'tree > type_sitter_lib :: TypedNode < 'tree > for AccessibilityModifier_OverrideModifier_Decorator_Identifier_RestPattern_NominalTypeAnnotation_Pattern_This_TypeAnnotation_Expression < 'tree > { const KIND : & 'static str = "{accessibility_modifier | override_modifier | decorator | identifier | rest_pattern | nominal_type_annotation | pattern | this | type_annotation | expression}" ; # [inline] fn node (& self) -> & yak_sitter :: Node < 'tree > { match self { Self :: AccessibilityModifier (x) => x . node () , Self :: OverrideModifier (x) => x . node () , Self :: Decorator (x) => x . node () , Self :: Identifier (x) => x . node () , Self :: RestPattern (x) => x . node () , Self :: NominalTypeAnnotation (x) => x . node () , Self :: Pattern (x) => x . node () , Self :: This (x) => x . node () , Self :: TypeAnnotation (x) => x . node () , Self :: Expression (x) => x . node () , } } # [inline] fn node_mut (& mut self) -> & mut yak_sitter :: Node < 'tree > { match self { Self :: AccessibilityModifier (x) => x . node_mut () , Self :: OverrideModifier (x) => x . node_mut () , Self :: Decorator (x) => x . node_mut () , Self :: Identifier (x) => x . node_mut () , Self :: RestPattern (x) => x . node_mut () , Self :: NominalTypeAnnotation (x) => x . node_mut () , Self :: Pattern (x) => x . node_mut () , Self :: This (x) => x . node_mut () , Self :: TypeAnnotation (x) => x . node_mut () , Self :: Expression (x) => x . node_mut () , } } # [inline] fn into_node (self) -> yak_sitter :: Node < 'tree > { match self { Self :: AccessibilityModifier (x) => x . into_node () , Self :: OverrideModifier (x) => x . into_node () , Self :: Decorator (x) => x . into_node () , Self :: Identifier (x) => x . into_node () , Self :: RestPattern (x) => x . into_node () , Self :: NominalTypeAnnotation (x) => x . into_node () , Self :: Pattern (x) => x . into_node () , Self :: This (x) => x . into_node () , Self :: TypeAnnotation (x) => x . into_node () , Self :: Expression (x) => x . into_node () , } } }
    #[doc = "one of `{identifier | rest_pattern}`:\n- [Identifier]\n- [RestPattern]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Identifier_RestPattern<'tree> {
        Identifier(Identifier<'tree>),
        RestPattern(RestPattern<'tree>),
    }
    #[automatically_derived]
    impl<'tree> Identifier_RestPattern<'tree> {
        #[doc = "Returns the node if it is of kind `identifier` ([Identifier]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn identifier(self) -> Option<Identifier<'tree>> {
            match self {
                Self::Identifier(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `rest_pattern` ([RestPattern]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn rest_pattern(self) -> Option<RestPattern<'tree>> {
            match self {
                Self::RestPattern(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Identifier_RestPattern<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "identifier" => Ok(unsafe {
                    Self :: Identifier (< Identifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "rest_pattern" => Ok(unsafe {
                    Self :: RestPattern (< RestPattern < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Identifier_RestPattern<'tree> {
        const KIND: &'static str = "{identifier | rest_pattern}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => x.node(),
                Self::RestPattern(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => x.node_mut(),
                Self::RestPattern(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => x.into_node(),
                Self::RestPattern(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{array_pattern | identifier | member_expression | non_null_expression | object_pattern | subscript_expression | undefined}`:\n- [ArrayPattern]\n- [Identifier]\n- [MemberExpression]\n- [NonNullExpression]\n- [ObjectPattern]\n- [SubscriptExpression]\n- [Undefined]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum ArrayPattern_Identifier_MemberExpression_NonNullExpression_ObjectPattern_SubscriptExpression_Undefined<
        'tree,
    > {
        ArrayPattern(ArrayPattern<'tree>),
        Identifier(Identifier<'tree>),
        MemberExpression(MemberExpression<'tree>),
        NonNullExpression(NonNullExpression<'tree>),
        ObjectPattern(ObjectPattern<'tree>),
        SubscriptExpression(SubscriptExpression<'tree>),
        Undefined(Undefined<'tree>),
    }
    #[automatically_derived]
    impl < 'tree > ArrayPattern_Identifier_MemberExpression_NonNullExpression_ObjectPattern_SubscriptExpression_Undefined < 'tree > { # [doc = "Returns the node if it is of kind `array_pattern` ([ArrayPattern]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn array_pattern (self) -> Option < ArrayPattern < 'tree > > { match self { Self :: ArrayPattern (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `identifier` ([Identifier]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn identifier (self) -> Option < Identifier < 'tree > > { match self { Self :: Identifier (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `member_expression` ([MemberExpression]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn member_expression (self) -> Option < MemberExpression < 'tree > > { match self { Self :: MemberExpression (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `non_null_expression` ([NonNullExpression]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn non_null_expression (self) -> Option < NonNullExpression < 'tree > > { match self { Self :: NonNullExpression (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `object_pattern` ([ObjectPattern]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn object_pattern (self) -> Option < ObjectPattern < 'tree > > { match self { Self :: ObjectPattern (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `subscript_expression` ([SubscriptExpression]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn subscript_expression (self) -> Option < SubscriptExpression < 'tree > > { match self { Self :: SubscriptExpression (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `undefined` ([Undefined]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn undefined (self) -> Option < Undefined < 'tree > > { match self { Self :: Undefined (x) => Some (x) , _ => None , } } }
    #[automatically_derived]
    impl < 'tree > TryFrom < yak_sitter :: Node < 'tree >> for ArrayPattern_Identifier_MemberExpression_NonNullExpression_ObjectPattern_SubscriptExpression_Undefined < 'tree > { type Error = type_sitter_lib :: IncorrectKind < 'tree > ; # [inline] fn try_from (node : yak_sitter :: Node < 'tree >) -> Result < Self , Self :: Error > { match node . kind () { "array_pattern" => Ok (unsafe { Self :: ArrayPattern (< ArrayPattern < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "identifier" => Ok (unsafe { Self :: Identifier (< Identifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "member_expression" => Ok (unsafe { Self :: MemberExpression (< MemberExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "non_null_expression" => Ok (unsafe { Self :: NonNullExpression (< NonNullExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "object_pattern" => Ok (unsafe { Self :: ObjectPattern (< ObjectPattern < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "subscript_expression" => Ok (unsafe { Self :: SubscriptExpression (< SubscriptExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , "undefined" => Ok (unsafe { Self :: Undefined (< Undefined < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node)) }) , _ => Err (type_sitter_lib :: IncorrectKind { node , kind : < Self as type_sitter_lib :: TypedNode < 'tree >> :: KIND , }) } } }
    #[automatically_derived]
    impl < 'tree > type_sitter_lib :: TypedNode < 'tree > for ArrayPattern_Identifier_MemberExpression_NonNullExpression_ObjectPattern_SubscriptExpression_Undefined < 'tree > { const KIND : & 'static str = "{array_pattern | identifier | member_expression | non_null_expression | object_pattern | subscript_expression | undefined}" ; # [inline] fn node (& self) -> & yak_sitter :: Node < 'tree > { match self { Self :: ArrayPattern (x) => x . node () , Self :: Identifier (x) => x . node () , Self :: MemberExpression (x) => x . node () , Self :: NonNullExpression (x) => x . node () , Self :: ObjectPattern (x) => x . node () , Self :: SubscriptExpression (x) => x . node () , Self :: Undefined (x) => x . node () , } } # [inline] fn node_mut (& mut self) -> & mut yak_sitter :: Node < 'tree > { match self { Self :: ArrayPattern (x) => x . node_mut () , Self :: Identifier (x) => x . node_mut () , Self :: MemberExpression (x) => x . node_mut () , Self :: NonNullExpression (x) => x . node_mut () , Self :: ObjectPattern (x) => x . node_mut () , Self :: SubscriptExpression (x) => x . node_mut () , Self :: Undefined (x) => x . node_mut () , } } # [inline] fn into_node (self) -> yak_sitter :: Node < 'tree > { match self { Self :: ArrayPattern (x) => x . into_node () , Self :: Identifier (x) => x . into_node () , Self :: MemberExpression (x) => x . into_node () , Self :: NonNullExpression (x) => x . into_node () , Self :: ObjectPattern (x) => x . into_node () , Self :: SubscriptExpression (x) => x . into_node () , Self :: Undefined (x) => x . into_node () , } } }
    #[doc = "one of `{escape_sequence | string_fragment}`:\n- [EscapeSequence]\n- [StringFragment]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum EscapeSequence_StringFragment<'tree> {
        EscapeSequence(EscapeSequence<'tree>),
        StringFragment(StringFragment<'tree>),
    }
    #[automatically_derived]
    impl<'tree> EscapeSequence_StringFragment<'tree> {
        #[doc = "Returns the node if it is of kind `escape_sequence` ([EscapeSequence]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn escape_sequence(self) -> Option<EscapeSequence<'tree>> {
            match self {
                Self::EscapeSequence(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `string_fragment` ([StringFragment]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn string_fragment(self) -> Option<StringFragment<'tree>> {
            match self {
                Self::StringFragment(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for EscapeSequence_StringFragment<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "escape_sequence" => {
                    Ok(unsafe {
                        Self :: EscapeSequence (< EscapeSequence < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                "string_fragment" => {
                    Ok(unsafe {
                        Self :: StringFragment (< StringFragment < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for EscapeSequence_StringFragment<'tree> {
        const KIND: &'static str = "{escape_sequence | string_fragment}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::EscapeSequence(x) => x.node(),
                Self::StringFragment(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::EscapeSequence(x) => x.node_mut(),
                Self::StringFragment(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::EscapeSequence(x) => x.into_node(),
                Self::StringFragment(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{expression | number | predefined_type | sequence_expression | string}`:\n- [Expression]\n- [Number]\n- [PredefinedType]\n- [SequenceExpression]\n- [String]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Expression_Number_PredefinedType_SequenceExpression_String<'tree> {
        Expression(Expression<'tree>),
        Number(Number<'tree>),
        PredefinedType(PredefinedType<'tree>),
        SequenceExpression(SequenceExpression<'tree>),
        String(String<'tree>),
    }
    #[automatically_derived]
    impl<'tree> Expression_Number_PredefinedType_SequenceExpression_String<'tree> {
        #[doc = "Returns the node if it is of kind `expression` ([Expression]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn expression(self) -> Option<Expression<'tree>> {
            match self {
                Self::Expression(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `number` ([Number]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn number(self) -> Option<Number<'tree>> {
            match self {
                Self::Number(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `predefined_type` ([PredefinedType]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn predefined_type(self) -> Option<PredefinedType<'tree>> {
            match self {
                Self::PredefinedType(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `sequence_expression` ([SequenceExpression]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn sequence_expression(self) -> Option<SequenceExpression<'tree>> {
            match self {
                Self::SequenceExpression(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `string` ([String]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn string(self) -> Option<String<'tree>> {
            match self {
                Self::String(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>>
        for Expression_Number_PredefinedType_SequenceExpression_String<'tree>
    {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "expression" => Ok(unsafe {
                    Self :: Expression (< Expression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "number" => {
                    Ok(unsafe {
                        Self :: Number (< Number < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                "predefined_type" => {
                    Ok(unsafe {
                        Self :: PredefinedType (< PredefinedType < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                "sequence_expression" => Ok(unsafe {
                    Self :: SequenceExpression (< SequenceExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "string" => {
                    Ok(unsafe {
                        Self :: String (< String < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree>
        for Expression_Number_PredefinedType_SequenceExpression_String<'tree>
    {
        const KIND: &'static str =
            "{expression | number | predefined_type | sequence_expression | string}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => x.node(),
                Self::Number(x) => x.node(),
                Self::PredefinedType(x) => x.node(),
                Self::SequenceExpression(x) => x.node(),
                Self::String(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => x.node_mut(),
                Self::Number(x) => x.node_mut(),
                Self::PredefinedType(x) => x.node_mut(),
                Self::SequenceExpression(x) => x.node_mut(),
                Self::String(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => x.into_node(),
                Self::Number(x) => x.into_node(),
                Self::PredefinedType(x) => x.into_node(),
                Self::SequenceExpression(x) => x.into_node(),
                Self::String(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{switch_case | switch_default}`:\n- [SwitchCase]\n- [SwitchDefault]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum SwitchCase_SwitchDefault<'tree> {
        SwitchCase(SwitchCase<'tree>),
        SwitchDefault(SwitchDefault<'tree>),
    }
    #[automatically_derived]
    impl<'tree> SwitchCase_SwitchDefault<'tree> {
        #[doc = "Returns the node if it is of kind `switch_case` ([SwitchCase]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn switch_case(self) -> Option<SwitchCase<'tree>> {
            match self {
                Self::SwitchCase(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `switch_default` ([SwitchDefault]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn switch_default(self) -> Option<SwitchDefault<'tree>> {
            match self {
                Self::SwitchDefault(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for SwitchCase_SwitchDefault<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "switch_case" => Ok(unsafe {
                    Self :: SwitchCase (< SwitchCase < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "switch_default" => Ok(unsafe {
                    Self::SwitchDefault(<SwitchDefault<'tree> as type_sitter_lib::TypedNode<
                        'tree,
                    >>::from_node_unchecked(node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for SwitchCase_SwitchDefault<'tree> {
        const KIND: &'static str = "{switch_case | switch_default}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::SwitchCase(x) => x.node(),
                Self::SwitchDefault(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::SwitchCase(x) => x.node_mut(),
                Self::SwitchDefault(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::SwitchCase(x) => x.into_node(),
                Self::SwitchDefault(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{escape_sequence | template_substitution}`:\n- [EscapeSequence]\n- [TemplateSubstitution]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum EscapeSequence_TemplateSubstitution<'tree> {
        EscapeSequence(EscapeSequence<'tree>),
        TemplateSubstitution(TemplateSubstitution<'tree>),
    }
    #[automatically_derived]
    impl<'tree> EscapeSequence_TemplateSubstitution<'tree> {
        #[doc = "Returns the node if it is of kind `escape_sequence` ([EscapeSequence]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn escape_sequence(self) -> Option<EscapeSequence<'tree>> {
            match self {
                Self::EscapeSequence(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `template_substitution` ([TemplateSubstitution]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn template_substitution(self) -> Option<TemplateSubstitution<'tree>> {
            match self {
                Self::TemplateSubstitution(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for EscapeSequence_TemplateSubstitution<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "escape_sequence" => {
                    Ok(unsafe {
                        Self :: EscapeSequence (< EscapeSequence < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                "template_substitution" => Ok(unsafe {
                    Self :: TemplateSubstitution (< TemplateSubstitution < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for EscapeSequence_TemplateSubstitution<'tree> {
        const KIND: &'static str = "{escape_sequence | template_substitution}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::EscapeSequence(x) => x.node(),
                Self::TemplateSubstitution(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::EscapeSequence(x) => x.node_mut(),
                Self::TemplateSubstitution(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::EscapeSequence(x) => x.into_node(),
                Self::TemplateSubstitution(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{_primary_type | infer_type}`:\n- [PrimaryType]\n- [InferType]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum PrimaryType_InferType<'tree> {
        PrimaryType(PrimaryType<'tree>),
        InferType(InferType<'tree>),
    }
    #[automatically_derived]
    impl<'tree> PrimaryType_InferType<'tree> {
        #[doc = "Returns the node if it is of kind `_primary_type` ([PrimaryType]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn primary_type(self) -> Option<PrimaryType<'tree>> {
            match self {
                Self::PrimaryType(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `infer_type` ([InferType]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn infer_type(self) -> Option<InferType<'tree>> {
            match self {
                Self::InferType(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for PrimaryType_InferType<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            if let Ok(this) = <PrimaryType<'tree> as TryFrom<_>>::try_from(node) {
                return Ok(Self::PrimaryType(this));
            }
            if let Ok(this) = <InferType<'tree> as TryFrom<_>>::try_from(node) {
                return Ok(Self::InferType(this));
            }
            Err(type_sitter_lib::IncorrectKind {
                node,
                kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
            })
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for PrimaryType_InferType<'tree> {
        const KIND: &'static str = "{_primary_type | infer_type}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::PrimaryType(x) => x.node(),
                Self::InferType(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::PrimaryType(x) => x.node_mut(),
                Self::InferType(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::PrimaryType(x) => x.into_node(),
                Self::InferType(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{_primary_type | constructor_type | function_type | infer_type | optional_parameter | optional_type | readonly_type | required_parameter | rest_type}`:\n- [PrimaryType]\n- [ConstructorType]\n- [FunctionType]\n- [InferType]\n- [OptionalParameter]\n- [OptionalType]\n- [ReadonlyType]\n- [RequiredParameter]\n- [RestType]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum PrimaryType_ConstructorType_FunctionType_InferType_OptionalParameter_OptionalType_ReadonlyType_RequiredParameter_RestType<
        'tree,
    > {
        PrimaryType(PrimaryType<'tree>),
        ConstructorType(ConstructorType<'tree>),
        FunctionType(FunctionType<'tree>),
        InferType(InferType<'tree>),
        OptionalParameter(OptionalParameter<'tree>),
        OptionalType(OptionalType<'tree>),
        ReadonlyType(ReadonlyType<'tree>),
        RequiredParameter(RequiredParameter<'tree>),
        RestType(RestType<'tree>),
    }
    #[automatically_derived]
    impl < 'tree > PrimaryType_ConstructorType_FunctionType_InferType_OptionalParameter_OptionalType_ReadonlyType_RequiredParameter_RestType < 'tree > { # [doc = "Returns the node if it is of kind `_primary_type` ([PrimaryType]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn primary_type (self) -> Option < PrimaryType < 'tree > > { match self { Self :: PrimaryType (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `constructor_type` ([ConstructorType]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn constructor_type (self) -> Option < ConstructorType < 'tree > > { match self { Self :: ConstructorType (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `function_type` ([FunctionType]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn function_type (self) -> Option < FunctionType < 'tree > > { match self { Self :: FunctionType (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `infer_type` ([InferType]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn infer_type (self) -> Option < InferType < 'tree > > { match self { Self :: InferType (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `optional_parameter` ([OptionalParameter]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn optional_parameter (self) -> Option < OptionalParameter < 'tree > > { match self { Self :: OptionalParameter (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `optional_type` ([OptionalType]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn optional_type (self) -> Option < OptionalType < 'tree > > { match self { Self :: OptionalType (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `readonly_type` ([ReadonlyType]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn readonly_type (self) -> Option < ReadonlyType < 'tree > > { match self { Self :: ReadonlyType (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `required_parameter` ([RequiredParameter]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn required_parameter (self) -> Option < RequiredParameter < 'tree > > { match self { Self :: RequiredParameter (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `rest_type` ([RestType]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn rest_type (self) -> Option < RestType < 'tree > > { match self { Self :: RestType (x) => Some (x) , _ => None , } } }
    #[automatically_derived]
    impl < 'tree > TryFrom < yak_sitter :: Node < 'tree >> for PrimaryType_ConstructorType_FunctionType_InferType_OptionalParameter_OptionalType_ReadonlyType_RequiredParameter_RestType < 'tree > { type Error = type_sitter_lib :: IncorrectKind < 'tree > ; # [inline] fn try_from (node : yak_sitter :: Node < 'tree >) -> Result < Self , Self :: Error > { if let Ok (this) = < PrimaryType < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: PrimaryType (this)) ; } if let Ok (this) = < ConstructorType < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: ConstructorType (this)) ; } if let Ok (this) = < FunctionType < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: FunctionType (this)) ; } if let Ok (this) = < InferType < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: InferType (this)) ; } if let Ok (this) = < OptionalParameter < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: OptionalParameter (this)) ; } if let Ok (this) = < OptionalType < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: OptionalType (this)) ; } if let Ok (this) = < ReadonlyType < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: ReadonlyType (this)) ; } if let Ok (this) = < RequiredParameter < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: RequiredParameter (this)) ; } if let Ok (this) = < RestType < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: RestType (this)) ; } Err (type_sitter_lib :: IncorrectKind { node , kind : < Self as type_sitter_lib :: TypedNode < 'tree >> :: KIND , }) } }
    #[automatically_derived]
    impl < 'tree > type_sitter_lib :: TypedNode < 'tree > for PrimaryType_ConstructorType_FunctionType_InferType_OptionalParameter_OptionalType_ReadonlyType_RequiredParameter_RestType < 'tree > { const KIND : & 'static str = "{_primary_type | constructor_type | function_type | infer_type | optional_parameter | optional_type | readonly_type | required_parameter | rest_type}" ; # [inline] fn node (& self) -> & yak_sitter :: Node < 'tree > { match self { Self :: PrimaryType (x) => x . node () , Self :: ConstructorType (x) => x . node () , Self :: FunctionType (x) => x . node () , Self :: InferType (x) => x . node () , Self :: OptionalParameter (x) => x . node () , Self :: OptionalType (x) => x . node () , Self :: ReadonlyType (x) => x . node () , Self :: RequiredParameter (x) => x . node () , Self :: RestType (x) => x . node () , } } # [inline] fn node_mut (& mut self) -> & mut yak_sitter :: Node < 'tree > { match self { Self :: PrimaryType (x) => x . node_mut () , Self :: ConstructorType (x) => x . node_mut () , Self :: FunctionType (x) => x . node_mut () , Self :: InferType (x) => x . node_mut () , Self :: OptionalParameter (x) => x . node_mut () , Self :: OptionalType (x) => x . node_mut () , Self :: ReadonlyType (x) => x . node_mut () , Self :: RequiredParameter (x) => x . node_mut () , Self :: RestType (x) => x . node_mut () , } } # [inline] fn into_node (self) -> yak_sitter :: Node < 'tree > { match self { Self :: PrimaryType (x) => x . into_node () , Self :: ConstructorType (x) => x . into_node () , Self :: FunctionType (x) => x . into_node () , Self :: InferType (x) => x . into_node () , Self :: OptionalParameter (x) => x . into_node () , Self :: OptionalType (x) => x . into_node () , Self :: ReadonlyType (x) => x . into_node () , Self :: RequiredParameter (x) => x . into_node () , Self :: RestType (x) => x . into_node () , } } }
    #[doc = "one of `{_primary_nominal_type | _primary_type | constructor_type | function_nominal_type | function_type | infer_type | nullable_nominal_type | readonly_type}`:\n- [PrimaryNominalType]\n- [PrimaryType]\n- [ConstructorType]\n- [FunctionNominalType]\n- [FunctionType]\n- [InferType]\n- [NullableNominalType]\n- [ReadonlyType]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum PrimaryNominalType_PrimaryType_ConstructorType_FunctionNominalType_FunctionType_InferType_NullableNominalType_ReadonlyType<
        'tree,
    > {
        PrimaryNominalType(PrimaryNominalType<'tree>),
        PrimaryType(PrimaryType<'tree>),
        ConstructorType(ConstructorType<'tree>),
        FunctionNominalType(FunctionNominalType<'tree>),
        FunctionType(FunctionType<'tree>),
        InferType(InferType<'tree>),
        NullableNominalType(NullableNominalType<'tree>),
        ReadonlyType(ReadonlyType<'tree>),
    }
    #[automatically_derived]
    impl < 'tree > PrimaryNominalType_PrimaryType_ConstructorType_FunctionNominalType_FunctionType_InferType_NullableNominalType_ReadonlyType < 'tree > { # [doc = "Returns the node if it is of kind `_primary_nominal_type` ([PrimaryNominalType]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn primary_nominal_type (self) -> Option < PrimaryNominalType < 'tree > > { match self { Self :: PrimaryNominalType (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `_primary_type` ([PrimaryType]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn primary_type (self) -> Option < PrimaryType < 'tree > > { match self { Self :: PrimaryType (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `constructor_type` ([ConstructorType]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn constructor_type (self) -> Option < ConstructorType < 'tree > > { match self { Self :: ConstructorType (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `function_nominal_type` ([FunctionNominalType]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn function_nominal_type (self) -> Option < FunctionNominalType < 'tree > > { match self { Self :: FunctionNominalType (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `function_type` ([FunctionType]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn function_type (self) -> Option < FunctionType < 'tree > > { match self { Self :: FunctionType (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `infer_type` ([InferType]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn infer_type (self) -> Option < InferType < 'tree > > { match self { Self :: InferType (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `nullable_nominal_type` ([NullableNominalType]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn nullable_nominal_type (self) -> Option < NullableNominalType < 'tree > > { match self { Self :: NullableNominalType (x) => Some (x) , _ => None , } } # [doc = "Returns the node if it is of kind `readonly_type` ([ReadonlyType]), otherwise returns None"] # [inline] # [allow (unused , non_snake_case)] pub fn readonly_type (self) -> Option < ReadonlyType < 'tree > > { match self { Self :: ReadonlyType (x) => Some (x) , _ => None , } } }
    #[automatically_derived]
    impl < 'tree > TryFrom < yak_sitter :: Node < 'tree >> for PrimaryNominalType_PrimaryType_ConstructorType_FunctionNominalType_FunctionType_InferType_NullableNominalType_ReadonlyType < 'tree > { type Error = type_sitter_lib :: IncorrectKind < 'tree > ; # [inline] fn try_from (node : yak_sitter :: Node < 'tree >) -> Result < Self , Self :: Error > { if let Ok (this) = < PrimaryNominalType < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: PrimaryNominalType (this)) ; } if let Ok (this) = < PrimaryType < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: PrimaryType (this)) ; } if let Ok (this) = < ConstructorType < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: ConstructorType (this)) ; } if let Ok (this) = < FunctionNominalType < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: FunctionNominalType (this)) ; } if let Ok (this) = < FunctionType < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: FunctionType (this)) ; } if let Ok (this) = < InferType < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: InferType (this)) ; } if let Ok (this) = < NullableNominalType < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: NullableNominalType (this)) ; } if let Ok (this) = < ReadonlyType < 'tree > as TryFrom < _ >> :: try_from (node) { return Ok (Self :: ReadonlyType (this)) ; } Err (type_sitter_lib :: IncorrectKind { node , kind : < Self as type_sitter_lib :: TypedNode < 'tree >> :: KIND , }) } }
    #[automatically_derived]
    impl < 'tree > type_sitter_lib :: TypedNode < 'tree > for PrimaryNominalType_PrimaryType_ConstructorType_FunctionNominalType_FunctionType_InferType_NullableNominalType_ReadonlyType < 'tree > { const KIND : & 'static str = "{_primary_nominal_type | _primary_type | constructor_type | function_nominal_type | function_type | infer_type | nullable_nominal_type | readonly_type}" ; # [inline] fn node (& self) -> & yak_sitter :: Node < 'tree > { match self { Self :: PrimaryNominalType (x) => x . node () , Self :: PrimaryType (x) => x . node () , Self :: ConstructorType (x) => x . node () , Self :: FunctionNominalType (x) => x . node () , Self :: FunctionType (x) => x . node () , Self :: InferType (x) => x . node () , Self :: NullableNominalType (x) => x . node () , Self :: ReadonlyType (x) => x . node () , } } # [inline] fn node_mut (& mut self) -> & mut yak_sitter :: Node < 'tree > { match self { Self :: PrimaryNominalType (x) => x . node_mut () , Self :: PrimaryType (x) => x . node_mut () , Self :: ConstructorType (x) => x . node_mut () , Self :: FunctionNominalType (x) => x . node_mut () , Self :: FunctionType (x) => x . node_mut () , Self :: InferType (x) => x . node_mut () , Self :: NullableNominalType (x) => x . node_mut () , Self :: ReadonlyType (x) => x . node_mut () , } } # [inline] fn into_node (self) -> yak_sitter :: Node < 'tree > { match self { Self :: PrimaryNominalType (x) => x . into_node () , Self :: PrimaryType (x) => x . into_node () , Self :: ConstructorType (x) => x . into_node () , Self :: FunctionNominalType (x) => x . into_node () , Self :: FunctionType (x) => x . into_node () , Self :: InferType (x) => x . into_node () , Self :: NullableNominalType (x) => x . into_node () , Self :: ReadonlyType (x) => x . into_node () , } } }
    #[doc = "one of `{expression | type_arguments}`:\n- [Expression]\n- [TypeArguments]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Expression_TypeArguments<'tree> {
        Expression(Expression<'tree>),
        TypeArguments(TypeArguments<'tree>),
    }
    #[automatically_derived]
    impl<'tree> Expression_TypeArguments<'tree> {
        #[doc = "Returns the node if it is of kind `expression` ([Expression]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn expression(self) -> Option<Expression<'tree>> {
            match self {
                Self::Expression(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `type_arguments` ([TypeArguments]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn type_arguments(self) -> Option<TypeArguments<'tree>> {
            match self {
                Self::TypeArguments(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Expression_TypeArguments<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "expression" => Ok(unsafe {
                    Self :: Expression (< Expression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "type_arguments" => Ok(unsafe {
                    Self::TypeArguments(<TypeArguments<'tree> as type_sitter_lib::TypedNode<
                        'tree,
                    >>::from_node_unchecked(node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Expression_TypeArguments<'tree> {
        const KIND: &'static str = "{expression | type_arguments}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => x.node(),
                Self::TypeArguments(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => x.node_mut(),
                Self::TypeArguments(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => x.into_node(),
                Self::TypeArguments(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{nominal_type_parameter | type_parameter}`:\n- [NominalTypeParameter]\n- [TypeParameter]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum NominalTypeParameter_TypeParameter<'tree> {
        NominalTypeParameter(NominalTypeParameter<'tree>),
        TypeParameter(TypeParameter<'tree>),
    }
    #[automatically_derived]
    impl<'tree> NominalTypeParameter_TypeParameter<'tree> {
        #[doc = "Returns the node if it is of kind `nominal_type_parameter` ([NominalTypeParameter]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn nominal_type_parameter(self) -> Option<NominalTypeParameter<'tree>> {
            match self {
                Self::NominalTypeParameter(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `type_parameter` ([TypeParameter]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn type_parameter(self) -> Option<TypeParameter<'tree>> {
            match self {
                Self::TypeParameter(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for NominalTypeParameter_TypeParameter<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "nominal_type_parameter" => Ok(unsafe {
                    Self :: NominalTypeParameter (< NominalTypeParameter < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "type_parameter" => Ok(unsafe {
                    Self::TypeParameter(<TypeParameter<'tree> as type_sitter_lib::TypedNode<
                        'tree,
                    >>::from_node_unchecked(node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for NominalTypeParameter_TypeParameter<'tree> {
        const KIND: &'static str = "{nominal_type_parameter | type_parameter}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::NominalTypeParameter(x) => x.node(),
                Self::TypeParameter(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::NominalTypeParameter(x) => x.node_mut(),
                Self::TypeParameter(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::NominalTypeParameter(x) => x.into_node(),
                Self::TypeParameter(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{identifier | this}`:\n- [Identifier]\n- [This]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Identifier_This<'tree> {
        Identifier(Identifier<'tree>),
        This(This<'tree>),
    }
    #[automatically_derived]
    impl<'tree> Identifier_This<'tree> {
        #[doc = "Returns the node if it is of kind `identifier` ([Identifier]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn identifier(self) -> Option<Identifier<'tree>> {
            match self {
                Self::Identifier(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `this` ([This]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn this(self) -> Option<This<'tree>> {
            match self {
                Self::This(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Identifier_This<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "identifier" => Ok(unsafe {
                    Self :: Identifier (< Identifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "this" => Ok(unsafe {
                    Self::This(
                        <This<'tree> as type_sitter_lib::TypedNode<'tree>>::from_node_unchecked(
                            node,
                        ),
                    )
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Identifier_This<'tree> {
        const KIND: &'static str = "{identifier | this}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => x.node(),
                Self::This(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => x.node_mut(),
                Self::This(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => x.into_node(),
                Self::This(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{call_expression | identifier | member_expression | subscript_expression}`:\n- [CallExpression]\n- [Identifier]\n- [MemberExpression]\n- [SubscriptExpression]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum CallExpression_Identifier_MemberExpression_SubscriptExpression<'tree> {
        CallExpression(CallExpression<'tree>),
        Identifier(Identifier<'tree>),
        MemberExpression(MemberExpression<'tree>),
        SubscriptExpression(SubscriptExpression<'tree>),
    }
    #[automatically_derived]
    impl<'tree> CallExpression_Identifier_MemberExpression_SubscriptExpression<'tree> {
        #[doc = "Returns the node if it is of kind `call_expression` ([CallExpression]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn call_expression(self) -> Option<CallExpression<'tree>> {
            match self {
                Self::CallExpression(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `identifier` ([Identifier]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn identifier(self) -> Option<Identifier<'tree>> {
            match self {
                Self::Identifier(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `member_expression` ([MemberExpression]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn member_expression(self) -> Option<MemberExpression<'tree>> {
            match self {
                Self::MemberExpression(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `subscript_expression` ([SubscriptExpression]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn subscript_expression(self) -> Option<SubscriptExpression<'tree>> {
            match self {
                Self::SubscriptExpression(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>>
        for CallExpression_Identifier_MemberExpression_SubscriptExpression<'tree>
    {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "call_expression" => {
                    Ok(unsafe {
                        Self :: CallExpression (< CallExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                "identifier" => Ok(unsafe {
                    Self :: Identifier (< Identifier < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "member_expression" => Ok(unsafe {
                    Self :: MemberExpression (< MemberExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "subscript_expression" => Ok(unsafe {
                    Self :: SubscriptExpression (< SubscriptExpression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree>
        for CallExpression_Identifier_MemberExpression_SubscriptExpression<'tree>
    {
        const KIND: &'static str =
            "{call_expression | identifier | member_expression | subscript_expression}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::CallExpression(x) => x.node(),
                Self::Identifier(x) => x.node(),
                Self::MemberExpression(x) => x.node(),
                Self::SubscriptExpression(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::CallExpression(x) => x.node_mut(),
                Self::Identifier(x) => x.node_mut(),
                Self::MemberExpression(x) => x.node_mut(),
                Self::SubscriptExpression(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::CallExpression(x) => x.into_node(),
                Self::Identifier(x) => x.into_node(),
                Self::MemberExpression(x) => x.into_node(),
                Self::SubscriptExpression(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{expression | number}`:\n- [Expression]\n- [Number]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Expression_Number<'tree> {
        Expression(Expression<'tree>),
        Number(Number<'tree>),
    }
    #[automatically_derived]
    impl<'tree> Expression_Number<'tree> {
        #[doc = "Returns the node if it is of kind `expression` ([Expression]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn expression(self) -> Option<Expression<'tree>> {
            match self {
                Self::Expression(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `number` ([Number]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn number(self) -> Option<Number<'tree>> {
            match self {
                Self::Number(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Expression_Number<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "expression" => Ok(unsafe {
                    Self :: Expression (< Expression < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "number" => {
                    Ok(unsafe {
                        Self :: Number (< Number < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                    })
                }
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Expression_Number<'tree> {
        const KIND: &'static str = "{expression | number}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => x.node(),
                Self::Number(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => x.node_mut(),
                Self::Number(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => x.into_node(),
                Self::Number(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{! | + | - | delete | typeof | void | ~}`:\n- [symbols::Not]\n- [symbols::Add]\n- [symbols::Sub]\n- [unnamed::Delete]\n- [unnamed::Typeof]\n- [unnamed::Void]\n- [symbols::BitNot]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Not_Add_Sub_Delete_Typeof_Void_BitNot<'tree> {
        Not(symbols::Not<'tree>),
        Add(symbols::Add<'tree>),
        Sub(symbols::Sub<'tree>),
        Delete(unnamed::Delete<'tree>),
        Typeof(unnamed::Typeof<'tree>),
        Void(unnamed::Void<'tree>),
        BitNot(symbols::BitNot<'tree>),
    }
    #[automatically_derived]
    impl<'tree> Not_Add_Sub_Delete_Typeof_Void_BitNot<'tree> {
        #[doc = "Returns the node if it is of kind `!` ([symbols::Not]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn not(self) -> Option<symbols::Not<'tree>> {
            match self {
                Self::Not(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `+` ([symbols::Add]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn add(self) -> Option<symbols::Add<'tree>> {
            match self {
                Self::Add(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `-` ([symbols::Sub]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn sub(self) -> Option<symbols::Sub<'tree>> {
            match self {
                Self::Sub(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `delete` ([unnamed::Delete]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn delete(self) -> Option<unnamed::Delete<'tree>> {
            match self {
                Self::Delete(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `typeof` ([unnamed::Typeof]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn r#typeof(self) -> Option<unnamed::Typeof<'tree>> {
            match self {
                Self::Typeof(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `void` ([unnamed::Void]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn void(self) -> Option<unnamed::Void<'tree>> {
            match self {
                Self::Void(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `~` ([symbols::BitNot]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn bit_not(self) -> Option<symbols::BitNot<'tree>> {
            match self {
                Self::BitNot(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for Not_Add_Sub_Delete_Typeof_Void_BitNot<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "!" => Ok(unsafe {
                    Self :: Not (< symbols :: Not < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "+" => Ok(unsafe {
                    Self :: Add (< symbols :: Add < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "-" => Ok(unsafe {
                    Self :: Sub (< symbols :: Sub < 'tree > as type_sitter_lib :: TypedNode < 'tree >> :: from_node_unchecked (node))
                }),
                "delete" => Ok(unsafe {
                    Self::Delete(<unnamed::Delete<'tree> as type_sitter_lib::TypedNode<
                        'tree,
                    >>::from_node_unchecked(node))
                }),
                "typeof" => Ok(unsafe {
                    Self::Typeof(<unnamed::Typeof<'tree> as type_sitter_lib::TypedNode<
                        'tree,
                    >>::from_node_unchecked(node))
                }),
                "void" => Ok(unsafe {
                    Self::Void(<unnamed::Void<'tree> as type_sitter_lib::TypedNode<
                        'tree,
                    >>::from_node_unchecked(node))
                }),
                "~" => Ok(unsafe {
                    Self::BitNot(<symbols::BitNot<'tree> as type_sitter_lib::TypedNode<
                        'tree,
                    >>::from_node_unchecked(node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for Not_Add_Sub_Delete_Typeof_Void_BitNot<'tree> {
        const KIND: &'static str = "{! | + | - | delete | typeof | void | ~}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::Not(x) => x.node(),
                Self::Add(x) => x.node(),
                Self::Sub(x) => x.node(),
                Self::Delete(x) => x.node(),
                Self::Typeof(x) => x.node(),
                Self::Void(x) => x.node(),
                Self::BitNot(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::Not(x) => x.node_mut(),
                Self::Add(x) => x.node_mut(),
                Self::Sub(x) => x.node_mut(),
                Self::Delete(x) => x.node_mut(),
                Self::Typeof(x) => x.node_mut(),
                Self::Void(x) => x.node_mut(),
                Self::BitNot(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::Not(x) => x.into_node(),
                Self::Add(x) => x.into_node(),
                Self::Sub(x) => x.into_node(),
                Self::Delete(x) => x.into_node(),
                Self::Typeof(x) => x.into_node(),
                Self::Void(x) => x.into_node(),
                Self::BitNot(x) => x.into_node(),
            }
        }
    }
    #[doc = "one of `{++ | --}`:\n- [symbols::AddAdd]\n- [symbols::SubSub]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AddAdd_SubSub<'tree> {
        AddAdd(symbols::AddAdd<'tree>),
        SubSub(symbols::SubSub<'tree>),
    }
    #[automatically_derived]
    impl<'tree> AddAdd_SubSub<'tree> {
        #[doc = "Returns the node if it is of kind `++` ([symbols::AddAdd]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn add_add(self) -> Option<symbols::AddAdd<'tree>> {
            match self {
                Self::AddAdd(x) => Some(x),
                _ => None,
            }
        }
        #[doc = "Returns the node if it is of kind `--` ([symbols::SubSub]), otherwise returns None"]
        #[inline]
        #[allow(unused, non_snake_case)]
        pub fn sub_sub(self) -> Option<symbols::SubSub<'tree>> {
            match self {
                Self::SubSub(x) => Some(x),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl<'tree> TryFrom<yak_sitter::Node<'tree>> for AddAdd_SubSub<'tree> {
        type Error = type_sitter_lib::IncorrectKind<'tree>;
        #[inline]
        fn try_from(node: yak_sitter::Node<'tree>) -> Result<Self, Self::Error> {
            match node.kind() {
                "++" => Ok(unsafe {
                    Self::AddAdd(<symbols::AddAdd<'tree> as type_sitter_lib::TypedNode<
                        'tree,
                    >>::from_node_unchecked(node))
                }),
                "--" => Ok(unsafe {
                    Self::SubSub(<symbols::SubSub<'tree> as type_sitter_lib::TypedNode<
                        'tree,
                    >>::from_node_unchecked(node))
                }),
                _ => Err(type_sitter_lib::IncorrectKind {
                    node,
                    kind: <Self as type_sitter_lib::TypedNode<'tree>>::KIND,
                }),
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter_lib::TypedNode<'tree> for AddAdd_SubSub<'tree> {
        const KIND: &'static str = "{++ | --}";
        #[inline]
        fn node(&self) -> &yak_sitter::Node<'tree> {
            match self {
                Self::AddAdd(x) => x.node(),
                Self::SubSub(x) => x.node(),
            }
        }
        #[inline]
        fn node_mut(&mut self) -> &mut yak_sitter::Node<'tree> {
            match self {
                Self::AddAdd(x) => x.node_mut(),
                Self::SubSub(x) => x.node_mut(),
            }
        }
        #[inline]
        fn into_node(self) -> yak_sitter::Node<'tree> {
            match self {
                Self::AddAdd(x) => x.into_node(),
                Self::SubSub(x) => x.into_node(),
            }
        }
    }
}
