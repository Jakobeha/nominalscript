#![doc = include_str!("../README.md")]

/// Static analysis, typing rules, and other semantic rules
// pub mod analyses;
/// Syntax (nodes queries, annotations), and "syntax package" which stores all syntax nodes in a package
pub mod syntax;
/// Diagnostics (errors/warnings/etc) and logging
pub mod diagnostics;
/// Semantic "thin" (pre-resolution) and "fat" (post-resolution) data-types
pub mod semantic;
/// Import resolution, exports. Also includes the compiled output
// pub mod import_export;
/// Project datastructure which contains everything
// mod project;
/// Utilities which could go in any crate
pub mod misc;
/// This is the file with the one function (+ wrappers) which transpiles everything.
///
/// It really is just one massive function.
/// Maybe I will end up refactoring out a lot of the functionality like I've already done for the
/// type analysis and scope resolution, so it will be less massive.
/// But honestly, it's just a really straightforward algorithm, and has a lot of cases to handle
/// for all of JS/TS's different expressions, but all of the cases are really straightforward
/// (with the less straightforward stuff in those other modules)
// pub mod compile;
/// Code generated by type-sitter
mod type_sitter;
mod compiler;
mod package;
/// Storage (allocation) helpers
pub mod storage;

use std::path::PathBuf;
use clap::Parser;
use compiler::{Compiler, IncrementalCompiler};

#[derive(Parser)]
#[command(author, version, about, long_about)]
/// Compiles a NominalScript package. Use `-w` to incrementally recompile on changes.
///
/// A NominalScript package is a folder with at least one of: `src/`, `bin/`, and `tests/`. Sources
/// from these paths are compiled into `out/src/`, `out/bin/`, and `out/tests/` respectively. Any
/// file in a source path with `.ns` extension is compiled into a `.ts` file, and any other file is
/// simply copied into the corresponding output path.
///
/// NominalScript is a language which adds a Nominal type system to TypeScript, like how TypeScript
/// adds a structural type system over JavaScript. See the NominalScript reference at
/// https://github.com/nominalscript/nominalscript/blob/master/docs/reference.md for more.
pub struct AppArgs {
    /// Path to the package
    package_path: PathBuf,
    /// Path to more packages. This is useful when you are working on multiple NominalScript
    /// packages, you can compile and watch all of them with a single command.
    package_paths: Vec<PathBuf>,
    /// If set, will incrementally recompile when detecting changes to the source directories.
    /// Otherwise, we exit after compiling once.
    #[arg(short, long)]
    watch: bool,
    /// Experimental: if set, will save compilation data AND load existing data on startup.
    /// Otherwise, the first compilation is a full pass.
    #[arg(short, long)]
    persist: bool,
}

/// Run the program. This adds a CLI I/O wrapper to [Compiler::run] and [IncrementalCompiler::run],
/// which actually run the batch and incremental compilers respectively.
fn main() {
    let AppArgs { package_path, mut package_paths, watch, persist } = AppArgs::parse();
    package_paths.insert(0, package_path);
    env_logger::init();

    if persist {
        eprintln!("Sorry, persisting compilation data is not yet implemented");
    }

    match watch {
        false => Compiler::run(package_paths),
        true => IncrementalCompiler::run(package_paths)
    }
}
